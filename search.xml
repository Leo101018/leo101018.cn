<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>针对硬盘大于2TB，centos7系统安装问题说明</title>
    <url>/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="针对硬盘大于2TB，centos7系统安装问题说明"><a href="#针对硬盘大于2TB，centos7系统安装问题说明" class="headerlink" title="针对硬盘大于2TB，centos7系统安装问题说明"></a><a href="https://www.cnblogs.com/Leo101018/p/13806461.html">针对硬盘大于2TB，centos7系统安装问题说明</a></h1><p>硬盘分区常见类型：</p>
<p>msdos（mbr分区）</p>
<p>gpt（gpt分区）</p>
<p>系统安装默认采用mbr分区。</p>
<p>MBR分区表(即主引导记录) 最大只支持2TB的分区，最多只支持4个主分区或3个主分区加一个扩展分区，信息只存储在一个区域；GPT（即GUID分区表），是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式，与MBR分区方式相比，突破4个主分区限制，每个磁盘最多支持128个分区，支持大于2T的分区，最大卷可达 18EB，信息存储在多个区域，当一部分受损后可修复。</p>
<p>设置GPT方式有UEFI和BIOS两种方式，UEFI启动是一种新的主板引导项，与传统的Bios方式相比可以提高开机后操作系统的启动速度。如今很多主板已经直接支持UEFI，这种场景下可以直接通过UEFI的方式设置GPT方式，如若主板不支持，那么还得通过传统的Bios方式强制设置GPT方式。</p>
<p>针对uefi启动，采用gpt分区，需要单独划分一个uefi分区</p>
<img src="/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/970770-20200929110620548-1970820754.png" class="" title="img">

<p>针对bios启动，mbr方式分区大于2TB硬盘会报错，如下</p>
<img src="/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/970770-20200929111340979-1715145746.png" class="" title="img">

<p> 此时bios启动安装时，输入inst.gpt强制采用gpt分区（实际这不不做也没关系）</p>
<img src="/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/970770-20200929111451537-931922777.png" class="" title="img">

<p>进入到分区页面</p>
<img src="/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/970770-20200929111945993-147036960.png" class="" title="img">

<p>关键需要划分bios boot分区，其它分区正常划分即可。</p>
<p>投机方式：将所有分区删除，点击standard标准分区，点击自动划分分区，就会自动将bios boot分区划分好，之后将其它不用分区删除，按照自己规划进行划分即可。</p>
<p>注意，bios boot分区必须是标准分区，文件系统为bios boot，否则会报错。</p>
<p>后续正常安装即可。</p>
]]></content>
      <categories>
        <category>CentOS</category>
        <category>Install</category>
      </categories>
      <tags>
        <tag>centos-install</tag>
      </tags>
  </entry>
  <entry>
    <title>vim详解</title>
    <url>/2022/10/25/Linux/vim/vim/</url>
    <content><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>vim：Linux环境下编辑器。</p>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p><strong>vim键盘图：</strong></p>
<img src="/2022/10/25/Linux/vim/vim/image-20221014131203980.png" class="" title="image-20221014131203980">



<h2 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h2><p><strong>vi&#x2F;vim 共分为三种模式，分别是</strong></p>
<p><strong>命令模式（Command mode）</strong></p>
<p><strong>插入模式（输入模式）（Insert mode）</strong></p>
<p><strong>底线命令模式（末行模式）（Last line mode）</strong></p>
<h3 id="命令模式（正常模式、普通模式）（normal-mode）"><a href="#命令模式（正常模式、普通模式）（normal-mode）" class="headerlink" title="命令模式（正常模式、普通模式）（normal mode）"></a>命令模式（正常模式、普通模式）（normal mode）</h3><p>刚启动 vi&#x2F;vim，便进入了命令模式。</p>
<p>此模式下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>常用的几个命令：</p>
<ul>
<li><strong>i 切换到插入模式，以输入字符。</strong></li>
<li><strong>x 删除当前光标所在处的字符。</strong></li>
<li><strong>: 切换到末行命令模式，以在最底一行输入命令。</strong></li>
</ul>
<p>命令模式只有一些最基本的命令，因此仍要依靠末行命令模式输入更多命令。</p>
<h3 id="输入模式（insert-mode）"><a href="#输入模式（insert-mode）" class="headerlink" title="输入模式（insert mode）"></a>输入模式（insert mode）</h3><p>命令模式下按下i就进入了输入模式</p>
<p>使用esc退出输入模式，回到命令模式。</p>
<h3 id="末行模式（last-line-mode）"><a href="#末行模式（last-line-mode）" class="headerlink" title="末行模式（last line mode）"></a>末行模式（last line mode）</h3><p>在命令模式下按下:（英文冒号）就进入了末行命令模式。</p>
<p>末行命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在末行命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出末行命令模式。</p>
<h3 id="3种模式图解"><a href="#3种模式图解" class="headerlink" title="3种模式图解"></a>3种模式图解</h3><img src="/2022/10/25/Linux/vim/vim/image-20221014131933608.png" class="" title="image-20221014131933608">



<h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。</p>
<h3 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h3><p>正常模式下，按R进入。</p>
<h2 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><p>h：光标向左移动一个字符，←</p>
<p>j：光标向下移动一个字符，↓</p>
<p>k：光标向上移动一个字符，↑</p>
<p>l：光标向右移动一个字符，→</p>
<p>例：</p>
<p>向下移动30行，30j</p>
<p>Ctrl+f：屏幕『向下』移动一页</p>
<p>Ctrl+b：屏幕『向上』移动一页</p>
<p>Ctrl+d：屏幕『向下』移动半页</p>
<p>Ctrl+u：屏幕『向上』移动半页</p>
<p>+：光标移动到非空格符的下一行</p>
<p>-：光标移动到非空格符的上一行</p>
<p>n+空格：那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</p>
<p>0：光标移动到这一行最前面。</p>
<p>g0：移到光标所在屏幕行行首。</p>
<p>^：移动到本行第一个非空白字符。</p>
<p>g^：同 ^ ，但是移动到当前屏幕行第一个非空字符处。</p>
<p>$：光标移动到这一行最后面。</p>
<p>g$：移动光标所在屏幕行行尾。</p>
<p>n|：把光标移到第n列上。</p>
<p>H：光标移动到<strong>这个屏幕</strong>的最上方那一行的第一个字符</p>
<p>M：光标移动到<strong>这个屏幕</strong>的中央那一行的第一个字符</p>
<p>L：光标移动到<strong>这个屏幕</strong>的最下方那一行的第一个字符</p>
<p>G：光标移动到这个文件的最后一行(常用)</p>
<p>nG：n 为数字。移动到这个文件的第 n 行。</p>
<p>gg：移动到这个文件的第一行，相当于 1G 啊！ (常用)。</p>
<p>n+回车：n 为数字。光标从当前行向下移动 n 行(常用)。</p>
<p>w：前移一个单词，光标停在下一个单词开头</p>
<p>W：移动下一个单词开头，但忽略一些标点</p>
<p>e：前移一个单词，光标停在下一个单词末尾</p>
<p>E：移动到下一个单词末尾，如果词尾有标点，则移动到标点</p>
<p>b：后移一个单词，光标停在上一个单词开头</p>
<p>B：移动到上一个单词开头，忽略一些标点</p>
<h4 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h4><p>[n]x：剪切光标右边n个字符，相当于d[n]l。</p>
<p>[n]X：剪切光标左边n个字符，相当于d[n]h。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>yy or Y：复制整行文本。</p>
<p>y[n]w：复制一(n)个词。</p>
<p>y[n]l：复制光标右边1(n)个字符。</p>
<p>y[n]h：复制光标左边1(n)个字符。</p>
<p>y$：从光标当前位置复制到行尾。</p>
<p>y0：从光标当前位置复制到行首。</p>
<p>:m,ny+回车：复制m行到n行的内容。</p>
<p>y1G或ygg：复制光标以上的所有行。</p>
<p>yG：复制光标以下的所有行。</p>
<p>y：复制在可视模式下选中的文本。</p>
<h4 id="删除（剪切）"><a href="#删除（剪切）" class="headerlink" title="删除（剪切）"></a>删除（剪切）</h4><p>[n] dd：删除（剪切）1(n)行。</p>
<p>d[n]l：删除（剪切）光标右边1(n)个字符。</p>
<p>d[n]h：删除（剪切）光标左边1(n)个字符。</p>
<p>d[n]w：删除（剪切）1(n)个单词</p>
<p>d$ or D：删除（剪切）当前位置到行尾的内容。</p>
<p>d0：删除（剪切）当前位置到行首的内容</p>
<p>:m,nd+回车：剪切m行到n行的内容。</p>
<p>d1G或dgg：剪切光标以上的所有行。</p>
<p>dG：剪切光标以下的所有行。</p>
<p>d&#x2F;f+回车：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</p>
<p>d：删除（剪切）在可视模式下选中的文本。</p>
<h4 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h4><p>p：在光标之后粘贴。</p>
<p>P：在光标之前粘贴。</p>
<h3 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h3><h4 id="搜索（查找）和替换"><a href="#搜索（查找）和替换" class="headerlink" title="搜索（查找）和替换"></a>搜索（查找）和替换</h4><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p>&#x2F;word：向下寻找word字符串</p>
<p>?word：向上寻找word字符串</p>
<p>n：重复前一个搜索动作。例如：我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串</p>
<p>N：与n相反，反向搜索</p>
<p>&#x2F;pattern&#x2F;+number：将光标停在包含pattern的行后面第number行上。</p>
<p>&#x2F;pattern&#x2F;-number:：将光标停在包含pattern的行前面第number行上。</p>
<h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p>:s&#x2F;old&#x2F;new：用new替换当前行第一个old。</p>
<p>:s&#x2F;old&#x2F;new&#x2F;g：用new替换当前行所有的old。</p>
<p>:%s&#x2F;old&#x2F;new&#x2F;g：用new替换文件中所有的old。</p>
<p>:%s&#x2F;^&#x2F;xxx&#x2F;g：在每一行的行首插入xxx。^表示行首。</p>
<p>:%s&#x2F;$&#x2F;xxx&#x2F;g：在每一行的行尾插入xxx。$表示行尾。</p>
<p>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</p>
<p>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</p>
<p>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</p>
<p>注意，g表示global，全部替换。</p>
<p>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s&#x2F;old&#x2F;new&#x2F;gci，加上i则忽略大小写(ignore)。</p>
<p>还有一种比较灵活的替换方式：它是匹配到某个模式后执行某种命令</p>
<p>语法为 ：[range]g&#x2F;pattern&#x2F;command</p>
<p>例如 ：%g&#x2F;^ xyz&#x2F;normal dd。</p>
<p>表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。</p>
<p>关于range的规定为：</p>
<p>如果不指定range，则表示当前行。</p>
<p>m,n: 从m行到n行。</p>
<p>0: 最开始一行（可能是这样）。</p>
<p>$: 最后一行</p>
<p>.: 当前行</p>
<p>%: 所有行</p>
<h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><h4 id="基本插入"><a href="#基本插入" class="headerlink" title="基本插入"></a>基本插入</h4><p>i：在光标前插入。</p>
<p>一个小技巧：按8，再按i，进入插入模式，输入&#x3D;， 按esc进入命令模式，就会出现8个&#x3D;，即8i&#x3D;然后esc。 这在插入分割线时非常有用，如30i&#x3D;然后esc就插入了36个&#x3D;组成的分割线。</p>
<p>I：在当前行第一个非空字符前插入</p>
<p>gI：在当前行第一列插入</p>
<p>a：在光标后插入</p>
<p>A：在当前行最后插入</p>
<p>o：在下面新建一行插入</p>
<p>O：在上面新建一行插入</p>
<p>:r filename：在当前位置插入另一个文件的内容</p>
<p>:[n]r filename：在第n行插入另一个文件的内容。</p>
<p>:r !date：在光标处插入当前日期与时间。同理，:r !command 可以将其它shell命令的输出插入当前文档。</p>
<h4 id="改写插入"><a href="#改写插入" class="headerlink" title="改写插入"></a>改写插入</h4><p>c[n]w：改写光标后1(n)个词。</p>
<p>c[n]l：改写光标后n个字母。注意，l可以省。</p>
<p>c[n]h：改写光标前n个字母。</p>
<p>[n]cc：修改当前[n]行。</p>
<p>[n]s：以输入的文本替代光标之后1(n)个字符，相当于c[n]l。</p>
<p>[n]S：删除指定数目的行，并以所输入文本代替之。</p>
<h2 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h2><p>aw：一个词<br>as：一句。<br>ap：一段。<br>ab：一块（包含在圆括号中的）。<br>y, d, c, v都可以跟文本对象。</p>
<h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><p>:set spell：开启拼写检查功能</p>
<p>:set nospell：关闭拼写检查功能</p>
<p>:set hlsearch：搜索高亮</p>
<p>:set nohlsearch：取消搜索高亮</p>
<h2 id="快速编辑"><a href="#快速编辑" class="headerlink" title="快速编辑"></a>快速编辑</h2><p>~：反转光标所在字符的大小写。</p>
<p>可视模式下的U或u：把选中的文本变为大写或小写。</p>
<p>gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如：guG，就是把当前行到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</p>
<p>[n] u：取消一(n)个改动。</p>
<p>:undo 5 ： 撤销5个改变。</p>
<p>:undolist：你的撤销历史。</p>
<p>ctrl + r：重做最后的改动。</p>
<p>U：取消当前行中所有的改动。</p>
<p>. ：重复上一个编辑动作</p>
<p><strong>宏：</strong></p>
<p>. ：重复上一个编辑动作<br>qa：开始录制宏a（键盘操作记录）<br>q：停止录制<br>@a：播放宏a</p>
<h2 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h2><p>vim -x file：开始编辑一个加密的文件。</p>
<p>:X：为当前文件设置密码。</p>
<p>:set key&#x3D; ：去除文件的密码。</p>
<h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>:e ++enc&#x3D;utf8 filename：让vim用utf-8的编码打开这个文件。<br>:w ++enc&#x3D;gbk：不管当前文件什么编码，把它转存成gbk编码。<br>:set fenc或:set fileencoding：查看当前文件的编码。<br>在vimrc中添加set fileencoding&#x3D;ucs-bom,utf-8,cp936：vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。<br>让vim 正确处理文件格式和文件编码，有赖于 ~&#x2F;.vimrc的正确配置</p>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p>大致有三种文件格式：unix, dos, mac，三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有换行符，mac 下只有回车符。</p>
<p>:e ++ff&#x3D;dos filename：让vim用dos格式打开这个文件。<br>:w ++ff&#x3D;mac filename：以mac格式存储这个文件。<br>:set ff：显示当前文件的格式。<br>在vimrc中添加set fileformats&#x3D;unix,dos,mac，让vim自动识别文件格式。</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>:set nu：显示行号</p>
<p>:set nonu：取消行号</p>
<p>ZZ：保存并退出</p>
<p>:x：保存并退出</p>
<p>:saveas newfilename：另存为</p>
<hr>
<h2 id="vim键位图"><a href="#vim键位图" class="headerlink" title="vim键位图"></a>vim键位图</h2><img src="/2022/10/25/Linux/vim/vim/image-20221025095209012.png" class="" title="image-20221025095209012">



<img src="/2022/10/25/Linux/vim/vim/image-20221025095304209.png" class="" title="image-20221025095304209">

<p>“f”命令移动到光标右边的指定字符上，例如，”fx”，会把移动到光标右边的第一个’x’字符上。</p>
<p>“F”命令则反方向查找，也就是移动到光标左边的指定字符上。</p>
<p>“t”命令和”f”命令的区别在于，它移动到光标右边的指定字符之前。例如，”tx”会移动到光标右边第一个’x’字符的前面。</p>
<p>“T”命令是”t”命令的反向版本，它移动到光标左边的指定字符之后。</p>
<p>这四个命令只在当前行中移动光标，光标不会跨越回车换行符。</p>
<p>可以在命令前面使用数字，表示倍数。例如，”3fx”表示移动到光标右边的第3个’x’字符上。</p>
<p>“;”命令重复前一次输入的f, t, F, T命令，而”,”命令会反方向重复前一次输入的f, t, F, T命令。这两个命令前也可以使用数字来表示倍数。</p>
<p>d命令可以和w，f，j，k等连用。</p>
<p>2i，进入插入模式，然后输入内容，然后esc，输入内容会重复出现2次。</p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025102154433.png" class="" title="image-20221025102154433">

<p><strong>“寄存器</strong></p>
<p>Vim 提供了许多寄存器。我们可以使用这些寄存器作为多个剪贴板。这个特性在处理多个文件时非常有用。</p>
<p><strong>拷贝内容到指定寄存器：</strong></p>
<p>“&lt;register-name&gt;&lt;command&gt;</p>
<p>例如，要复制当前行文本到寄存器”a”中，请使用以下命令</p>
<p>“ayy</p>
<p><strong>从寄存器中粘贴文本：</strong></p>
<p>“&lt;register-name&gt;p</p>
<p>例如，下面的命令从寄存器”a”粘贴文本</p>
<p>“ap</p>
<p><strong>列出可用寄存器：</strong></p>
<p>:registers</p>
<p><strong>匿名寄存器（未命名寄存器）：</strong>未命名寄存器用””表示。 Vim 将已删除或复制的文本存储在这个寄存器中。</p>
<p><strong>命名寄存器（有名字寄存器）：</strong>我们可以使用26个指定的寄存器; 我们可以使用 a-z 或 A-Z。默认情况下vim不使用这些寄存器。如果我们使用小写寄存器名称，那么内容将被覆盖，如果我们使用大写名称，那么内容将被追加到该寄存器中。</p>
<p><strong>数字寄存器：</strong>我们可以使用0到9个命名寄存器。Vim fills these registers with text from yank and delete command.</p>
<p>编号寄存器0包含来自最近的 yank 命令的文本</p>
<p>编号寄存器1包含由最近的 delete 或 change 命令删除的文本</p>
<p><strong>默认寄存器：</strong></p>
<p>%：Name of the current file</p>
<p>当前文件的名称</p>
<p>#：Name of the alternate file for the current window</p>
<p>当前窗口的备用文件的名称</p>
<p>:     Most recently executed command</p>
<p>最近执行的命令</p>
<p>.：Contains the last inserted text</p>
<p>包含最后插入的文本</p>
<p>“：Last used register</p>
<p>最后使用的寄存器</p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025104853100.png" class="" title="image-20221025104853100">

<p><strong>:set incsearch   #很聪明的查找,输入一个字符马上自动匹配,而不是输入完再查找</strong></p>
<p>*<strong>：搜索当前单词的下一个出现</strong></p>
<p><strong>#：查找当前单词的以前出现</strong></p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025121437413.png" class="" title="image-20221025121437413">





<img src="/2022/10/25/Linux/vim/vim/image-20221025121504058.png" class="" title="image-20221025121504058">

<p><strong>marks标记：</strong></p>
<p>在编辑的时候，你忽然想起来需要修改同一个文档的另一个地方，但又想记住当前的位置，以便稍后再回来编辑。vim中我们可以对文本进行标记，方便vim编辑器在文档的不同位置间跳转。</p>
<p><strong>添加标记：</strong></p>
<p>ma：m 是标记命令，a 是所做标记的名称</p>
<p>可以使用小写字母 a-z 或大写字母 A-Z 中的任意一个做为标记名称，意味着一个文件里最多可以有52个命名标记。小写字母的标记，仅用于当前缓冲区；而大写字母的标记，则可以跨越不同的缓冲区。例如，你正在编辑 File1，但仍然可以使 用’A 命令，移动到 File2 中创建的标记A。</p>
<p><strong>跳转标记：</strong></p>
<p>‘a：a是标记名。跳转到指定标记行的首个非空字符</p>
<p>&#96;a：a是标记名。跳转到所做标记时的光标位置</p>
<p><strong>列出标记：</strong></p>
<p>:marks命令，可以列出所有标记</p>
<p>其中也包括一些系统内置的特殊标记（Special marks）：</p>
<p>.             最近编辑的位置</p>
<p>0-9        最近使用的文件</p>
<p>∧           最近插入的位置</p>
<p>‘            上一次跳转前的位置</p>
<p>“           上一次退出文件时的位置</p>
<p>[           上一次修改的开始处</p>
<p>]           上一次修改的结尾处</p>
<p><strong>删除标记：</strong></p>
<p>如果删除了做过标记的文本行，那么所做的标记也就不存了</p>
<p>不仅可以利用标记来快速移动，而且还可以使用标记来删除文本。例如在某一行用ma做了标记，然后就可以使用d’a来删掉这一行。也可以使用y’a命令就可以来复制这一行了。</p>
<p>:delmarks a b c命令，可以删除某个或多个标记。</p>
<p>:delmarks! 命令，则会删除所有标记。</p>
<p><strong>Macros宏：</strong></p>
<p>Vim 的 Macro 就是用来解决重复的问题。 macro 的操作都是以文本的方式存放在寄存器中。</p>
<p>宏是一组命令的集合，应用极其广泛。VIM同样支持宏操作。</p>
<p>q* 开始录制宏</p>
<p>q 停止录制宏</p>
<p>@* 执行宏</p>
<p>@@ 重复执行上次的@*命令一次</p>
<p>以上命令均是在VIM的一般模式(Normal)下使用的，其中*代表一个数字或单个字符。[0-9a-zA-Z]</p>
<p>:help recording 查看宏帮助</p>
<p><strong>录制宏：</strong></p>
<p>q[a-z]：使用 q + [a-z] 26个字母中的一个。</p>
<p>之后的命令都会被记录</p>
<p><strong>结束录制宏：</strong></p>
<p>按一下q结束录制。</p>
<p><strong>执行宏（播放宏）：</strong></p>
<p>10@a：执行 macro 的时候，在寄存器前加 @ ，比如记录在寄存器 a 中，执行 10 遍a寄存器中记录的命令。</p>
<p>@@：再执行一遍上一次的命令。</p>
<p><strong>查看宏：</strong></p>
<p>:reg a</p>
<p>macro 内容保存在寄存器 a 中，直接使用 :reg a 来查看内容即可。</p>
<p><strong>编辑宏：</strong></p>
<p>假设已经有一个 macro 保存在了 a 中，可以使用</p>
<p>:let @a&#x3D;’</p>
<p>输入Ctrl + r + a 来插入 a 中内容，然后追加其它内容</p>
<p>编辑内容然后以 ‘ 结束 Enter 退出</p>
<p><strong>案例：</strong></p>
<p>经典注释和尾部追加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span></span><br><span class="line"><span class="type">int</span> c = a+b</span><br><span class="line">print a</span><br><span class="line">print b</span><br><span class="line">print c</span><br></pre></td></tr></table></figure>

<p>注释，或者在每一行的末尾添加特定字符，比如在每行末加上分号; ，对于这个操作 Vim 中有太多的方式可以完成，比如说替换 :%s&#x2F;$&#x2F;;&#x2F;g </p>
<p>比如说 . 命令。</p>
<p>也可以使用宏。</p>
<p>如果是用 . 来实现的话，首先在第一行执行A;，然后重复5次执行j.，对于这种简单文件来说很容易使用，但是如果这个文件有 1000 行，那么显然 . 命令是不可行的。使用 macro , 可以先录制一遍，然后在 1000 行上执行便可。</p>
<p>比如可以在normal模式下使用 </p>
<p><strong>qa 然后A; 然后Esc 然后j 然后q</strong></p>
<p>说明：</p>
<p>qa 开启录制，存入 a 寄存器</p>
<p>A 在行尾进入插入模式</p>
<p>; 插入分号</p>
<p>esc退出插入模式</p>
<p>j 下一行</p>
<p>q 退出录制</p>
<p><strong>此时 a 寄存器中就保存了当前行的操作，在当前行尾部添加 ; 并将光标移动到下一行。</strong></p>
<p>播放宏：</p>
<p>1000@a   执行1000遍 macro ，就能将下面1000行尾部添加 ;</p>
<p><strong>案例：</strong></p>
<p>递增数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">...</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<p>使用 macro 实现插入 1 到 100 个数字，每一行自增一</p>
<p>首先在第一行插入1，然后光标定位了”1”处，进入normal模式</p>
<p>输入命令：qayyp&lt;Ctrl&gt;aq</p>
<p>yyp     拷贝一行再粘贴在新的一行</p>
<p>&lt;Ctrl&gt;a    数字+1</p>
<p>q     结束录制</p>
<p>播放宏：98@a</p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025130708412.png" class="" title="image-20221025130708412">

<p>K，光标放到某个单词上，按K，会看到对应单词的man帮助，例如，定位到systemed，然后按K，就会查看systemed的man帮助。前提是有对应单词的man手册才行。</p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025131517427.png" class="" title="image-20221025131517427">



<img src="/2022/10/25/Linux/vim/vim/image-20221025132334412.png" class="" title="image-20221025132334412">

<hr>
<img src="/2022/10/25/Linux/vim/vim/image-20221025132641477.png" class="" title="image-20221025132641477">



<img src="/2022/10/25/Linux/vim/vim/image-20221025132714438.png" class="" title="image-20221025132714438">

<img src="/2022/10/25/Linux/vim/vim/image-20221025132744618.png" class="" title="image-20221025132744618">



<img src="/2022/10/25/Linux/vim/vim/image-20221025132806470.png" class="" title="image-20221025132806470">

<hr>
]]></content>
      <categories>
        <category>Linux</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行</title>
    <url>/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行"><a href="#01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行" class="headerlink" title="01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行"></a>01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行</h1><h2 id="Java的发展历史"><a href="#Java的发展历史" class="headerlink" title="Java的发展历史"></a>Java的发展历史</h2><p>Java是一种面向对象的程序设计语言，由Sun Microsystems公司的James Gosling等人于20世纪90年代初开发。它最初被命名为Oak，用来开发消费类电子产品，解决诸如电话、电视机等家用电器的控制和通讯问题。后来随着互联网的发展，Sun看到了Oak在计算机网络上的广阔应用前景，于是改造了Oak，在1995年5月正式命名为”Java”，变化历程如下图1.1和1.2所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image001.png" class="">



<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image002.png" class="" title="img">

<h2 id="Java语言的版本"><a href="#Java语言的版本" class="headerlink" title="Java语言的版本"></a>Java语言的版本</h2><p><strong>JavaSE</strong></p>
<p>　　 Java SE（Java Platform，Standard Edition）。Java SE 以前称为J2SE。它允许开发和部署在<a href="http://baike.baidu.com/view/79807.htm">桌面</a>、<a href="http://baike.baidu.com/view/899.htm">服务器</a>、嵌入式环境和实时环境中使用的Java <a href="http://baike.baidu.com/view/330120.htm">应用程序</a>。Java SE 包含了支持Java Web 服务开发的类，并为Java Platform，Enterprise Edition（Java EE）提供基础。<br>    例子：类似QQ、扫雷、飞秋、凌波这样子的桌面应用。</p>
<p><strong>Java EE</strong></p>
<p>　　 Java EE（Java Platform，Enterprise Edition）。这个版本以前称为J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在Java SE 的基础上构建的，它提供Web 服务、<a href="http://baike.baidu.com/view/3852154.htm">组件模型</a>、管理和通信API，可以用来实现企业级的面向服务<a href="http://baike.baidu.com/view/1188494.htm">体系结构</a>（service-oriented architecture，SOA）和Web 2.0 应用程序。 </p>
<p><strong>Java ME</strong></p>
<p>　　 Java ME（Java Platform，Micro Edition）。这个版本以前称为J2ME，也叫<a href="http://baike.baidu.com/view/412221.htm">K-JAVA</a>。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视<a href="http://baike.baidu.com/view/16791.htm">机顶盒</a>和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以<a href="http://baike.baidu.com/view/31294.htm">动态</a>下载的连网和离线应用程序的丰富支持。基于Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</p>
<h2 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h2><p><strong>1.跨平台</strong></p>
<p>何谓平台：即一套特定的硬件再加上运行其上的操作系统，即硬件＋软件。</p>
<p>Java编译器将Java源程序编译成一种与体系结构无关的中间文件格式，称为字节码。只要有Java运行系统的机器都能执行这种中间代码。从而使同一版本的应用程序可以运行在不同的平台上。</p>
<p>怎样理解平台无关性呢？JVM (java Virtual Machine)起到了主要作用。JVM是运行在平台之上的程序，它能够虚拟出一台目标机，所有字节码就是在虚拟出的目标机上运行。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image004.jpg" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image002-1664876304333-1.png" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/image-20221004173848525.png" class="" title="image-20221004173848525">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/image-20221004173904530.png" class="" title="image-20221004173904530">

<p>110是Windows上的指令。</p>
<p>101是linux上的指令。</p>
<p><strong>Java跨平台</strong></p>
<p>“write once run anywhere”</p>
<p>Java的跨平台是相对于其他编程语言而言的，通过Java语言编写的应用程序在不同的系统平台上都可以运行。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。在windows编译的c语言程序，在linux下是不能运行的，想要在linux下运行，那么就需要将c语言程序源码在linux平台上重新编译成linux平台的目标代码才行。当然在linux下编译的c语言程序在windows下也是不能运行的。<strong>而Java语言在不同平台上运行时不需要重新编译。</strong></p>
<p>Java跨平台的原理：Java的跨平台是通过Java虚拟机（JVM）来实现的。</p>
<p><strong>2.半编译半解释</strong></p>
<p>源程序先编译成字节码，Java解释器(运行系统)能直接对Java字节码进行解释执行。链接程序通常比编译程序所需资源少，Java的编译和解释执行过程如下图1.4所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image005.png" class="" title="img">

<p><strong>3.简单</strong></p>
<p>Java是个精简的系统，无需强大的硬件环境便可以很好地运行。Java的风格和语法类似于C++，因此，C++程序员可以很快就掌握Java编程技术。Java摒弃了C++中容易引发程序错误的地方，如多重继承、运算符重载、指针和内存管理等，Java语言具有支持多线程、自动垃圾收集和采用引用等特性。Java提供了丰富的类库，方便用户迅速掌握Java。</p>
<p><strong>4.面向对象</strong></p>
<p>对象可以是人们研究的任何实体，小到一个原子大到整个宇宙，均可看作对象，它不仅能表示具体的事物，还能表示抽象的规则、概念等。对象之间通过消息相互作用，用公式表示，面向对象编程语言可以表示为：程序&#x3D;对象+消息。现实世界中的对象均有属性和行为，映射到计算机程序上，属性就表示对象的数据（用来表示对象的状态），行为就表示对象的方法（用来处理数据或同外界交互）。</p>
<p>所有面向对象编程语言都支持三个概念：封装、继承和多态，Java也不例外。</p>
<p>面向对象可以说是Java最基本的特性。Java语言的设计完全是面向对象的，它不支持类似C语言那样的面向过程的程序设计技术。所有的Java程序和applet均是对象，Java支持静态和动态风格的代码继承及重用。</p>
<p><strong>5.分布式</strong></p>
<p>Java包括一个支持HTTP和FTP等基于TCP&#x2F;IP协议的子库。因此，Java应用程序可凭借URL打开并访问网络上的对象，就像访问本地文件一样简单方便。Java的分布性为实现在分布环境尤其是Internet下实现动态内容提供了技术途径。</p>
<p><strong>6.健壮</strong></p>
<p>Java提供了自动垃圾收集机制来进行内存管理，并检测程序对内存的访问，确定合法并不会引起任何问题后，才允许访问。</p>
<p>Java还提供了异常处理机制用来检查编译及运行时可能出现的问题，Java在编译和运行程序时要对可能出现的异常进行检查；同时，Java在编译时还可捕获类型声明中的许多常见错误，帮助程序员消除错误，防止系统崩溃。</p>
<p><strong>7、安全</strong></p>
<p>作为网络语言，安全是非常重要的。Java的安全性可从两个方面得到保证。一方面，在Java语言里，像指针和释放内存等C++功能被删除，避免了非法内存操作。另一方面，当Java用来创建浏览器时，语言功能和一类浏览器本身提供的功能结合起来，使它更安全。Java语言在你的机器上执行前，要经过很多次的测试。它经过代码校验，检查代码段的格式，检测指针操作，试图改变一个对象的类型。另外，Java拥有多个层次的互锁保护措施，能有效地防止病毒的入侵和破坏行为的发生。Java不支持指针，避免了由于指针操作所引起的错误和非法入侵。同时，Java在运行应用程序时，严格检查其访问数据的权限，保证数据的可靠性。</p>
<p><strong>8.多线程</strong></p>
<p>线程有时也称小进程，是一个大进程里分出来的小的独立运行的基本单位。Java提供的多线程功能使得在一个程序里可同时执行多个小任务，即同时进行不同的操作或处理不同的事件。多线程带来的更大的好处是具有更好的网上交互性能和实时控制性能，尤其是实现多媒体功能。</p>
<h2 id="Java开发环境的搭建"><a href="#Java开发环境的搭建" class="headerlink" title="Java开发环境的搭建"></a>Java开发环境的搭建</h2><p>Java运行环境就是JRE (Java Runtime Environment），是由Sun所研发的，是一个软件, JRE可以让计算机系统执行Java应用程序，它是运行JAVA程序所必须的环境的集合，JRE的内部有一个JAVA虚拟机（Java Virtual Machine，JVM）以及一些标准的类库（Class Library），如果你只需要运行Java程序,下载并安装它即可。</p>
<p>如果你要自行开发 Java软件，请下载JDK。在JDK中附带有JRE。最新版本下载地址<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html%E3%80%82">http://www.oracle.com/technetwork/java/javase/downloads/index.html。</a></p>
<p>java的环境的搭建：</p>
<p>​    </p>
<p>​    <strong>jre: java运行环境。 jre &#x3D; java虚拟机 + 核心类库(辅助java虚拟机运行的文件)</strong></p>
<p>​    </p>
<p>​    <strong>jdk： java开发工具集  jdk &#x3D; jre + java开发工具。</strong></p>
<p>java开发工具，例如，javac编译工具，java解释器执行工具。</p>
<p>如果只是软件使用者，那么安装jre即可，提供运行环境。</p>
<p>如果是软件开发者，那么就需要安装jdk。因为需要开发工具。</p>
<p>JRE Java Runtime Environment Java运行环境。包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<p>JDK 是整个Java的核心，包括了Java运行环境、Java工具和Java基础类库。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/image-20221004174307304.png" class="" title="image-20221004174307304">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/image-20221004174351709.png" class="" title="image-20221004174351709">



<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image006.png" class="" title="img">

<h2 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h2><img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image007.png" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image008.png" class="" title="img">

<h2 id="Java程序运行的原理"><a href="#Java程序运行的原理" class="headerlink" title="Java程序运行的原理"></a>Java程序运行的原理</h2><p>Java程序运行在Java虚拟机上，Java虚拟机就是指JVM (Java Virtual Machine) ，这是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬件架构,如处理器、堆栈、寄存器等,还具有相应的指令系统，编辑、编译及运行Java程序的过程如图1.13所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image009.png" class="" title="img">

<p><strong>图1.13编辑、编译及运行Java程序的过程</strong></p>
<p>一个运行时的Java虚拟机实例的天职就是：负责运行一个Java程序。Java虚拟机的主要任务是装载class文件并且解释执行其中的字节码。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中，如下图1.14所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image010.png" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image011.png" class="" title="img">

<p><strong>图 运行时过程</strong></p>
<p>编译源文件：java源代码被java编译器编译（Compile)。如果这时产生错误，我们称为编译错误。如果没有错误，则生成字节码（byte code）。</p>
<p>运行字节码：这里，java字节码被装载到java虚拟机中，解释成本地代码再运行。如果此时产生错误，我们称之为运行时错误（Runtime）。</p>
<h2 id="注释的使用"><a href="#注释的使用" class="headerlink" title="注释的使用"></a>注释的使用</h2><p>Java 的注释是被Javac忽略的部分，Java中的注释包含下面三种。</p>
<p>1．单行注释</p>
<p>&#x2F;&#x2F; 单行注释</p>
<p>2．多行注释</p>
<p>&#x2F;* 多行注释 *&#x2F;</p>
<p>3．文档注释</p>
<p>&#x2F;** 文档注释 *&#x2F;</p>
<p>Java的注释如下图1.17所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image012.png" class="" title="img">

<p>Java中的修饰符如下图1.19所示，其中public用来修饰类，也可以修饰方法，static用来修饰main方法，void是main方法的返回值类型，表示此方法没有返回值。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image013.png" class="" title="img">

<h2 id="类和主方法"><a href="#类和主方法" class="headerlink" title="类和主方法"></a>类和主方法</h2><p>Java中的类和主方法的结构图下图1.20所示，主方法在类的内部，类里包含方法。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image014.png" class="" title="img">

<hr>
<p>Java跨平台性是通过JVM（Java虚拟机）来实现的。</p>
<p>JVM是不具有跨平台性的，针对不同的平台分别设计了对应的JVM。通过不同平台的JVM来实现了Java程序的跨平台性。也就是通过JVM的不跨平台性来支持Java程序的跨平台性。</p>
<p>Java代码的执行：</p>
<p>编译：Java源码通过javac命令编译成class字节码文件。</p>
<p>解释执行：class字节码文件通过java命令解释执行。</p>
<p>Java源码-&gt;编译-&gt;class字节码文件-&gt;解释器解释执行</p>
<p>注意，class字节码文件是与特定硬件平台无关的中间代码，从而实现了在不同平台上的JVM上的解释执行，实现跨平台性。</p>
<p> Java字节码的两种执行方式：</p>
<p>即时编译：解释器（JVM）将字节码编译成对应硬件平台的机器码（二进制指令），然后再在该平台上直接执行该机器码，速度快，效率高。</p>
<p>解释执行：解释器每次解释并执行字节码中的一小段代码，从而实现字节码的执行。</p>
<p> Java程序执行与C&#x2F;C++程序执行对比：</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image015.png" class="" title="img">

<p>JVM相当于80x86计算机。</p>
<p>JVM中的Java解释器相当于80x86 CPU。</p>
<p>在80x86 CPU上运行的是C&#x2F;C++源码编译之后的机器码，在JVM解释器上运行的是Java源码编译之后的字节码。</p>
<p>当前不是所有平台都提供了JVM的，因此，Java代码只能在已经实现了JVM软件的并且安装了JVM软件的平台上运行。</p>
<p>javac命令就是java编译器。</p>
<p>java命令就是java解释器。利用解释器去装载字节码的时候，会自动的启动jvm虚拟机。使字节码在jvm内部运行。</p>
<p>Java源文件编译过程：</p>
<p>Java应用程序的开发周期包括编译、下载、解释和执行几个部分。Java编译程序将Java源程序翻译为JVM可执行代码—字节码。这一编译过程同C&#x2F;C++的编译有些不同。当C编译器编译生成一个对象的代码时，该代码是为在某一特定硬件平台运行而产生的。因此，在编译过程中，编译程序通过查表将所有对符号的引用转换为特定的内存偏移量，以保证程序运行。Java编译器却不将对变量和方法的引用编译为数值引用，也不确定程序执行过程中的内存布局，而是将这些符号引用信息保留在字节码中，由解释器在运行过程中创建内存布局，然后再通过查表来确定一个方法所在的地址。这样就有效的保证了Java的可移植性和安全性。</p>
<p>解释器解释执行分为3步：</p>
<p>代码的装入、代码的校验、代码的执行。</p>
<p>运行JVM字节码的工作是由解释器来完成的。解释执行过程分三步进行：代码的装入、代码的校验和代码的执行。装入代码的工作由“类装载器”（class loader）完成。类装载器负责装入运行一个程序需要的所有代码，这也包括程序代码中的类所继承的类和被其调用的类。当类装载器装入一个类时，该类被放在自己的名字空间中。除了通过符号引用自己名字空间以外的类，类之间没有其他办法可以影响其它类。在本台计算机上的所有类都在同一地址空间内，而所有从外部引进的类，都有一个自己独立的名字空间。这使得本地类通过共享相同的名字空间获得较高的运行效率，同时又保证它们与从外部引进的类不会相互影响。当装入了运行程序需要的所有类后，解释器便可确定整个可执行程序的内存布局。解释器为符号引用同特定的地址空间建立对应关系及查询表。通过在这一阶段确定代码的内存布局，Java很好地解决了由超类改变而使子类崩溃的问题，同时也防止了代码对地址的非法访问。</p>
<p>随后，被装入的代码由字节码校验器进行检查。校验器可发现操作数栈溢出，非法数据类型转换等多种错误。通过校验后，代码便开始执行了。</p>
<p>Java基础类库，都内置在jdk中。</p>
<p>demo目录是提供的一些例子程序。</p>
<p> lib目录就是提供的一些基础类库。</p>
<p> jre目录就是运行时环境。</p>
<p><strong>linux&#x2F;unix</strong>下，换行是一个字符来表示的，ascII表示就是10。</p>
<p><strong>windows</strong>下，换行是两个字符来表示，实际是回车+换行，ascII表示就是13和10。来表示一个回车+换行。</p>
<p><strong>Java</strong>中所有功能都需要通过类来完成，也就是说Java中最小组织单位就是类。</p>
<p><strong>JDK</strong>、JRE、JVM关系示意图</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image017.jpg" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image019.png" class="" title="https:&#x2F;&#x2F;img2020.cnblogs.com&#x2F;blog&#x2F;2170368&#x2F;202010&#x2F;2170368-20201013143113378-1314191418.png">

<p>JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。<br> JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。<br> 我们想要运行一个已有的Java程序，那么只需安装 JRE 即可。<br> 我们想要开发一个全新的Java程序，那么必须安装 JDK 。</p>
<p>三者关系： JDK &gt; JRE &gt; JVM</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image021.jpg" class="" title="img">

<p>Java程序的执行过程</p>
<p>所有的Java代码，其后缀都是以java结尾，Java程序的执行过程分为两步：</p>
<p>\1. 编译</p>
<p>\2. 执行</p>
<p>Class文件是字节码文件，程序最终执行的就是这个字节码（bytecode）文件。</p>
<p>编译命令：java Hello.java</p>
<p>执行命令：java Hello（注意，Test后面没有.class）</p>
<p><strong>注意，加载的是类，而不是class字节码文件。执行的流程就是首先根据java命令后面的要加载的类的名字来找到对应的名字的class文件，然后JVM会将class文件加载到内存的方法区中，然后将class文件解开，就会找到里面对应的那个类，然后就可以加载这个类进行运行。</strong></p>
<p>Java是跨平台的语言，真正执行的不是二进制代码，而是字节码。</p>
<p>JVM（Java Virtual Machine，Java虚拟机）</p>
<p>Java是跨平台的，而JVM不是跨平台的（JVM是由C语言编写的）</p>
<p>Java之所以能够做到跨平台，本质原因在于JVM不是跨平台的。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>03-JavaHome&amp;临时环境变量&amp;classpath环境变量</title>
    <url>/2022/10/04/Java/JavaSE/03-JavaHome&amp;%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="1-配置java-home、临时环境变量信息"><a href="#1-配置java-home、临时环境变量信息" class="headerlink" title="1.配置java_home、临时环境变量信息"></a>1.配置java_home、临时环境变量信息</h1><p>PATH环境信息：</p>
<p>D:;</p>
<p>D:\JDK\JDK\bin;</p>
<p>D:\eclipse4.3\adt-bundle-windows-x86-20131030\adt-bundle-windows-x86-20131030\sdk\platform-tools;</p>
<p>C:\Program Files\Intel\iCLS Client;</p>
<p>%SystemRoot%\system32;</p>
<p>%SystemRoot%;</p>
<p>%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\OpenCL SDK\2.0\bin\x86;D:\mysql\bin;C:\Program Files\TortoiseSVN\bin;D:\firfox\quicktime\QTSystem\</p>
<p>目前path环境变量除了保存了我们自己配置的信息以外，还有系统自带的信息，如果一旦不不小心删除了path环境变量信息，那么就可能导致系统部分功能无法使用。</p>
<p>尽量避免修改的path环境变量信息。</p>
<p>如果我们需要频繁的更换jdk的版本，那么就需要频繁的去修改path环境变量内容了，就容易出错。</p>
<p>那么为了尽量避免频繁修改path环境变量，如何做？</p>
<p>解决办法：新建一个环境变量保存jdk安装目录会发生变化的部分，然后在path环境变量上引用新环境变量所保存的信息。</p>
<p>即使用java_home，当然这个环境变量不叫java_home也行，但是一般都起名为java_home。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image001.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image002.png" class="" title="img">

<p>当jdk版本有变动的时候，去修改JAVA_HOME的值即可了。path环境变量就不用动了。</p>
<p>有的时候，某个jdk版本只用一次，那么可以使用临时配置环境变量即可。</p>
<p>需求： 在现实开发中有时候jdk版本的信息有时候只会使用一次或者几次就不再使用了，那么如果是这种需求，我们一般都是通过set命令配置临时环境变量。</p>
<p><strong>临时环境变量就是仅对于当前控制台窗口起作用，窗口一旦关闭，那么配置的临时环境变量信息会发生消失。</strong></p>
<p>set命令的用法：</p>
<p>​    </p>
<p>​    set              查看所有的环境变量信息。</p>
<p>​    set 环境变量的名字      查看指定的环境变量信息。</p>
<p>​    set 环境变量名字 &#x3D; 路径信息   设置指定的环境变量信息。</p>
<p>​    set 环境变量名字 &#x3D;       清空指定的环境变量信息。</p>
<p>​    <strong>set 环境变量名字 &#x3D; 新路径；%环境变量名字%  在原有的基础上添加新的路径信息。</strong></p>
<p>注意： 以后大家但凡看到是set命令设置的环境变量信息，都是临时环境变量信息。</p>
<p><strong>helloworld的小细节</strong></p>
<p>\1.  缺少main方法</p>
<p>出现提示：缺少一个名称为main的方法。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image004.png" class="" title="img">

<p>\2.  源文件中的大小写要注意。初学者请牢记，第一个hello例子中只有     String和System中两个字符是大写的，其他的都小写。</p>
<p>\3.  配置path和classpath时，里面的路径是所有查找的目标的父目录，        而不是目标自己。</p>
<p>\4.  A.java.txt</p>
<p>​        文本文件默认是txt结尾的，注意要把隐藏已知文件类型扩展名去掉。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image006.png" class="" title="img">

<p>\5.  大小写</p>
<p>只有类名Demo，String和System中三个个首字母是大写的。</p>
<p>  <strong>public</strong> <strong>class</strong> <strong>Demo</strong>{    <strong>public</strong> <strong>static</strong> <strong>void</strong>  main(<strong>String</strong>[] args) {      <strong>System</strong>.<em>out</em>.println(“hello  java”);    }  }  </p>
<p>\6.  path</p>
<p>看path环境变量配置 ，里面的路径是所有查找的目标的父目录，而不是目标自己。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image008.png" class="" title="img">

<p><strong>7.</strong>  <strong>写错类名</strong>, <strong>源文件名不存在或者写错，或者当前路径错误。</strong></p>
<p><strong>类文件名写错，或者类文件不在当前路径下，或者不在classpath指定  路径下。</strong></p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image010.png" class="" title="img">

<p><strong>java</strong>命令加载的是类，而不是<strong>class</strong>文件的。因此，如果人为的将<strong>class文件</strong>的文件名改成别的，那么java命令加载的时候，仍然需要写里面的类名，而不应该写<strong>class文件的文件名。</strong></p>
<p>\8.  javac 生成的.class 文件的名称取决于类名，跟.java名没有关系。</p>
<p><strong>javac编译源文件，生成的class文件的文件名默认就是类名。</strong></p>
<p>第一个hello world例子常见 的问题：</p>
<p>​    </p>
<p>​    \1. 找不到对应的文件</p>
<p>​       原因：</p>
<p>​           1 隐藏了后缀名，你的不是java文件是txt文件。</p>
<p>​           2.编译 的时候写错了文件名。</p>
<p>​    \2. 找不到或无法加载主类 Demo1 </p>
<p>​       原因： 运行的时候写错了类名. 注意： class文件的文件名是对应的类名的。不是对应的java文件名的。</p>
<p>​    \3. java的代码是严格区分大小写的。</p>
<p>​    </p>
<p>​    \4. ‘javac’ 不是内部或外部命令 </p>
<p>​       原因： 没有配置path环境变量信息，或者是配置错误了。</p>
<h1 id="2-classpath环境变量信息"><a href="#2-classpath环境变量信息" class="headerlink" title="2.classpath环境变量信息"></a>2.classpath环境变量信息</h1><p><strong>JVM查找类文件的顺序：</strong></p>
<p>•  <strong>如果没有配置classpath环境变量，JVM只在当前目录下查找要运行的类文件。</strong></p>
<p>•  <strong>如果配置了classpath环境，JVM会先在classpath环境变量值的目录中查找要运行的类文件。</strong></p>
<p>•  <strong>值的结尾处如果加上分号，那么JVM在classpath目录下没有找到要指定的类文件，会在当前目录下在查找一次。</strong></p>
<p>•  <strong>值的结尾出如果没有分号，那么JVM在classpath目录下没有找到要指定的类文件，不会在当前目录下查找，即使当前目录下有，也不会运行。</strong></p>
<p><strong>建议：配置classpath环境变量时，值的结尾处不要加分号，如果需要访问当前目录可以用 “.”表示。</strong></p>
<p>classpath 环境变量：</p>
<p>​    </p>
<p>​    设置了classpath环境变量的时候，启动jvm(java虚拟机)的时候，那么java虚拟机就会 根据classpath环境变量所保存路径信息下去寻找对应的class文件。</p>
<p>​    设置classpath环境变量信息的有分号与没有分号的区别： </p>
<p>​       \1. 如果配置classpath环境变量信息<strong>没有加上分号</strong>,那么java虚拟机仅会在classpath所保存的路径下去搜索对应的class文件，不会在当前路径下去搜索了。</p>
<p>​       \2. 如果配置classpath环境变量信息<strong>加上分号</strong>，那么java虚拟机除了会在classpath所保存的路径下去搜索对应 的class文件之外,如果能找到对应的class文件那么就马上指定对应的class文件，否则还会去 当前路径下去搜索。</p>
<p><strong>注意，分号;，就相当于是当前目录，就是那个点.。</strong></p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image011.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image012.png" class="" title="img">

<p>现在E盘和F盘都有同名的Demo1.java文件，并且类名也相同，都是Demo1。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image013.png" class="" title="img">

<p>当前F盘编译了Demo1.java，有对应的class文件。</p>
<p>此时由于设置了classpath，因此，首先会在classpath设置的目录去搜索Demo1的class文件的。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image014.png" class="" title="img">

<p>如果将F盘的class文件删除了。</p>
<p>那么在classpath里面指定的f盘里找不到class文件，就在当前目录E盘下找。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image015.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image016.png" class="" title="img">

<p>分号放前面了。分号，就相当于是当前路径。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image017.png" class="" title="img">

<p>注意，不建议将classpath配置成永久环境变量的。</p>
<p>以前的书籍，都让配置classpath问永久环境变量。</p>
<p>jdk5官方也不建议配置classpath为永久环境变量了。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image018.png" class="" title="img">

<p>如果这里配置了，然后最后又没有加上分号。</p>
<p>然后自己可能忘记了。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image019.png" class="" title="img">

<p>在F盘执行，想要执行的是F盘的Demo1的，结果却执行了E盘的，原因就是上面配置了classpath导致的。因此，就会产生误解。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image020.png" class="" title="img">

<p>将E盘的class文件删了。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image021.png" class="" title="img">

<p>这就是由于配置了classpath&#x3D;E:\的原因。</p>
<p>因此，不推荐配置classpath为永久环境变量的。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image022.png" class="" title="img">

<p>在jdk5.0之前，是必须要配置classpath的。原因是当时的jvm没有那么智能。</p>
<p><strong>jre&#x3D;jvm+核心类库。也就是jvm的运行要依赖核心类库的。</strong></p>
<p>jdk5.0之前，安装完的jdk之后，jvm不知道核心类库的位置。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image023.png" class="" title="img">

<p>核心类库在这个目录下的。</p>
<p>因此，jdk5.0之前的jvm需要这些核心类库支持才能运行，但是又不能够智能的找到它们，因此，就强制要求必须要配置classpath环境变量，指向到这些核心类库的jar包。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image024.png" class="" title="img">

<p>即要求要这样来配置。</p>
<p>而在jdk5.0之后的jvm比较智能了，能够自动的找到这些核心类库的jar包了，因此，不需要配置classpath指向到这些核心类库的jar包了。</p>
<p><strong>注意，配置classpath的作用，它对jvm有作用，同时它对编译的时候，也会产生作用的，因为编译的时候，遇到import导包的时候，就需要参考classpath指定的路径去找对应的包下的类的class文件。</strong></p>
<p>classpath环境变量</p>
<p>\1.  classpath的作用: 作用是<strong>指定类搜索路径</strong>，要使用已经编写好的类，前提当然是能够找到它们了，一旦配置了classpath路径信息的时候，jvm<strong>（java运行命令）</strong>与java编译器都会根据classpath指定的路径去寻找class文件。</p>
<p>\2.  如何设置当前目录（.）</p>
<p>set classpath&#x3D;.;设置路径 与 set classpath&#x3D;设置路径;.有什么区别?</p>
<p>“.”在前面的时候，java虚拟机会先从当前路径去寻找class文件，然后再到指定的路径去需找。如果”.”在后面，java虚拟机则会先寻找指定好的路径,然后再在当前的路径去寻找。</p>
<p><strong>设置classpath的时候要加上 ; 就会在当前目录下查找。因为分号就相当于是当前路径。</strong></p>
<p>\1.  简述对JVM,JRE,JDK的理解。</p>
<p>JVM: JAVA虚拟机</p>
<p>Jre： java运行环境 jre &#x3D; java虚拟机+ 核心类库</p>
<p>Jdk : java开发工具集。 Jdk &#x3D; jre + java开发工具。</p>
<p>\2.    简述环境变量path和java_home \ classpath的作用？</p>
<p>Path: 为了让控制台在任意路径下都可以找到java的开发工具。</p>
<p>Java_home : 避免频繁修改path 环境变量信息。</p>
<p>Classpath : 设置class文件所在的路径信息。</p>
<p>\3.    独立编写hello world程序，编译并运行。</p>
<p>\4.    java语言是否区分大小写? class的作用,javac,java的作用？</p>
<p> 是， class的作用定义一个该类 的关键字，</p>
<p> java :  启动java虚拟机解释并执行对应的class文件。</p>
<p>javac： 启动java编译器对指定的java源文件进行编译</p>
<p>\5. 简述main方法(是什么，什么特点，怎么用，何时用？)</p>
<p>​    程序的主入口，代码是从住方法上开始执行的。</p>
<p>​    写法是固定的。</p>
<p>​    定义一个类中使用。</p>
<p>​    如果一个类需要独立运行的时候，就需要main方法。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>02-命令行下运行Java代码</title>
    <url>/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="02-命令行下运行Java代码"><a href="#02-命令行下运行Java代码" class="headerlink" title="02-命令行下运行Java代码"></a><a href="https://www.cnblogs.com/Leo101018/p/13808541.html">02-命令行下运行Java代码</a></h1><img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013133731413-1792118278.png" class="" title="img">

<p>这里如果报错，说明环境变量PATH没有配置。</p>
<p>如果没有配置PATH环境变量，仍然想要执行javac命令，那么就需切换到javac命令目录下去执行。</p>
<p>当执行一个程序的时候，首先在当前目录下查找是否有这个程序，如果没有，那么就去path环境变量下查找，以找到的第一个为准，也就是在path下有多个这个程序，但是找到了第一个就停止往后找了。<br>如果都没找到，那么就会报错了。</p>
<p>查看环境变量内容</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013133951044-759302803.png" class="" title="img">

<p>命令行下设置环境变量PATH内容</p>
<p>set path&#x3D;jdk路径\bin</p>
<p>注意，配置到bin目录。</p>
<p>命令行下配置，退出cmd，即失效，永久配置到环境变量配置文件中进行配置。</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013134400039-1428974611.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013134445937-977223770.png" class="" title="img">

<p> 注意，这里配置JAVA_HOME环境变量，然后通过该环境变量再去指定到bin目录，目的是不用去频繁的更改PATH环境变量，方式修改错误。如果jdk变换其他版本了，只需要更改JAVA_HOME环境变量即可。</p>
<p>编写测试java文件</p>
<p>[</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Hello</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Welcome</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013134851725-1447593978.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013134927582-528866572.png" class="" title="img">

<p><strong>注意：编译的时候，对于文件名的大小写是不敏感的。</strong></p>
<p><strong>在Java的源文件中可以写入多个类，但是编译之后，每个类会单独生成一个字节码文件（class文件）。</strong></p>
<p>当有很多的class文件的时候，给别人提供使用是不方便的，因此，可以将多个class文件进行打包，jar文件。</p>
<p>可以使用jar cvf xxx.jar Hello.class Welcome.class方式打包。</p>
<p>通常打包操作可通过IDE完成。</p>
<p>[</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Hello</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Welcome</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013135517652-212396672.png" class="" title="img">

<p><strong>当在一个源文件中定义了一个public的类，那么这个源文件的文件名必须取名为这个public类的类名。java中的规定。</strong><br><strong>因此，在一个源文件中，有且只能有一个public的类。也可以没有public的类，那么文件名可以是任意类的类名或者是其它的名字。</strong></p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013135719935-1988852445.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013135758658-1222200341.png" class="" title="img">

<p><strong>编译的时候，可以没有main函数，但是要想执行，必须有main函数。否则执行错误。</strong></p>
<p><strong>另外，java解释器，解释执行的时候，加载的是一个类，而不是一个文件，不是welcome.class这个文件。而是Welcome这个类。</strong></p>
<p> <strong>java解释器要加载这个类，因此，后面的这个类名是大小写相关的。</strong></p>
<p> <strong>注意，main函数必须是public static void的。java Welcome加载类的过程为，首先根据这个名字找到对应的</strong></p>
<p><strong>class文件，即找到Welcome.class文件，然后jvm将该文件加载入内存的方法区（代码区）中，然后将class文件解</strong></p>
<p><strong>开，然后搜寻找到public static void的main函数，然后将该main函数加载到方法调用栈上进行执行。</strong></p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013140208913-1985116180.png" class="" title="img">

<p>第一次运行java Welcome没有报错，原因是，在Welcome.class目录下运行，能够找到对应文件。</p>
<p>第二次运行java Welcome报错，原因是，当前目录下没有Welcome.class文件了，且classpath环境变量没有配置，所以找不到类文件。</p>
<p><strong>当定义了classpath之后，那么java解释器在加载一个类的时候，就会完全根据classpath定义的路径去搜索要加载的类。而不会去看是否当前目录下有这个class文件。</strong></p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013140611958-1418112487.png" class="" title="img">

<p><strong>可以看到，java解释器加载类的时候，当定义了classpath的时候，是完全按照定义的classpath指定的路径去搜寻的，而不会在当前路径下查找了。即使当前路径下有这个类，也不会找到。</strong><br><strong>为了让当前路径下的类也能找到，那么classpath中添加当前路径‘.’即可。</strong></p>
<p>为了配置的classpath永久生效，也需要配置到环境变量中去。</p>
<p>因此，需要配置两个环境变量：</p>
<p>path和classpath。</p>
<p><strong>安装jdk的路径要注意： 不能带有中文路径或者是空格。</strong></p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/image-20221004165803557.png" class="" title="image-20221004165803557">

<p>安装过程中，先安装jdk，然后又会提示你安装jre，实际上这个jre完全可以不安装，因为前面安装的jdk已经包含了jre了。</p>
<p>jdk目录的介绍：</p>
<p>​    bin: 存放的是java的开发工具。   </p>
<p>​    db : JDK7附带的一个轻量级的数据库，名字叫做Derby。</p>
<p>​    include ：存放的调用系统资源的接口文件。java程序中向os调用的时候，需要的本地os接口文件。</p>
<p>​    jre ： java运行环境</p>
<p>​    lib : 核心类库。</p>
<p>​    src.zip : java源代码</p>
<p>java.exe 启动java虚拟机解释并执行指定的class文件。</p>
<p>​     java工具的使用格式：</p>
<p>​            java 指定的class文件</p>
<p> javac.exe 启动java编译器对指定的java源文件进行编译。</p>
<p>编写第一个java的程序：</p>
<p>​    第一步： 新建一个txt文件。把后缀名改成java。</p>
<p>​    第二步： <strong>java 代码全部都是写到类上面的。也就是在java中，类是程序组织的最小单位。</strong></p>
<p>​       如何编写一个类：</p>
<p>​           使用一个关键字class即可定义个类。</p>
<p>​       格式：</p>
<p>​           class 类名{</p>
<p>​           } 备注： 大括号表示是一个类的范围，在类的范围之内都可以写代码，</p>
<p>​    <strong>第三步： 编写一个主方法。 主方法的写法是固定的，是一个程序的入口，代码从主方法开始执行</strong></p>
<p> 当直接双击一个可执行文件一闪而过就关闭了，那么一般说明，这个可执行文件需要一个控制台中来执行它。</p>
<p>如何启动java编译对java的源文件进行编译？</p>
<p>​    javac的使用格式：</p>
<p>​       javac java源文件。   </p>
<p> 编译的过程中我们就面临 的问题：每次编译的时候都需要写上java源文件的完整路径。 烦！！！</p>
<p>即需要在javac可执行文件的目录下，执行”javac java源文件完整路径”</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/image-20221004170158393.png" class="" title="image-20221004170158393">

<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/image-20221004170206872.png" class="" title="image-20221004170206872">

<p>这样是不好的，将源文件放到了javac的安装目录了，不好。乱。</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/image-20221004170232725.png" class="" title="image-20221004170232725">

<p>每次都需要写全路径，麻烦。</p>
<p><strong>解决方案： 如果可以在任意的路径下都可以找到java的开发工具，那么该问题就解决了。</strong></p>
<p><strong>在控制台写一个可执行文件的文件名，然后能够执行的原理：</strong></p>
<p>​    在控制台写一个可执行文件的文件名,那么系统<strong>首先会在控制台当前路径下去搜索是否存在该文件</strong>，如果可以找到指定的文件，那么就执行该文件，如果找不到该文件，那么系统还会根据<strong>path</strong>的环境变量所保存的路径信息下去搜索是否有指定的文件，如果能找到，那么就执行该文件。</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/clip_image001.png" class="" title="img">



<p>SystemRoot是Windows系统的根路径。</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/clip_image001-1664874219008-26.png" class="" title="img">

<p>即这个目录。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>04-标识符、常量（字面量）、变量和数据类型、运算符</title>
    <url>/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="04-标识符、常量（字面量）、变量和数据类型、运算符"><a href="#04-标识符、常量（字面量）、变量和数据类型、运算符" class="headerlink" title="04-标识符、常量（字面量）、变量和数据类型、运算符"></a>04-标识符、常量（字面量）、变量和数据类型、运算符</h1><h2 id="Java程序结构"><a href="#Java程序结构" class="headerlink" title="Java程序结构"></a>Java程序结构</h2><img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004214518848.png" class="" title="image-20221004214518848">



<p>其中数据类型确定要存储在内存中的数据的类型；变量是存储数据的基本单元；运算符是一个符号，用于操作一个或多个参数以得出结果；程序是按顺序执行的，控制流语句允许改变此顺序。</p>
<h2 id="标识符、关键字和保留字"><a href="#标识符、关键字和保留字" class="headerlink" title="标识符、关键字和保留字"></a>标识符、关键字和保留字</h2><p>在Java语言中，通过标识符来表示一些元素的名字，比如变量名、类名、方法名和包名等。Java中的标识符要符合下面的规则：</p>
<ol>
<li>标识符必须以字母、下划线（_）、数字或美元（$）组成；</li>
<li>标识符必须由字母、下划线（_）或美元（$）开头，不能由数字开头；</li>
<li>标识符不能是关键字或者保留字；</li>
<li>标识符中不能有空格;</li>
<li>标识符没有长度限制。</li>
</ol>
<p>例如，A_123，$abc，length都是合法的标识符，而1a，s+g就是非法的标识符，各种不同的元素命名规则如下图</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004214805746.png" class="" title="image-20221004214805746">

<p>提示：</p>
<ol>
<li>Java区分大小写，因此area和Area是两个不同的标识符；</li>
<li>为提高程序的可读性，建议使用有意义的命名标识符，如area，length等。</li>
</ol>
<p>命名规范： 软性建议<br>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。<br>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。<br>变量名规范：全部小写。</p>
<p> <strong>关键字和保留字</strong><br>下表是Java中的关键字和保留字，关键字是对Java的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等；保留字是为Java预留的关键字，虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字，关键字和保留字如下表所示。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004215024906.png" class="" title="image-20221004215024906">



<h2 id="常量（字面量）"><a href="#常量（字面量）" class="headerlink" title="常量（字面量）"></a>常量（字面量）</h2><p><strong>常量（字面量）：也叫做字面量</strong>，我们可以直观看到的值，是指在Java程序中固定不变的数据。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004215140584.png" class="" title="image-20221004215140584">



<h2 id="常量（使用final声明的常变量）"><a href="#常量（使用final声明的常变量）" class="headerlink" title="常量（使用final声明的常变量）"></a>常量（使用final声明的常变量）</h2><p>常量<br>在程序中往往会存在变量值不需要变化的情况，比如表示圆周率的变量，比如表示黄金分割点的变量，那么<strong>这些值不变的变量就叫常量</strong>。<br>在Java中，<strong>常量用关键字final来表示（在后面章节会详细讲解）</strong>，它也是有数据类型的，语法如下：<br><strong>final数据类型 常量名 &#x3D; 初始值;</strong><br>提示：</p>
<ol>
<li><p><strong>常量在声明的时候必须初始化；</strong></p>
</li>
<li><p><strong>常量在初始化后值不能再更改，否则会引起错误。</strong><br> 例如：<br> final double PI &#x3D; 3.14;</p>
</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量（variable）是用来存储数据的一块存储区域，在程序运行中它的值可以发生变化。变量可以存放一种数据类型的值，Java程序在运行加载时会根据变量的不同数据类型来分配不同的内存空间，变量的数据类型在声明时指定。<br>变量是指在程序的运行过程中随时可以发生变化的量，作用是：<br>1．变量是程序中数据的临时存放场所<br>2．保存程序运行时用户输入的数据<br>3．特定的运算结果等</p>
<p><strong>变量的声明</strong><br>一个变量只有在声明后才有效，声明的作用就是确定该变量要存储的数据类型。声明变量的语法格式如下：<br>数据类型 变量名;<br>如果要同时声明多个相同数据类型的变量，可以如下写：<br>数据类型 变量名1,变量名2;<br>代码举例如下：<br>int number, max;</p>
<p>注意，变量必须要先声明，后使用。</p>
<p><strong>在局部作用域（例如函数体内）内声明的变量必须进行初始化才能够使用，否则就是一个随机值，不能够直接使用，编译会提示未初始化的变量错误。</strong></p>
<p>变量在声明后，不能直接访问，只有被赋值的变量才能够被访问，否则就会出现运行错误。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004215515107.png" class="" title="image-20221004215515107">

<p><strong>局部变量必须进行初始化。</strong></p>
<p><strong>变量的赋值</strong><br><strong>第一次给变量赋值叫”初始化”。</strong>使用等号”&#x3D;”来进行赋值，语法如下：<br>变量名 &#x3D; 数据值;<br>例如：<br>int number;<br>number &#x3D; 1000;<br>也可以把变量的声明和初始化合用一个语句实现出来，例如上面两行代码就可以改写成一行代码：<br>int number &#x3D; 1000;<br>每个已经声明了数据类型的存储变量只能存储对应类型的数据。如下代码是正确的：<br>int ii &#x3D; 100;<br>double pi &#x3D; 3.14;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String args[])</span> &#123;</span><br><span class="line">        <span class="type">double</span> salary; <span class="comment">//声明变量</span></span><br><span class="line">        salary = <span class="number">1500.00</span>; <span class="comment">//变量赋初值</span></span><br><span class="line">        System.out.println(salary); <span class="comment">//变量的访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004220048802.png" class="" title="image-20221004220048802">

<p>注意，Java中的变量如图，就是这个内存区域中存储的是5，这个内存区域就是变量a，不同于Python中的变量是一种指向的关系。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在Java中，数据类型分为两大类：<br><strong>基本数据类型：8种基本数据类型</strong><br>● 字符型<br>● 布尔型<br>● 数值型<br>  ○ 整型<br>  ○ 浮点型<br><strong>引用数据类型：存储地址的引用</strong><br>● 类<br>● 接口<br>● 数组</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004220409808.png" class="" title="image-20221004220409808">

<p>有的说法，java的数据类型中的复合数据类型，实际上就是引用数据类型，就是类，接口，数组，这些。</p>
<p>Java的数据类型分为两大类：<br>基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。<br>引用数据类型：包括 类 、 数组 、 接口 。</p>
<p>基本数据类型：</p>
<p>　　整数型 byte short int long<br>　　浮点型 float double<br>　　字符型 char<br>　　布尔型 boolean</p>
<p>引用数据类型：</p>
<p>　　字符串、数组、类、接口、Lambda</p>
<p>注意事项：<br>\1. <strong>字符串不是基本类型，而是引用类型。</strong><br>\2. <strong>浮点型可能只是一个近似值，并非精确的值。</strong><br>\3. <strong>数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。</strong><br>\4. <strong>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。</strong><br>　<strong>如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。</strong></p>
<p>每个数据类型都有取值范围，编译器会对每种数据类型分配相应大小的存储空间。下面我们来详细介绍一下这8种基本数据类型。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004220730005.png" class="" title="image-20221004220730005">

<p><strong>Java中的默认类型：整数类型是 int ，声明long型后面需加上l或者L，否则会出错。浮点类型数据默认是 double 。</strong></p>
<h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><table>
<thead>
<tr>
<th>byte</th>
<th>字节型</th>
<th>1个字节（8位二进制）</th>
<th>-128 到 127</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>short</th>
<th align="left">短整型</th>
<th>2个字节（16位二进制）</th>
<th>-2^15 到 2^15-1</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>int</th>
<th>整型</th>
<th>4个字节（32位二进制）</th>
<th>-2^31到 2^31-1</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>long</th>
<th>长整型</th>
<th>8个字节（64位二进制）</th>
<th>-2^63到 2^63-1</th>
</tr>
</thead>
</table>
<p><strong>Java中整型的四种表示形式</strong><br>十进制整数：0 ~ 9，注：第一位不能是0</p>
<p>十六进制数：0 ~ 9 A ~ F, 注：必须以0x或0X开头<br>例如： 0X8A 0x12</p>
<p>八进制整数：0 ~ 7，注：必须以0开头<br>例如： 0123 012</p>
<p>二进制整数：0~1，注：必须以0B开头（在java1.7及以上版本可用）<br>例如： 0B1010</p>
<p>例 在java中与语句int a &#x3D; 97;等效的声明语句是_____<br>A.int a &#x3D; 0X0061;<br>B.int a &#x3D; 0X61;<br>C.int a &#x3D; 0141;<br>D.int a &#x3D; 97.0;<br>答案：ABC</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>与整数类型相似，Java浮点数类型有固定的表示范围和字段长度，不受平台影响，浮点数据类型</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>占空间大小</strong></th>
<th><strong>值域</strong></th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>单精度浮点型</td>
<td>4个字节，精度约7位</td>
<td>-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>8个字节，精度约为17位</td>
<td>-1.798E308 ~ 1.798E308</td>
</tr>
</tbody></table>
<p>Java浮点数类型有两种表示形式，分别是十进制形式和科学计数法形式，具体表示方式如下：</p>
<p>十进制数形式，例如：3.14 314.0 .314</p>
<p>科学计数法形式，如：3.14e2 3.14E-1</p>
<p><strong>Java浮点型常量默认为double型，如要声明一个常量为float型，则需在数字后面加f或F，</strong>如:<br>double d &#x3D; 12345.6<br><strong>float f &#x3D; 12.3F</strong></p>
<p><strong>提示：</strong></p>
<ol>
<li><strong>带小数的数据默认是double型而非float型的；</strong></li>
<li>定义float型数据需要后面紧跟”f”或”F”来表示，比如float f &#x3D; 2.1f；</li>
<li>定义长整型数据，可以后面紧跟”l”或”L”来表示。</li>
</ol>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符数据类型用于<strong>存放单个字符，每个字符占用2个字节（16位二进制）的内存空间</strong>。一个字符型数据由单引号括起来，使用”char”关键字来说明数据类型，语法如下：</p>
<p>char letter &#x3D; ‘a’;</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004221957987.png" class="" title="image-20221004221957987">



<p>字符类型是一个16位无符号整数，Java中字符类型的值是对应字符的编码, 是unicode编码，其中，英文部分的值与ascII编码一致。char是定长编码, 所有的字符都是16位。例如：</p>
<p>‘A’ 对应的编码是0x0041</p>
<p>‘中’对用的编码是 0x4e2d</p>
<p>char类型在编码中: ‘0’<del>‘9’, ‘a’</del>‘z’, ‘A’~’Z’都是连续编码的，’0’与’\u0000’不是同一个字符，字符编码的最小值为0, 最大值是65535 ，也就是2^16-1，使用时要注意字符字面量使用单引号为定界符号。</p>
<p><strong>提示：</strong></p>
<ol>
<li>字符型只表示一个字符，不能表示多个字符，比如’abc’是错的；</li>
<li>字符型只能用单引号（’）括起来，用双引号（”）括起来的不是字符，而是字符串（String），比如”a”表示的不是char型字符而是String型字符串。</li>
</ol>
<p>Java还允许使用转义字符来表示特殊字符。转义字符用斜杠”\“打头，后面跟一个字符。</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>转义字符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>退格键</td>
<td>\b</td>
<td>表示一次退格</td>
</tr>
<tr>
<td>Tab键</td>
<td>\t</td>
<td>表示一个Tab空格</td>
</tr>
<tr>
<td>换行符</td>
<td>\n</td>
<td>表示换行</td>
</tr>
<tr>
<td>回车键</td>
<td>\r</td>
<td>表示回车</td>
</tr>
<tr>
<td>斜杠</td>
<td>\\</td>
<td>表示斜杠</td>
</tr>
<tr>
<td>单引号</td>
<td>\‘</td>
<td>表示单引号</td>
</tr>
<tr>
<td>双引号</td>
<td>\“</td>
<td>表示双引号</td>
</tr>
</tbody></table>
<p>转义字符用在一些特殊字符的表示上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeCharDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;escape\bchar&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;escape\tchar&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;escape\rchar&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;escape\nchar&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\\我在斜线里\\&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\&#x27;我在单引号里\&#x27;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我没有单引号&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\&quot;我在双引号里\&quot;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我没有双引号&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004222512443.png" class="" title="image-20221004222512443">



<p><strong>其中\b, \r，在java命令行中能够看到效果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;escape\bchar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;escape\tchar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;escape\rchar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;escape\nchar&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004222613069.png" class="" title="image-20221004222613069">



<p><strong>ASCII码表</strong></p>
<p>对于字符来说，存储的时候，会转为对应的ascII码来进行存储的。<br>因此，字符在计算机中的表示都是以整数来进行表示的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//字符类型变量</span></span><br><span class="line">  <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//字符类型和int类型计算</span></span><br><span class="line">  System.out.println(c+i);<span class="comment">//输出结果是98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ASCII（ American Standard Code for Information Interchange 美国标准信息交换码）。</strong></p>
<p>在char类型和int类型计算的过程中，char类型的字符先查询编码表，得到97，再和1求和，结果为98。</p>
<p>实际就是char类型提升为了int类型（自动类型转换）。char类型内存2个字节，int类型内存4个字节。</p>
<p><strong>ASCII码表</strong></p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004234949377.png" class="" title="image-20221004234949377">

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004235010409.png" class="" title="image-20221004235010409">



<p>java中1.3这种认为是double类型的，因此，1.3f这样表示1.3是float类型的。<br>c中非0即为真，因此可以while（1）这样，但是java中不行，java只能while（true）这样。</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔数据类型由关键字boolean来表示，<strong>布尔型数据的值域只有两个值：true和false</strong>。例如，下面两行代码：</p>
<p>boolean isOK &#x3D; true;</p>
<p>boolean isFirst &#x3D; false;</p>
<p><strong>提示：</strong></p>
<ol>
<li><strong>true和false都是小写，True、TRUE、False、FALSE都不是布尔型数据的值</strong>；</li>
<li><strong>布尔型数据不能用数字0和1来表示真假，只能用true和false；</strong></li>
<li><strong>布尔型数据默认值是false。</strong></li>
</ol>
<p><strong>例2.5 布尔数据类型</strong></p>
<p>boolean flag;</p>
<p>flag &#x3D; true;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//定义字节型变量</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//定义短整型变量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//定义整型变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">//定义长整型变量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">12345678900L</span>;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        <span class="comment">//定义单精度浮点型变量</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">5.5F</span>;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">//定义双精度浮点型变量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">8.5</span>;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        <span class="comment">//定义布尔型变量</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        System.out.println(bool);</span><br><span class="line">        <span class="comment">//定义字符型变量</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>long类型：建议数据后加L表示。<br>ﬂoat类型：建议数据后加F表示。</p>
<p>注意事项：</p>
<p>变量名称：在同一个大括号范围内，变量的名字不可以相同。否者会报重复定义的错误。<br>变量赋值：定义的变量，不赋值不能使用。</p>
<p>变量要先定义后使用。</p>
<p>每条语句最后要加分号;否则语法错误。</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>Java是强类型语言，要求赋值或传递时数据类型必须匹配，我们可以利用Java提供的数据类型的转换来消除这种错误。</p>
<p>Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。</p>
<p><strong>Java提供了两种数据类型的转换方式：自动转换和强制转换</strong></p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004223055828.png" class="" title="image-20221004223055828">



<h3 id="自动数据类型转换"><a href="#自动数据类型转换" class="headerlink" title="自动数据类型转换"></a>自动数据类型转换</h3><p>自动数据类型转换也称之为隐式类型转换，我们在数值数据类型中了解到，不同类型的数据会占用不同大小的存储空间，那么<strong>数据类型自</strong></p>
<p><strong>动转换的原则就是</strong>：<strong>小空间的数据类型可以自动转换成大空间的数据类型</strong>，<strong>也就是说低精度的数据可以升级成高精度的数据</strong>，反之不行，</p>
<p>我们可以理解成高精度的数据转换成低精度的数据会失去数据的精度，所以不能这样转换。数据类型的自动转换顺序如下图</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004223327366.png" class="" title="image-20221004223327366">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// byte x = b + i; // 报错</span></span><br><span class="line">    <span class="comment">//int类型和byte类型运算，结果是int类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b + i;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运算结果，变量的类型将是 int 类型，这就是出现了数据类型的自动类型转换现象。</p>
<p>byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类型。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004233905882.png" class="" title="image-20221004233905882">



<p>同理，当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">2.5</span>;</span><br><span class="line">    <span class="comment">//int类型和double类型运算，结果是double类型</span></span><br><span class="line">    <span class="comment">//int类型会提升为double类型</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> d+i;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>转换规则：</p>
<p>范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int 。</p>
<p>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</p>
<h3 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h3><p>将 1.5 赋值到 int 类型变量会发生什么？产生编译失败，肯定无法赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1.5</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>double 类型内存8个字节， int 类型内存4个字节。 1.5 是 double 类型，取值范围大于 int 。</p>
<p>想要赋值成功，只有通过强制类型转换，将 double 类型强制转换成 int 类型才能赋值。</p>
<p>自动转换是Java自动执行的，而强制转换需要我们自己手动执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// double类型数据强制转成int类型，直接去掉小数点。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1.5</span>;</span><br></pre></td></tr></table></figure>



<p>强制数据类型转换也称之为显式类型转换，既然有些数据类型不能互相自动进行转换，那么Java提供了强制转换的方法，强制转换的语法就是用圆括号括起你要转换成的目的数据类型：</p>
<p>变量&#x3D;（目标类型）值;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">a = (<span class="type">byte</span>) b;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">2.8</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> (<span class="type">float</span>)<span class="number">5.2</span>;</span><br></pre></td></tr></table></figure>



<p>当一个 short 类型与 1 相加，我们知道会类型提升，但是还想给结果赋值给short类型变量，就需要强制转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">//short类型变量，内存中2个字节</span></span><br><span class="line">     <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">       出现编译失败</span></span><br><span class="line"><span class="comment">       s和1做运算的时候，1是int类型，s会被提升为int类型</span></span><br><span class="line"><span class="comment">       s+1后的结果是int类型，将结果在赋值会short类型时发生错误</span></span><br><span class="line"><span class="comment">       short内存2个字节，int类型4个字节</span></span><br><span class="line"><span class="comment">       必须将int强制转成short才能完成赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     s = s + <span class="number">1</span>；<span class="comment">//编译失败</span></span><br><span class="line">     s = (<span class="type">short</span>)(s+<span class="number">1</span>);<span class="comment">//编译成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004234246121.png" class="" title="image-20221004234246121">

<p><strong>注意：</strong></p>
<p>　　浮点转成整数，直接取消小数点，可能造成数据损失精度。<br>　　int 强制转成 short 砍掉2个字节，可能造成数据丢失。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义s为short范围内最大值</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">32767</span>;</span><br><span class="line"><span class="comment">// 运算后，强制转换，砍掉2个字节后会出现不确定的结果</span></span><br><span class="line">s = (<span class="type">short</span>)(s + <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004234426297.png" class="" title="image-20221004234426297">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> b;</span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line">b = b*<span class="number">3</span>;java会自动做类型提升，将b自动提升为<span class="type">int</span>，因此，会发生错误。</span><br><span class="line">b = （<span class="type">byte</span>）b*<span class="number">3</span>;这样，但是还是报错，因为强制类型转换比乘法优先级高。</span><br><span class="line">b = （<span class="type">byte</span>）（b*<span class="number">3</span>）;应该这样。</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestConvert</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String arg[])</span> &#123;</span><br><span class="line">    <span class="comment">/*自动类型转换*/</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">45</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> (i1 + i2) * <span class="number">1.0</span>;<span class="comment">//系统将转换为double型运算</span></span><br><span class="line">    System.out.println(d1);</span><br><span class="line">    <span class="comment">/*自动类型转换*/</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="number">12.3f</span>;<span class="comment">//必须加f</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">12300</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">300000000000L</span>;<span class="comment">//必须加l</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> l1 + l2 + f3;<span class="comment">//系统将转换为float型计算</span></span><br><span class="line">    System.out.println(f);</span><br><span class="line">    <span class="type">byte</span> m1=<span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> m2=<span class="number">3</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">byte</span>)(m1+m2);<span class="comment">//byte类型参与运算会自动转换为int类型，然后再进行运算，结果为int，因此，需要强转为byte赋值</span></span><br><span class="line">    <span class="comment">/*强制类型转换*/</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> (<span class="type">long</span>)f;<span class="comment">//强制转换会舍去小数部分（不是四舍五入）</span></span><br><span class="line">    System.out.println(l);</span><br><span class="line">    <span class="comment">/*强制类型转换*/</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">67</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">89</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> (<span class="type">byte</span>)(b1 + b2);<span class="comment">//系统将转换为int型运算，需要强制转换符</span></span><br><span class="line">    System.out.println(b3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004225305700.png" class="" title="image-20221004225305700">

<p>67+89&#x3D;156</p>
<p>156-127&#x3D;28</p>
<p>byte范围是-128~127，因此，当超过了范围之后就会溢出，然后又会从最小的开始了。因此，128就是-128,129就是-127，以此类推，156就是-100。</p>
<p><strong>提示：</strong></p>
<ol>
<li><strong>boolean型数据不能和其他基本数据类型进行转换；</strong></li>
<li><strong>char型和int型数据可以互换；</strong></li>
<li><strong>byte、short、char之间不会相互转换，它们三者在计算时首先会转换为int类型；</strong></li>
<li>在强制类型转换过程中，源类型的值可能大于目标类型，因此可能造成精度降低或溢出，使用时需注意。</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符和表达式"><a href="#算术运算符和表达式" class="headerlink" title="算术运算符和表达式"></a>算术运算符和表达式</h3><p>算术运算是一种常见的运算，主要是对数值型数据进行加减乘除等运算</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>名称</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加运算符</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减运算符</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>乘运算符</td>
<td></td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除运算符</td>
<td>若是两个整数相除，只保留整数部分</td>
</tr>
<tr>
<td>%</td>
<td>取模（取余）运算符</td>
<td><strong>被除数为正数结果都为正，被除数为负数结果都为负</strong></td>
</tr>
<tr>
<td>++</td>
<td>自增</td>
<td>++变量名：变量在参与其他操作前先将自己加1; 变量名++：先用原来的值参与其他操作后，再将自己加1</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>算法同++</td>
</tr>
<tr>
<td>+</td>
<td>字符串连接</td>
<td>当操作数中只要有一个是String类型，系统会自动将另一个操作数转换成字符串类型，然后进行连接</td>
</tr>
</tbody></table>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004225941405.png" class="" title="image-20221004225941405">

<p>被除数为正，结果为正。不看除数正负</p>
<p>被除数为负，结果为负。不看除数正负</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004225958659.png" class="" title="image-20221004225958659">

<p>由于被除数是5.0，因此，2会自动类型转换为double，然后进行计算，因此，结果为double的。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230012172.png" class="" title="image-20221004230012172">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfplusOperatorDemo1</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;, &quot;</span> + i);<span class="comment">// 0,1</span></span><br><span class="line">    a = ++i;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;, &quot;</span> + i);<span class="comment">// 2,2</span></span><br><span class="line">    i = i++;</span><br><span class="line">    System.out.println(i);<span class="comment">// 2</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 0</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 1</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 2</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 0</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 1</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 2</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230310108.png" class="" title="image-20221004230310108">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfplusOperatorDemo2</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">3</span>, y1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="number">3</span>, y2 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> r1, r2;</span><br><span class="line">    r1 = x1++ + x1*y1;</span><br><span class="line">    r2 = ++x2 + x2*y2;</span><br><span class="line">    System.out.println(<span class="string">&quot;x1=&quot;</span>+x1+<span class="string">&quot; y1=&quot;</span>+y1+<span class="string">&quot; r1=&quot;</span>+r1);</span><br><span class="line">    System.out.println(<span class="string">&quot;x2=&quot;</span>+x2+<span class="string">&quot; y2=&quot;</span>+y2+<span class="string">&quot; r2=&quot;</span>+r2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230544013.png" class="" title="image-20221004230544013">

<p>注意，+运算符是左结合性，也就是从左向右运算的。</p>
<h3 id="字符串和运算符"><a href="#字符串和运算符" class="headerlink" title="字符串和运算符"></a>字符串和运算符</h3><p>字符串连接运算符使用”+”运算符，但此时与算术运算符中的加法运算符”+”的意义是不同的。字符串连接运算符，能够将多个字符串合并到一起生成一个新的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">2.15f</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">5.7</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;c=&quot;</span> + c);</span><br><span class="line">    System.out.println(<span class="string">&quot;s=&quot;</span> + s);</span><br><span class="line">    System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">    System.out.println(<span class="string">&quot;f=&quot;</span> + f);</span><br><span class="line">    System.out.println(<span class="string">&quot;d=&quot;</span> + d);</span><br><span class="line">    System.out.println(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230716894.png" class="" title="image-20221004230716894">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line">		<span class="type">float</span> f=<span class="number">2.5f</span>;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i+f+c+s);</span><br><span class="line">		</span><br><span class="line">		System.out.println(i+f+s+c);</span><br><span class="line">		</span><br><span class="line">		System.out.println(c+s+i+f);</span><br><span class="line">		</span><br><span class="line">		System.out.println(c+s+(i+f));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230949690.png" class="" title="image-20221004230949690">



<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>名称</strong></th>
<th><strong>例子</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值运算符</td>
<td>i&#x3D;8</td>
<td>8赋值给i</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加简捷赋值运算符</td>
<td>i+&#x3D;8</td>
<td>同i&#x3D;i+8</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减简捷赋值运算符</td>
<td>i-&#x3D;8</td>
<td>同i&#x3D;i-8</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘简捷赋值运算符</td>
<td>i*&#x3D;8</td>
<td>同i&#x3D;i*8</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除简捷赋值运算符</td>
<td>i&#x2F;&#x3D;8</td>
<td>同i&#x3D;i&#x2F;8</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>取模简捷赋值运算符</td>
<td>i%&#x3D;8</td>
<td>同i&#x3D;i%8</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		i+=<span class="number">8</span>;<span class="comment">//18</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">		</span><br><span class="line">		i-=<span class="number">8</span>;<span class="comment">//10</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">	</span><br><span class="line">		i*=<span class="number">8</span>;<span class="comment">//	80</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">		</span><br><span class="line">		i/=<span class="number">8</span>;<span class="comment">//10</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">		</span><br><span class="line">		i%=<span class="number">8</span>;<span class="comment">//2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意，在java中的基本数据类型的赋值而言是将变量值放到变量的内存单元中去，然后该内存单元命名为变量名。不同于python中的变量值与变量名绑定的含义。</strong></p>
<p><strong>python中变量值与变量名绑定，更像是java中的引用类型的变量值与变量名的关系，变量中存储的是引用类型值的内存地址或者叫做引用地址。</strong></p>
<h3 id="关系运算符和表达式"><a href="#关系运算符和表达式" class="headerlink" title="关系运算符和表达式"></a>关系运算符和表达式</h3><p><strong>关系运算又叫比较运算</strong>，用来对两个操作数进行大小、等于的关系比较，</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>样例</th>
<th>结果说明</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于</td>
<td>1&gt;2</td>
<td>false</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td>1&gt;&#x3D;2</td>
<td>false</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>1&lt;2</td>
<td>true</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td>1&lt;&#x3D;2</td>
<td>true</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>等于</td>
<td>1&#x3D;&#x3D;2</td>
<td>false</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>1!&#x3D;2</td>
<td>true</td>
</tr>
</tbody></table>
<p>比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 true 或者 false 。</p>
<p>注意，比较运算符最终的运算结果为布尔值的。</p>
<p><strong>关系表达式用于进行关系比较，关系表达式的值都是布尔型的</strong>，例如下面代码：</p>
<p>int i &#x3D; 10;</p>
<p>int j &#x3D; 16;</p>
<p>boolean smalli &#x3D; i&lt;j;</p>
<p>boolean equal &#x3D; i&#x3D;&#x3D;j;</p>
<p>boolean bigi &#x3D; i&gt;j;</p>
<p><strong>提示：</strong></p>
<ol>
<li>关系表达式的结果都是布尔值，true或false；</li>
<li>比较相等的是双等号”&#x3D;&#x3D;”，不是一个等号”&#x3D;”，一个等号”&#x3D;”只能用来赋值。</li>
</ol>
<h3 id="逻辑运算符和表达式"><a href="#逻辑运算符和表达式" class="headerlink" title="逻辑运算符和表达式"></a>逻辑运算符和表达式</h3><p>逻辑运算又叫布尔运算，包括四个运算符，分别是&amp;&amp;、||、！和^，用来进行与、或、非和异或的逻辑运算。</p>
<p><strong>逻辑运算的操作数和结果都是布尔类型的值。</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th><strong>运算符</strong></th>
<th><strong>名称</strong></th>
<th><strong>运算规则</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>与运算符</td>
<td>逻辑与</td>
<td>运算符左右两端的操作数都为true，表达式结果才为true，其它情况表达式结果为false</td>
</tr>
<tr>
<td>| |</td>
<td>或运算符</td>
<td>逻辑或</td>
<td>运算符左右两端的操作数都为false，表达式结果才为false，其它情况表达式结果为true</td>
</tr>
<tr>
<td>!</td>
<td>非运算符</td>
<td>逻辑取反</td>
<td>操作数为true，结果为false；操作数为false，结果为true</td>
</tr>
<tr>
<td>^</td>
<td>异或运算符</td>
<td>逻辑异或</td>
<td>运算符左右两端的操作数，相同结果为false，不同结果为true</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		System.out.println(x&amp;&amp;y);<span class="comment">//false</span></span><br><span class="line">		System.out.println(x||y);<span class="comment">//true</span></span><br><span class="line">		System.out.println(!x);<span class="comment">//false</span></span><br><span class="line">		System.out.println(x^y);<span class="comment">//亦或，相同为假，不同为真				</span></span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>



<p><strong>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false</strong></p>
<p>注意，在python中，运算结果不一定是ture或者false的。要看两边的内容，例如，11 || False，那么结果是11，不是布尔值的，因为，python中，非0的11表示了True。</p>
<p>而在java中，逻辑运算符两侧必须是布尔类型的值才行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">55</span>&gt;<span class="number">13</span> || <span class="literal">false</span>); <span class="comment">//结果为true</span></span><br><span class="line"><span class="comment">//        System.out.println(55 || 0); error ||两侧数据类型错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>短路与vs非短路与</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//短路与&amp;&amp; vs 非短路与&amp;</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">20</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//boolean flag = a&gt;b &amp;&amp; ++b&gt;c;//左边为假，右边短路了</span></span><br><span class="line">		<span class="comment">//System.out.println(flag);//false</span></span><br><span class="line">		<span class="comment">//System.out.println(b);//20</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> a&gt;b &amp; ++b&gt;c;<span class="comment">//右边不短路</span></span><br><span class="line">		System.out.println(flag);<span class="comment">//false</span></span><br><span class="line">		System.out.println(b);<span class="comment">//21			</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>短路或 vs 非短路或</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//短路或|| vs 非短路|		</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">20</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//boolean flag = a&lt;b||++b&gt;c;//左边为真，右边短路了</span></span><br><span class="line">		<span class="comment">//System.out.println(flag);//true</span></span><br><span class="line">		<span class="comment">//System.out.println(b);//20</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> a&lt;b|++b&gt;c;<span class="comment">//右边不短路</span></span><br><span class="line">		System.out.println(flag);<span class="comment">//true</span></span><br><span class="line">		System.out.println(b);<span class="comment">//21	</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>三目条件运算符的语法为：</p>
<p><strong>表达式1 ? 表达式2 : 表达式3</strong></p>
<p>int a&#x3D;3, b&#x3D;6;</p>
<p>int x &#x3D; a&gt;b? a:b;</p>
<p>那么计算结果就是x&#x3D;6。</p>
<p><strong>在三目条件运算中，表达式1和表达式2的值可以是任意一种基本数据类型。</strong></p>
<p><strong>数据类型 变量名 &#x3D; 布尔类型表达式？结果1：结果2</strong></p>
<p><strong>三元运算符计算方式：</strong><br>　　布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。<br>　　布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 三目条件运算符		</span></span><br><span class="line">		<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> a&lt;b?<span class="literal">true</span>:<span class="literal">false</span>;	</span><br><span class="line">		<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> a&lt;b?<span class="string">&#x27;真&#x27;</span>:<span class="string">&#x27;假&#x27;</span>;	</span><br><span class="line">		<span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> a&lt;b?<span class="string">&quot;正确&quot;</span>:<span class="string">&quot;错误&quot;</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a&lt;b?<span class="number">1</span>:<span class="number">0</span>;		</span><br><span class="line">		<span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> a&lt;b?<span class="number">1.0</span>:<span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004233201050.png" class="" title="image-20221004233201050">



<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>表达式通常由多个运算符组成。优先级的规则决定每个运算符在任何给定表达式中的计算顺序。表达式是按照从左到右运算符的优先级来进行运算的，正因为这种优先级的限制，才保证了每个表达式每次运算的结果都一样。</p>
<p>按操作数多少划分优先级</p>
<p>一元操作符 &gt; 二元操作符 &gt; 三元操作符</p>
<p>按运算类型划分优先级</p>
<p>算术运算符 &gt; 关系运算符 &gt; 逻辑运算符 &gt; 赋值运算符</p>
<p>尽量多的使用括号，括号优先级别最高，使用括号也可保证在不确定优先级的情况下，更好地控制语句的执行顺序。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004233454906.png" class="" title="image-20221004233454906">



<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式是符合一定语法规则的运算符和运算数的序列。按照使用的运算符和运算结果的不同可以分为：</p>
<p>1.算术表达式</p>
<p>例如：(x+y-12)*100</p>
<p>2.关系表达式</p>
<p>例如：x&gt;y， x&gt;&#x3D;y， x!&#x3D;y， x&#x3D;&#x3D;y</p>
<p>3、逻辑表达式</p>
<p>例如：x&amp;&amp;y， x||y||z， (!x)&amp;&amp;(!y)</p>
<p>4、赋值表达式</p>
<p>例如：x&#x3D;y， x+&#x3D;y</p>
<p>关于表达式，有下面几个概念需要介绍。</p>
<p>表达式的值：对表达式中操作数进行运算得到的结果称为表达式的值；</p>
<p>表达式的类型：表达式值的数据类型即为表达式的类型；</p>
<p>表达式的运算顺序：应按照运算符的优先级从高到低的顺序进行，优先级相同的运算符按照事先约定的结合方向进行</p>
<p>表达式后面加上;，即为语句了。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>07-方法详解</title>
    <url>/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="07-方法详解"><a href="#07-方法详解" class="headerlink" title="07-方法详解"></a>07-方法详解</h1><p><strong>方法：</strong>就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</p>
<p>不使用方法的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func_sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 打印一个3行，3列的矩形</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; <span class="number">3</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; <span class="number">3</span>; col++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 打印一个5行，6列的矩形</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 打印一个7行，8列的矩形</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007200513995.png" class="" title="image-20221007200513995">







<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表）｛</span><br><span class="line">        代码...   </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>定义格式解释：</p>
<p>　　修饰符： 目前固定写法 public static 。后面还会学习其它的修饰符<br>　　返回值类型： 目前固定写法 void ，其他返回值类型在后面遇到再说。<br>　　方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法。<br>　　参数列表： 目前无参数， 带有参数的方法在后面遇到再说。<br>　　<strong>return：方法结束。因为返回值类型是void，方法大括号内的return可以不写。或者写成return;也是可以的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是一个方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><p>方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法main中来调用我们自己定义好的方法。在主方法中，直接写要调用的方法名字并加上括号就可以调用了。</p>
<p><strong>注意，方法如果不调用，它是不会进入到方法调用栈进行执行的，只是在代码区中存放的死的代码而已。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//调用定义的方法method</span></span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义方法，被main方法调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自己定义的方法，需要被main调用运行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，Java中将要调用的方法定义在主方法后面也是没有问题的，Java编译器能够识别到它编译通过，并且执行的时候，从上到下执行也是能够搜寻到它的。</strong></p>
<p><strong>方法定义注意事项：</strong><br>　　<strong>方法必须定义在一类中，方法外</strong>。<strong>在Java中，所有内容组织都是以类为最小单位的，不能够脱离类而单独存在。</strong><br>　　<strong>方法不能定义在另一个方法的里面，方法不支持嵌套定义。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正确写法，类中，main方法外面可以定义方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//错误写法，一个方法不能定义在另一方法内部，不支持嵌套定义</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JShell脚本工具"><a href="#JShell脚本工具" class="headerlink" title="JShell脚本工具"></a>JShell脚本工具</h2><p><strong>JShell脚本工具是JDK9的新特性</strong><br>　　什么时候会用到 JShell 工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运行，这个时候可以使用JShell工具。<br>　　启动JShell工具，在DOS命令行直接输入JShell命令。</p>
<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007193143874.png" class="" title="image-20221007193143874">



<p>接下来可以编写Java代码，无需写类和方法，直接写方法中的代码即可，同时无需编译和运行，直接回车即可</p>
<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007193215249.png" class="" title="image-20221007193215249">

<p>JShell工具，只适合片段代码的测试，开发更多内容，建议编写在方法中。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="x3D-符号的扩展"><a href="#x3D-符号的扩展" class="headerlink" title="+&#x3D;符号的扩展"></a>+&#x3D;符号的扩展</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  s+=<span class="number">1</span>;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析： s +&#x3D; 1 逻辑上看作是 s &#x3D; s + 1 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能将取值范围大的类型赋值到取值范围小的类型。但是， s&#x3D;s+1进行两次运算 ， <strong>+&#x3D; 是一个运算符，只运算一次，并带有强制转换的特点，</strong>也就是说 s +&#x3D; 1 就是 s &#x3D; (short)(s + 1) ，因此程序没有问题编译通过，运行结果是2.</p>
<h3 id="常量和变量的运算"><a href="#常量和变量的运算" class="headerlink" title="常量和变量的运算"></a>常量和变量的运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="type">byte</span> b1=<span class="number">1</span>;</span><br><span class="line">  <span class="type">byte</span> b2=<span class="number">2</span>;</span><br><span class="line">  <span class="type">byte</span> b3=<span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">  <span class="type">byte</span> b4=b1 + b2;</span><br><span class="line">  System.out.println(b3);</span><br><span class="line">  System.out.println(b4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析： b3 &#x3D; 1 + 2 ， 1 和 2 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 1+2 的结果并没有超过byte类型的取值范围，可以赋值给变量 b3 ，因此 b3&#x3D;1 + 2 是正确的。<br>反之， b4 &#x3D; b1 + b2 ， b1 和 b2 是变量，变量的值是可能变化的，在编译的时候，编译器javac不确定b1+b2的结果是什么，编译器只是知道b1和b2的类型都是byte，因此会将b1和b2自动类型转换为int进行相加运算，结果为int的，会将结果以int类型进行处理，所以int类型不能赋值给byte类型，因此编译失败。</p>
<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007193940901.png" class="" title="image-20221007193940901">



<h2 id="方法进阶"><a href="#方法进阶" class="headerlink" title="方法进阶"></a>方法进阶</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问控制符] [修饰符] 返回值类型 方法名( 参数类型 形式参数,参数类型 形式参数,…) </span><br><span class="line">&#123; </span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表)&#123;</span><br><span class="line"><span class="comment">//代码省略...</span></span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰符： public static 固定写法，目前这样写，后续学习其它修饰符<br>返回值类型： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者。如果没有返回值，可以定义为void。<br>参数列表：方法在运算过程中的未知数据，调用者调用方法时传递。参数列表是可选的，可以为空。参数可以是0个或者多个，多个参数之间使用逗号分割。<br>return：将方法执行后的结果带给调用者，方法执行到 return ，整体方法运行结束。</p>
<p><strong>注意：参数列表中的参数，称之为“形参”。调用该方法传递的参数，称之为“实参”</strong></p>
<p><strong>定义方法的两个明确，即要确定参数列表和返回值类型</strong></p>
<p> <strong>明确返回值类型</strong></p>
<p> <strong>明确参数列表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用方法getSum，传递两个整数，这里传递的实际数据又称为实际参数</span></span><br><span class="line">        <span class="comment">// 并接收方法计算后的结果，返回值     </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义计算两个整数和的方法</span></span><br><span class="line"><span class="comment">    返回值类型，计算结果是int</span></span><br><span class="line"><span class="comment">    参数：不确定数据求和，定义int参数.参数又称为形式参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007194517802.png" class="" title="image-20221007194517802">





<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比较两个整数是否相同</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法compare，传递两个整数</span></span><br><span class="line">        <span class="comment">//并接收方法计算后的结果，布尔值</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> compare(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">        System.out.println(bool);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义比较两个整数是否相同的方法</span></span><br><span class="line"><span class="comment">        返回值类型，比较的结果布尔类型</span></span><br><span class="line"><span class="comment">        参数：不确定参与比较的两个整数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">计算<span class="number">1</span>+<span class="number">2</span>+<span class="number">3.</span>..+<span class="number">100</span>的和</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法getSum</span></span><br><span class="line">        <span class="comment">//并接收方法计算后的结果，整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义计算1~100的求和方法</span></span><br><span class="line"><span class="comment">        返回值类型，计算结果整数int</span></span><br><span class="line"><span class="comment">        参数：没有不确定数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//定义变量保存求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从1开始循环，到100结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现不定次数打印</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法printHelloWorld，传递整数</span></span><br><span class="line">        printHelloWorld(<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义打印HelloWorld方法</span></span><br><span class="line"><span class="comment">    返回值类型，计算没有结果 void</span></span><br><span class="line"><span class="comment">    参数：不确定打印几次</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloWorld</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="定义方法的注意事项"><a href="#定义方法的注意事项" class="headerlink" title="定义方法的注意事项"></a>定义方法的注意事项</h2><p><strong>定义位置，类中，其它方法外面。不支持嵌套定义</strong><br><strong>返回值类型，必须要和 return 语句返回的类型相同，否则编译失败</strong> 。</p>
<p><strong>对于return后面的值可以自动类型转换为定义方法时指定的返回值类型的，则不会报错，例如，return的是byte类型，然后返回值类型定义为int。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值类型要求是int</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;<span class="comment">// 正确，int类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.2</span>;<span class="comment">// 错误，类型不匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 错误，类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能在 return 后面写代码， return 意味着方法结束，所有后面的代码永远不会执行，属于无效代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);<span class="comment">// 错误，return已经结束，这里不会执行，无效代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="调用方法的三种形式"><a href="#调用方法的三种形式" class="headerlink" title="调用方法的三种形式"></a>调用方法的三种形式</h2><h3 id="直接调用：直接写方法名调用"><a href="#直接调用：直接写方法名调用" class="headerlink" title="直接调用：直接写方法名调用"></a>直接调用：直接写方法名调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法被调用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="赋值调用：调用方法，在方法前面定义变量，接收方法返回值"><a href="#赋值调用：调用方法，在方法前面定义变量，接收方法返回值" class="headerlink" title="赋值调用：调用方法，在方法前面定义变量，接收方法返回值"></a>赋值调用：调用方法，在方法前面定义变量，接收方法返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出语句调用：在输出语句中调用方法"><a href="#输出语句调用：在输出语句中调用方法" class="headerlink" title="输出语句调用：在输出语句中调用方法"></a>输出语句调用：在输出语句中调用方法</h3><p>在输出语句中调用方法， System.out.println(方法名()) 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(getSum(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能用输出语句调用 void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(printHello());<span class="comment">// 错误，不能输出语句调用void类型方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果方法返回一个值，对方法的调用通常就当做一个值处理。<br>如果方法返回void，对方法的调用应是当做语句处理。</p>
<p>所谓调用方法，其实就是给方法的入口传入一些值（参数），然后在出口得到方法执行的结果（返回值）。给方法传入参数的过程，称为“传参”。实际上，方法传参的过程就是把实参赋值给对应的形参的过程，并且实参和形参的数量、类型必须匹配。</p>
<ul>
<li>形参必须注明数据类型</li>
<li>实参直接写，不需要类型声明</li>
<li>return只能返回一次</li>
<li>遇到return语句，方法结束执行，后续语句不执行</li>
<li>方法的返回值，必须与方法声明中的返回值类型匹配</li>
<li>方法定义，不能写在main()中</li>
<li>方法的定义是不能嵌套的</li>
</ul>
<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007203513036.png" class="" title="image-20221007203513036">



<h2 id="方法调用的值传递（简单类型或者叫做基本类型）和引用传递（引用类型）"><a href="#方法调用的值传递（简单类型或者叫做基本类型）和引用传递（引用类型）" class="headerlink" title="方法调用的值传递（简单类型或者叫做基本类型）和引用传递（引用类型）"></a>方法调用的值传递（简单类型或者叫做基本类型）和引用传递（引用类型）</h2><img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007203757588.png" class="" title="image-20221007203757588">



<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func_sample2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 打印一个n行，m列的矩形</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">printRectangle</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        printRectangle(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        printRectangle(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        printRectangle(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007201729233.png" class="" title="image-20221007201729233">



<h2 id="方法分类"><a href="#方法分类" class="headerlink" title="方法分类"></a>方法分类</h2><p><strong>根据参数个数：</strong></p>
<ul>
<li>无参方法</li>
<li>有参方法</li>
</ul>
<p><strong>根据返回值类型:</strong></p>
<ul>
<li>有返回值的方法</li>
</ul>
<p>​			根据返回值的类型细分为：</p>
<p>​						基本数据类型<br>​						引用数据类型</p>
<ul>
<li>无返回值的方法</li>
</ul>
<p>​			void</p>
<p><strong>无返回值，无入参的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drawRect</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> width=<span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> height=<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;width;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>无返回值，有入参的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getBigger</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y )</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>( x&gt;=y ) &#123; </span><br><span class="line">             System.out.println( x ); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">             System.out.println( y ); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//没有返回值，return可以省略</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>有返回值，无入参的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">100</span>;</span><br><span class="line">		<span class="type">int</span> y=<span class="number">200</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span>x+y;</span><br><span class="line">		<span class="keyword">return</span> z;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>有返回值，有入参的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">absolut</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x; </span><br><span class="line">         &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -x;</span><br><span class="line">         &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p><strong>方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。</strong><br>参数列表：个数不同，数据类型不同，顺序不同。<br>重载方法调用：JVM通过方法名和方法的参数列表，来确定要调用的方法，从而调用不同的方法。</p>
<p><strong>注意：方法名相同，参数个数不同，数据类型不同，顺序不同，构成重载，与其它都无关。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比较两个数据是否相等。参数类型分别为两个 <span class="type">byte</span> 类型，两个 <span class="type">short</span> 类型，两个 <span class="type">int</span> 类型，两个 <span class="type">long</span> 类型，并</span><br><span class="line">在 main 方法中进行测试。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义不同数据类型的变量</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        System.out.println(compare(a, b));</span><br><span class="line">        System.out.println(compare(c, d));</span><br><span class="line">        System.out.println(compare(e, f));</span><br><span class="line">        System.out.println(compare(g, h));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 两个byte类型的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">byte</span> a, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;byte&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 两个short类型的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">short</span> a, <span class="type">short</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 两个int类型的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 两个long类型的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">判断哪些方法是重载关系。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> i,<span class="type">double</span> d)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">OPEN</span><span class="params">()</span>&#123;&#125; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;&#125; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">模拟输出语句中的 println 方法效果，传递什么类型的数据就输出什么类型的数据，只允许定义一个方法名</span><br><span class="line">println 。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">byte</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">short</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">long</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">float</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">boolean</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>05-流程控制语句</title>
    <url>/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="05-流程控制语句"><a href="#05-流程控制语句" class="headerlink" title="05-流程控制语句"></a>05-流程控制语句</h1><p><strong>顺序结构：代码从上向下执行。</strong></p>
<p><strong>选择结构</strong></p>
<p><strong>循环结构</strong></p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>在Java语言中，条件语句主要有两类语法：if语句和switch语句</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p><strong>if语句（单一条件）</strong></p>
<p>该类语句的语法格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式) &#123;</span><br><span class="line">执行语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005193048890.png" class="" title="image-20221005193048890">



<p><strong>语法说明：</strong></p>
<ol>
<li>if是该语句中的关键字，后续小括号不可省略；</li>
<li>条件表达式返回的结果为布尔型，当返回为真值时才能执行if功能代码；</li>
<li><strong>功能代码块为多行时，应将其放在花括号”{}”中间，当功能代码块为单行时，则不需要花括号；</strong></li>
<li><strong>不论if语句块是单行还是多行，建议都用花括号”{}”括起来；</strong></li>
<li>if()子句后不能跟分号”;”。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">If_sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x等于1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;x的值为&quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204105922.png" class="" title="image-20221005204105922">



<p><strong>if语句(二选一)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    功能代码块<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    功能代码块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204132567.png" class="" title="image-20221005204132567">

<p><strong>如果功能代码1和2只有一句，则不需要加花括号”{}”。</strong></p>
<p><strong>语法说明：</strong></p>
<p>if-else语句的代码执行过程等价于 三目条件运算符。</p>
<p>变量 &#x3D; 布尔表达式 ? 语句1:语句2</p>
<p>如果布尔表达式的值为true，则执行语句1</p>
<p>如果布尔表达式的值为false，则执行语句2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">If_Sample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;n是奇数&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;条件表达式返回值为真&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;n不是奇数&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;条件表达式返回值为假&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204143342.png" class="" title="image-20221005204143342">





<p>当有多个if在程序的语句中存在时，else与最近的if匹配。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">2</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    功能代码块<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，else对应条件表达式2，条件表达式1的if语句将独立执行。</p>
<p>if语句和三元运算符的互换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//定义变量，保存a和b的较大值</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">        c = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以上述功能改写为三元运算符形式</span></span><br><span class="line">    c = a &gt; b ? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>if语句(多选一)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">2</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">3</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">3</span>;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    功能代码块n;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204154312.png" class="" title="image-20221005204154312">

<p><strong>语法说明：</strong></p>
<ol>
<li>else if是else和if两个关键字，中间使用空格进行间隔；</li>
<li>条件表达式返回值都是布尔类型；</li>
<li>else if语句可以有任意多句；</li>
<li><strong>最后的else语句为可选；</strong></li>
<li><strong>如果功能代码部分只有一条语句而不是语句块，花括号”{}”可以省略。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">If_Sample3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">55</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">100</span> &amp;&amp; i &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是A&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是B&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是C&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是D&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是E&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204433192.png" class="" title="image-20221005204433192">





<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">   <span class="keyword">case</span> 取值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">   <span class="keyword">case</span> 取值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">case</span> 取值n:</span><br><span class="line">        语句块n;</span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">        语句块n+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>语法说明：</strong></p>
<ol>
<li><strong>表达式的类型只能为byte、short、char、int、enum（枚举），在Java7中增加了对String类型的支持；</strong></li>
<li>case语句是标号语句，只确定程序的入口；</li>
<li><strong>值1、值2……值n只能为常数或常量，不能为变量，而且值不能重复；</strong></li>
<li>功能代码部分可以写任意多句；</li>
<li>break关键字结束switch语句，为可选项；</li>
<li>default语句功能类似于if-else语句中的else。</li>
</ol>
<p><strong>注意，continue语句不能用于Switch中。</strong></p>
<p><strong>break有两个地方可以使用，Switch中，循环语句中。</strong></p>
<p><strong>switch语句的代码执行过程为：</strong></p>
<p>将case语句后的值和表达式的值比较，若相等即从该case语句开始向下执行，如果没有break语句，则一直执行到switch语句的结束，如果遇到break语句，则结束switch语句的执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch_sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Block A&quot;</span>);</span><br><span class="line">            result = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Block B&quot;</span>);</span><br><span class="line">            result = n * n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Block C&quot;</span>);</span><br><span class="line">            result = n * n * n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005212718524.png" class="" title="image-20221005212718524">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch_sample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (score / <span class="number">10</span>) &#123;<span class="comment">//注意，这里可以是表达式，但是表达式的运算结果必须是byte，short，int，char，String</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为A&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为B&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为C&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为D&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为E&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005212917127.png" class="" title="image-20221005212917127">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch_</span> sample3 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Finally Friday!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Super Saturday!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Sleepy Sunday!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;I hope for my Weekend!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213022570.png" class="" title="image-20221005213022570">





<p>case的穿透性 ：</p>
<p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      System.out.println(<span class="string">&quot;执行case0&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      System.out.println(<span class="string">&quot;执行case5&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">      System.out.println(<span class="string">&quot;执行case10&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      System.out.println(<span class="string">&quot;执行default&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序中，执行case5后，由于没有break语句，程序会一直向后走，不会在判断case，也不会理会前面的break，直接运行完整体switch。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213147397.png" class="" title="image-20221005213147397">

<p><strong>while语句的代码执行过程为：</strong></p>
<p>首先判断循环条件，如果循环条件为true，则执行循环体代码，然后再判断循环条件，直到循环条件不成立时停止执行。如果首先判断循环条件就为false，则不执行循环体，直接执行while语句后续的代码。</p>
<p><strong>语法说明：</strong></p>
<ol>
<li>循环条件的类型为布尔类型，指循环成立的条件；</li>
<li><strong>花括号{}不是必须的，当循环体中只有一条语句时，可以省略；</strong></li>
<li>循环体是需要重复执行的代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line">  <span class="keyword">while</span>(布尔表达式②)&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程<br>　　执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<br>　　①负责完成循环变量初始化。<br>　　②负责判断是否满足循环条件，不满足则跳出循环。<br>　　③具体执行的语句。<br>　　④循环后，循环变量的变化情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">While_sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213401677.png" class="" title="image-20221005213401677">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">While_sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            x++;</span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213438605.png" class="" title="image-20221005213438605">



<p><strong>使用while语句计算1+2+3+…+10的和。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">While_Sum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1+2+...+10=&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213903586.png" class="" title="image-20221005213903586">



<p><strong>使用while语句计算从1到100的所有奇数相加。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">While_OddSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            	sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1到100之间的奇数和为&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214313314.png" class="" title="image-20221005214313314">



<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214421763.png" class="" title="image-20221005214421763">

<p><strong>语法说明：</strong></p>
<ol>
<li>循环体是重复执行的代码部分，循环条件要求是布尔类型，值为true时执行循环体，否则循环结束，最后整个语句以分号结束；</li>
<li>do-while语句是 “先循环再判断”的流程控制结构。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②);</span><br></pre></td></tr></table></figure>

<p>执行流程<br>　　执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。<br>　　①负责完成循环变量初始化。<br>　　②负责判断是否满足循环条件，不满足则跳出循环。<br>　　③具体执行的语句<br>　　④循环后，循环变量的变化情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoWhile_sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">            x++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(x&lt;<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214550405.png" class="" title="image-20221005214550405">





<p><strong>使用do-while语句计算从1到100的所有奇数相加。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoWhile_OddSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            	sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1到100之间的奇数和为&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214659459.png" class="" title="image-20221005214659459">





<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line">循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214747630.png" class="" title="image-20221005214747630">

<p><strong>for语句的代码执行过程为：</strong></p>
<ol>
<li>执行表达式1，实现初始化；</li>
<li>执行表达式2，判断循环条件是否成立，如果循环条件为false，则结束循环，否则执行下一步；</li>
<li>执行循环体；</li>
<li>执行表达式3，完成迭代；</li>
<li>跳转到步骤2重复执行。</li>
</ol>
<p><strong>语法说明：</strong></p>
<ol>
<li>表达式1用于初始化，一般书写变量初始化的代码，例如循环变量的声明、赋值等，它在for语句中执行且只执行一次。<strong>表达式1可以为空；</strong></li>
<li><strong>表达式2是循环条件，要求必须为布尔类型，如果该条件为空，则默认为true，即条件成立；</strong></li>
<li><strong>表达式3为迭代语句，</strong>是指循环变量变化的语句，一般书写i++、i–这样的结构。<strong>该语句可以为空。</strong></li>
<li>循环体指循环重复执行的功能代码。</li>
<li><strong>花括号{}不是必须的，当循环体部分只有一条语句时可以省略。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式①; 布尔表达式②; 步进表达式④)&#123;</span><br><span class="line">        循环体③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程<br>　　执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<br>　　①负责完成循环变量初始化<br>　　②负责判断是否满足循环条件，不满足则跳出循环<br>　　③具体执行的语句<br>　　④循环后，循环条件所涉及变量的变化情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For_Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;<span class="number">3</span>;x++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215107319.png" class="" title="image-20221005215107319">



<p><strong>用for循环改写从1到100的所有奇数相加的和。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For_OddSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1到100之间的奇数和为&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215151061.png" class="" title="image-20221005215151061">





<p><strong>注意：</strong></p>
<p>Java中的for：<br>for (int i &#x3D; 0;i &lt; 10;i++)<br>{ }<br><strong>注意，这里的i的作用域范围就是在for内部，出了for之外，看不到这个i。</strong>因为这里定义的i是在for的()中定义的i等同于如下</p>
<p>for(){</p>
<p>int i</p>
<p>}</p>
<p><strong>即等同于在for的{}大括号内部定义的i，属于局部变量。</strong></p>
<p><strong>{}表示代码块或者叫做语句块，属于局部范围，内部定义的变量属于局部变量。</strong></p>
<p>c中不是这样，c中这个i出了for仍然能够看到。</p>
<p>for 和 while 的小区别：<br>　　控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。<br>　　在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。</p>
<h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>如果循环条件永远为真，那么这样的循环就是死循环，一般情况下都要在代码中避免死循环的出现。</p>
<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215255185.png" class="" title="image-20221005215255185">

<p>for的条件部分为空，默认就是true。</p>
<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215313201.png" class="" title="image-20221005215313201">

<p>for(;;){}即可构成死循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfinitiveForExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;停不下来。。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p><strong>问题描述：在控制台中用星号”*”输出如下样式的图形</strong></p>
<p>***</p>
<p>***</p>
<p>***</p>
<p>当没有学习循环语句时，可以使用打印语句实现，实现方式如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiplication_Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>学习了循环之后可以实现如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiplication_Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用嵌套循环可以实现如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiplication_Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=<span class="number">3</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>控制台打印九九乘法表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiplicationTable1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.print(i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+i*j+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();<span class="comment">//换行</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215702671.png" class="" title="image-20221005215702671">



<h3 id="循环的中断"><a href="#循环的中断" class="headerlink" title="循环的中断"></a>循环的中断</h3><p>在使用循环语句时，只有循环条件表达式的值为false时，才能结束循环。有时，<strong>想提前中断循环</strong>，要实现这一点，只需要在循环语句块中添加break或continue语句。</p>
<p><strong>break</strong></p>
<p><strong>使用场景：终止switch或者循环</strong></p>
<p>​        <strong>在选择结构switch语句中</strong><br>　　<strong>在循环语句中</strong><br>　　<strong>离开使用场景的存在是没有意义的</strong></p>
<p>在前面switch语句的介绍中已经接触过break语句，其功能是中断switch语句的执行。</p>
<p>同样，在循环语句中，break语句的作用也是结束循环语句的执行。</p>
<ul>
<li>break语句用于终止某个语句块的执行。用在循环语句体中，可以强行退出循环。</li>
<li>break语句可以出现在while、do…while、for、switch语句体中。</li>
<li>break label语句可以出现在任何语句体中。</li>
</ul>
<p><strong>注意，break是跳出离它最近的这个循环，继续执行循环体后面的语句。如果break用在了Switch中，然后Switch外层嵌套了循环，那么break只是跳出Switch，不会跳出外层的循环的。</strong></p>
<p><strong>如果break想要跳出不是离它最近的循环，例如，跳出外层循环或者更外层的循环，那么此时就需要使用label标签了。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        if (b == true) &#123;</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1.查询余额，2.存款，3.取款，4.修改密码，5.退出&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">nub</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">switch</span> (nub) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        System.out.println(money);</span><br><span class="line">                        decide();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        money += setmoney(money);</span><br><span class="line">                        decide();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        money -= getmoney(money);</span><br><span class="line">                        decide();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> changePwd(password);</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前密码为&quot;</span> + str);</span><br><span class="line">                        decide();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                        System.out.println(<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">                        System.exit(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">&quot;非法操作&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>例如，这里的Switch外层套了while循环，Switch中使用了break，那么该break是跳出Switch，而不会跳出外层的while的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break_Sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i, sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">666</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;从1到&quot;</span> + i + <span class="string">&quot;的和为&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005220506855.png" class="" title="image-20221005220506855">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break_Sample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005220601014.png" class="" title="image-20221005220601014">





<p><strong>带标签的break</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break_Sample3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        label1: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> label1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005220731939.png" class="" title="image-20221005220731939">





<p><strong>continue</strong></p>
<p>continue语句虽然也完成循环的终止，但与break语句的区别在于：continue语句只跳出本次循环，但还要继续执行下一次循环；break语句则完全跳出它所在或所标记的循环。</p>
<p><strong>continue是跳过本次循环，继续执行下一次循环。因此，continue是不能够用于Switch中的，因为Switch本身就不是循环，所以，没有办法跳过本次循环的。</strong></p>
<p><strong>显示20以内的奇数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Continue_Sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005220939216.png" class="" title="image-20221005220939216">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Continue_Sample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            	<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码的执行结果为：</p>
<p>1</p>
<p>2</p>
<p>4</p>
<p>5</p>
<p><strong>带标签的continue</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Continue_Sample3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        label1: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.print(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> label1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005221058880.png" class="" title="image-20221005221058880">



<p>这样在执行continue语句时，就不再是终止内部循环中的本次循环，而是直接终止外部循环的本次循环，执行i++语句，进入下一次外部循环。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="水仙花"><a href="#水仙花" class="headerlink" title="水仙花"></a>水仙花</h3><p>水仙花数指一个特殊的三位数，它的各位数字的立方和与其自身相等。请输出所有的水仙花数。</p>
<p>思路：关键是将三位数的个位、十位和百位数字分别拆分出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Narcissus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &lt; <span class="number">1000</span>; i++) &#123; <span class="comment">// 循环所有三位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i % <span class="number">10</span>; <span class="comment">// 拆分出个位数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (i / <span class="number">10</span>) % <span class="number">10</span>; <span class="comment">// 拆分出十位数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> i / <span class="number">100</span>; <span class="comment">// 拆分出百位数字</span></span><br><span class="line">            <span class="comment">// 判断立方和是否等于自身</span></span><br><span class="line">            <span class="keyword">if</span> (a * a * a + b * b * b + c * c * c == i) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="求两个自然数的最大公约数"><a href="#求两个自然数的最大公约数" class="headerlink" title="求两个自然数的最大公约数"></a>求两个自然数的最大公约数</h3><p>最大公约数指两个数字公共的约数中最大的，例如数字3的约数有1、3，数字9的约数有1、3、9，则数字3和数字9的公共约数有1和3，其中3是最大的公约数。</p>
<p>思路：假设初始值从1开始逐步增1，每次把能同时使两个数整除的值都存储起来，那么最后一个存储起来的值就是最大的约数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonDivisor1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m % i == <span class="number">0</span>) &amp;&amp; (n % i == <span class="number">0</span>)) &#123;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第二种编程思路：设定初始值为两个数字中最小的数字，逐步减1，那么第一次得到的能同时使两个数整除的值就是最大公约数。</p>
<p>求9和12的最大公约数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonDivisor2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n &gt; m ? m : n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> result; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n % i == <span class="number">0</span>) &amp;&amp; (m % i == <span class="number">0</span>)) &#123;</span><br><span class="line">                result = i;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打印图形"><a href="#打印图形" class="headerlink" title="打印图形"></a>打印图形</h3><img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005221819644.png" class="" title="image-20221005221819644">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarPrint</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">1</span>; row &lt;= <span class="number">5</span>; row++) &#123; <span class="comment">// 外层循环执行换行</span></span><br><span class="line">            <span class="comment">// 打印空格的数量为5减去所在行数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">0</span>; c1 &lt; <span class="number">5</span> - row; c1++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印星号的数量为所在行数的2倍减1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">0</span>; c2 &lt; <span class="number">2</span> * row - <span class="number">1</span>; c2++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 换行</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="质数判断"><a href="#质数判断" class="headerlink" title="质数判断"></a>质数判断</h3><p>质数是只能被1和自身整除的自然数，也称素数，质数中最小的为2。所有自然数都可以被自身和1整除。</p>
<p>思路：我们只需判断一个数能否被1和自身以外的数字整除即可，大于其本身的自然数除外。若数字为n，则只需判断从2到n-1之间的所有数字，即程序只需判断该数能否被区间[2,n-1]内的某个自然数整除即可，若在区间内存在能被整除的数则说明不是质数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">29</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//布尔类型，表示是否为质数，初始值为真</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//若能够整除则不是质数</span></span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                b = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出结果，判断是否为质数</span></span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot;是质数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot;不是质数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>06-内存和数组</title>
    <url>/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="06-内存和数组"><a href="#06-内存和数组" class="headerlink" title="06-内存和数组"></a>06-内存和数组</h1><h2 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h2><p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程<br>序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。<br>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p>
<p>Java运行程序，会从OS来申请内存的。并不是将整个内存都给Java来使用。</p>
<p>Java内存主要分为5部分，目的是更加方便的管理。</p>
<h2 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h2><img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006101709722.png" class="" title="image-20221006101709722">

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006101752076.png" class="" title="image-20221006101752076">

<p>注意，方法区中存储的都是方法的代码等死的信息的，真正方法的运行是在栈中运行的。</p>
<p>另外，凡是在堆中创建的东西，都是有默认值的。如上。</p>
<p>数组的静态初始化虽然没有写new，但是，实际底层仍然是通过new来创建的，因此，仍然是放在堆中的。</p>
<p>上面说的栈，也叫做方法栈或者叫做方法调用栈。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006105359824.png" class="" title="image-20221006105359824">



<p>说明，当我们定义的类Student中有成员变量，这个成员变量可以是基本类型，也可以是引用类型，那么如果是基本类型的话，那么成员变量分配的内存空间就是在堆区中给对象分配的内存空间中进行分配，如果成员变量是引用类型，那么在堆区中给对象分配的内存空间中存放的就是地址了，也就是指向，那么指向的对象就是在堆区中另外的一个空间，然后当前堆区中的这个对象中存放的就是引用变量，指向另外的这个对象。</p>
<p>注意，静态方法存放的位置仍然是方法区中的对应的类的字节码中的位置。</p>
<p>另外对于String类型，new的时候，就是堆区中创建一个对象了，不会共享字符串常量池中的内容。实际上分为两步，如果new的String的字符串在字符串常量池中没有，那么首先就是在堆区中创建这个对象，然后再将这个字符串存放到字符串常量池中一份。如果new的这个字符串在字符串常量池中已经有了，那么它只会在堆区中创建这个字符串对象，不会再往字符串常量池中去添加了，因为已经有了。</p>
<p>可以看到，数组也是引用类型，不管通过new的方式，还是简化的方式进行的数组定义，它都是在堆区中创建一个对象的。然后栈区中变量指向它。</p>
<p>字符串常量池，在新版本jdk中，它放在了堆区中了。在老版本的jdk中，它是存放在代码区（方法区）中的。</p>
<h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p>数组概念：存储相同数据类型的多个元素的容器。</p>
<p>注意，多个元素的数据类型要相同。</p>
<p>注意，在java中数组也是一个对象。</p>
<h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><h3 id="方式一-动态初始化方式"><a href="#方式一-动态初始化方式" class="headerlink" title="方式一 动态初始化方式"></a>方式一 动态初始化方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组存储的数据类型[] 数组名字 = <span class="keyword">new</span> 数组存储的数据类型[长度];</span><br></pre></td></tr></table></figure>

<p>数组定义格式详解：<br>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。<br>[] : 表示数组。<br>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。<br>new：关键字，创建数组使用的关键字。<br>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。<br>[长度]：数组的长度，表示数组容器中可以存储多少个元素。<br><strong>注意：数组有定长特性，长度一旦指定，不可更改。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//此种定义方式可读性更好，表明arr变量，它的类型为int[]，即整形[]，整形数组</span></span><br><span class="line"><span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//类似c中的写法</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，不能int[5] arr或者int arr[5]这样定义，错误的。</strong></p>
<p><strong>注意，int []是类型。数组的类型。注意，不要int [4]这样，因为int []是类型，而真正开辟多大内存空间是在new后面来指定的。</strong></p>
<h3 id="方式二-静态初始化方式"><a href="#方式二-静态初始化方式" class="headerlink" title="方式二 静态初始化方式"></a>方式二 静态初始化方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意，int[] arr &#x3D; new int[4]{1,2,3,4};这样是错误的。</strong></p>
<p>这样是不对的，因为new int[] {}这样理解为调用int []类型的构造方法的意思。</p>
<p>另外，int [] b &#x3D;new int [2] {1,2,3,4}，这样在编译的时候编译器看不出错误的，只有在执行的时候，才会发现，因此，这种语法禁止。</p>
<h3 id="方式三-静态初始化方式-简化版"><a href="#方式三-静态初始化方式-简化版" class="headerlink" title="方式三 静态初始化方式-简化版"></a>方式三 静态初始化方式-简化版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>数组有默认值，对于数字类型，默认值为0，对于字符型，默认值为‘\u0000’，对于布尔类型，默认值为false, 对于对象类型（引用类型），默认值为null</strong></p>
<p><strong>类的成员变量，如果定义的时候，没有赋值，那么它是有一个默认值的。当生成对象的时候，成员变量就会有一个默认值。</strong></p>
<p>数组也是对象，当int[] a &#x3D;new int[4]，这样就生成了一个int类型的数组对象，那么这个元素就可以看成是对象的成员变量，也有默认值的。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006164345181.png" class="" title="image-20221006164345181">





<h2 id="数组访问"><a href="#数组访问" class="headerlink" title="数组访问"></a>数组访问</h2><p><strong>索引</strong></p>
<p>索引： 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名[索引]</span><br></pre></td></tr></table></figure>



<p><strong>长度属性</strong></p>
<p>数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度。</p>
<p>语句为： 数组名.length ，属性length的执行结果是数组的长度，<strong>int类型结果</strong>。由次可以推断出，数组的最大索引值为 数组名.length-1 。</p>
<p><strong>注意，数组长度属性是final的常量，不可修改的，只读的。</strong></p>
<p><strong>数组长度length属性是public final int的。</strong>Length属性是final的，意思就是常量。而且length属性是在数组生成的时候，构造方法的时候赋值的。是个常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//打印数组的属性，输出结果是5</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组名[索引]&#x3D;数值，为数组中的元素赋值</strong><br><strong>变量&#x3D;数组名[索引]，获取出数组中的元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//定义存储int类型数组，赋值元素1，2，3，4，5</span></span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//为0索引元素赋值为6</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//获取数组0索引上的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="comment">//直接输出数组0索引元素</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组内存结构图"><a href="#数组内存结构图" class="headerlink" title="数组内存结构图"></a>数组内存结构图</h2><p>数组声明后，Java虚拟机就会给数组分配存储空间</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006164132327.png" class="" title="image-20221006164132327">

<p>数组在声明后，但是没有创建前，并没有给它分配具体的内存空间，所以这个时候访问数组会出现NullPointerException异常。我们需要在访问数组前创建数组，确定数组的长度，以便能为数组分配内存空间。</p>
<p>可以看到，此时只是栈空间中有了变量，但是堆中并没有创建数组对象，因此，没有指向。</p>
<p><strong>数组是存储多个相同类型数据的对象。数组的所有元素保存在堆内存中。 创建一个数组就是在堆中创建一个数组对象。数组创建后所有元素立即拥有默认值。索引从0开始，连续分配</strong>。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006164534875.png" class="" title="image-20221006164534875">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr);<span class="comment">//[I@5f150435</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。</p>
<p>输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素。</p>
<p><strong>注意，如果数组是引用类型的数组，那么数组元素（堆中存放）中存放的是引用类型数据的内存地址。而该引用类型的实际数据仍然是在堆中的，数组中的元素指向它。</strong></p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006160427884.png" class="" title="image-20221006160427884">

<p>注意，在堆中的数据都是有出事默认值的。</p>
<p>定义两个数组内存结构图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">    System.out.println(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006160641814.png" class="" title="image-20221006160641814">





<p>两个变量指向一个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义数组，存储3个元素</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//数组索引进行赋值</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//输出3个索引上的元素值</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//定义数组变量arr2，将arr的地址赋值给arr2</span></span><br><span class="line">    <span class="type">int</span>[] arr2 = arr;</span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006160741403.png" class="" title="image-20221006160741403">

<p>注意，int类型的数组的数组元素初始值默认都是0（因为在堆区中，所以都有默认值），然后再进行赋值，将初始值覆盖。</p>
<h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><p><strong>数组遍历： 就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>数组的遍历还可以使用for each循环（增强型for循环）来做。</strong></p>
<p><strong>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素 : 数组或集合)&#123;  </span><br><span class="line"><span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;沉默王二&quot;</span>, <span class="string">&quot;一枚有趣的程序员&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">沉默王二</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>



<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="数组获取最大值元素"><a href="#数组获取最大值元素" class="headerlink" title="数组获取最大值元素"></a>数组获取最大值元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">2000</span>, <span class="number">10000</span>, <span class="number">100</span>, <span class="number">4000</span> &#125;;</span><br><span class="line">    <span class="comment">//定义变量，保存数组中0索引的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//遍历数组，取出每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="comment">//遍历到的元素和变量max比较</span></span><br><span class="line">      <span class="comment">//如果数组元素大于max</span></span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">        <span class="comment">//max记录住大值</span></span><br><span class="line">        max = arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组最大值是： &quot;</span> + max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      循环中定义变量min=0最小索引</span></span><br><span class="line"><span class="comment">      max=arr.length‐1最大索引</span></span><br><span class="line"><span class="comment">      min++,max‐‐</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐) &#123;</span><br><span class="line">      <span class="comment">//利用第三方变量完成数组中的元素交换</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[min];</span><br><span class="line">      arr[min] = arr[max];</span><br><span class="line">      arr[max] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转后，遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组最大值、最小值和平均值"><a href="#数组最大值、最小值和平均值" class="headerlink" title="数组最大值、最小值和平均值"></a>数组最大值、最小值和平均值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayMax</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">          <span class="type">int</span> a[] = &#123;<span class="number">1</span>,-<span class="number">12</span>,<span class="number">33</span>&#125;;</span><br><span class="line">          <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">          <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">          <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];        </span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">              sum = sum+a[i];</span><br><span class="line">              <span class="keyword">if</span>(a[i]&gt;max)&#123;</span><br><span class="line">                 max = a[i];</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(a[i]&lt;min)&#123;</span><br><span class="line">              	min = a[i];</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">double</span> <span class="variable">ave</span> <span class="operator">=</span> (<span class="type">double</span>)sum/<span class="number">3</span>;</span><br><span class="line">           System.out.println(<span class="string">&quot;平均值&quot;</span>+ave);</span><br><span class="line">           System.out.println(<span class="string">&quot;最大值&quot;</span>+max);</span><br><span class="line">           System.out.println(<span class="string">&quot;最小值&quot;</span>+min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006164810467.png" class="" title="image-20221006164810467">



<h3 id="数组应用例题"><a href="#数组应用例题" class="headerlink" title="数组应用例题"></a>数组应用例题</h3><p>假设队列中共有500人，每次从1开始数，数到3的人出队，下一个人接着从1开始数，编写程序找到最后剩下的人是哪一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Count3Quit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="comment">// 用布尔值来标识每个人是否出队 出队为false，未出队为true 并将每个人的初始值都赋为true</span></span><br><span class="line">       <span class="type">boolean</span> a[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">500</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">           a[i] = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">/*leftNum:未出队的人数 countNum:取值为1、2、3， 每次从1开始数，数到3的人出队，下一个人接着从1开始数</span></span><br><span class="line"><span class="comment">    index：数数的人的编号，取值范围0~500</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> a.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">countNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 循环数数，直到只剩下一个人，即leftNum的值为1</span></span><br><span class="line">       <span class="keyword">while</span> (leftNum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (a[index] == <span class="literal">true</span>) &#123;</span><br><span class="line">              countNum++;</span><br><span class="line">              <span class="keyword">if</span> (countNum == <span class="number">3</span>) &#123;</span><br><span class="line">                  countNum = <span class="number">0</span>;</span><br><span class="line">                  a[index] = <span class="literal">false</span>;</span><br><span class="line">                  leftNum--;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           index++;</span><br><span class="line">           <span class="comment">// 如果数到第500个人，index回0，又从第1个人开始数</span></span><br><span class="line">           <span class="keyword">if</span> (index == a.length) &#123;</span><br><span class="line">              index = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环遍历每个数数的人，找到值为true的并输出</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (a[i] == <span class="literal">true</span>)</span><br><span class="line">              System.out.println(<span class="string">&quot;最后剩下的人是第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;的人&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006165039136.png" class="" title="image-20221006165039136">







<h2 id="数组相关异常"><a href="#数组相关异常" class="headerlink" title="数组相关异常"></a>数组相关异常</h2><h3 id="数组越界异常"><a href="#数组越界异常" class="headerlink" title="数组越界异常"></a>数组越界异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行后，将会抛出 ArrayIndexOutOfBoundsException 数组越界异常。</p>
<h3 id="数组空指针异常"><a href="#数组空指针异常" class="headerlink" title="数组空指针异常"></a>数组空指针异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    arr = <span class="literal">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>运行的时候会抛出 NullPointerException 空指针异常。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006162933104.png" class="" title="image-20221006162933104">



<h2 id="数组作为方法参数和返回值"><a href="#数组作为方法参数和返回值" class="headerlink" title="数组作为方法参数和返回值"></a>数组作为方法参数和返回值</h2><h3 id="数组作为方法参数"><a href="#数组作为方法参数" class="headerlink" title="数组作为方法参数"></a>数组作为方法参数</h3><p>数组作为方法参数传递，传递的参数是数组内存的地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">//调用方法，传递数组</span></span><br><span class="line">    printArray(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建方法，方法接收数组类型的参数</span></span><br><span class="line"><span class="comment">    进行数组的遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006163106571.png" class="" title="image-20221006163106571">



<h3 id="数组作为方法返回值"><a href="#数组作为方法返回值" class="headerlink" title="数组作为方法返回值"></a>数组作为方法返回值</h3><p>数组作为方法的返回值，返回的是数组的内存地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//调用方法，接收数组的返回值</span></span><br><span class="line">    <span class="comment">//接收到的是数组的内存地址</span></span><br><span class="line">    <span class="type">int</span>[] arr = getArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建方法，返回值是数组类型</span></span><br><span class="line"><span class="comment">    return返回数组的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getArray() &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">//返回数组的地址，返回到调用者</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006163240822.png" class="" title="image-20221006163240822">



<h3 id="方法传递参数时参数类型区别"><a href="#方法传递参数时参数类型区别" class="headerlink" title="方法传递参数时参数类型区别"></a>方法传递参数时参数类型区别</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    change(a, b);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = b + a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值，实际上传递的仍然是变量的值，只是这个值是地址而已。因此，在java中实际上只有一种传值方式，就是传值，只是这个值可以是普通的基本数据类型的值，也可以是引用类型变量的值（地址值）。</p>
<h2 id="数组排序与查找"><a href="#数组排序与查找" class="headerlink" title="数组排序与查找"></a>数组排序与查找</h2><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><strong>冒泡排序（BubbleSort）</strong>的基本概念是：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。冒泡排序流程至此第一趟结束，将最大的数放到了最后。</p>
<p>在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006165740950.png" class="" title="image-20221006165740950">

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006165801694.png" class="" title="image-20221006165801694">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array_BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  趟i:  1,2,3,... arr.length-1</span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 *  每趟次数 j：   i=1  j=5(0,1,2,3,4)</span></span><br><span class="line"><span class="comment">		 *           i=2  j=4(0,1,2,3)</span></span><br><span class="line"><span class="comment">		 *           i=3  j=3</span></span><br><span class="line"><span class="comment">		 *           </span></span><br><span class="line"><span class="comment">		 *                j=arr.length-i-1</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)<span class="comment">//趟</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-i;j++)<span class="comment">//次</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//交换位置</span></span><br><span class="line">					<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">					arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">//打印数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组元素查找"><a href="#数组元素查找" class="headerlink" title="数组元素查找"></a>数组元素查找</h3><p>二分查找的前提是需要查找的<strong>数组必须是已排序的</strong>，这里实现默认前提为升序。</p>
<p>查找时将数组分为三部分，依次是<strong>中值（所谓的中值就是数组中间位置的那个值）前，中值，中值后</strong>；将要查找的值和数组中的值进行比较，若小于中值则在中值前面找，若大于中值则在中值后面找，等于中值时直接返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                   <span class="type">int</span>[] sort = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">// 需要查找的值</span></span><br><span class="line">                   <span class="type">int</span> <span class="variable">locale</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// 记录 查找位置的变量</span></span><br><span class="line">                   <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> sort.length - <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">while</span> (high &gt;= low) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> (key &lt; sort[mid])</span><br><span class="line">                                     high = mid - <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (key == sort[mid]) &#123;</span><br><span class="line">                                     locale = mid;</span><br><span class="line">                                     <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span></span><br><span class="line">                                     low = mid + <span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (locale == -<span class="number">1</span>)</span><br><span class="line">                            System.out.println(<span class="string">&quot;数组中不存在元素&quot;</span> + key);</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;元素&quot;</span> + key + <span class="string">&quot;在数组中的下标是&quot;</span> + locale);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006170757245.png" class="" title="image-20221006170757245">





<h2 id="数组操作（使用工具类）"><a href="#数组操作（使用工具类）" class="headerlink" title="数组操作（使用工具类）"></a>数组操作（使用工具类）</h2><h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><p>使用System.arraycopy。</p>
<p> System.arraycopy(source,srcPos,dest,destPos,length)</p>
<p>复制source数组中从下标srcPos开始的length个元素到目标数组dest，并从目标数组的下标为destPos的位置开始储存 ，其中各个参数的含义如下：</p>
<p>@source： 源数组  </p>
<p>@srcPos： 源数组中的起始位置 </p>
<p>@dest： 目标数组 </p>
<p>@destPos：目标数组中的起始位置 </p>
<p>@length： 要复制的数组元素的个数</p>
<p><strong>复制数组{1,2,3,4,5}中从下标0开始的5个元素到目标数组{6,7,8,9,10,11,12,13,14,15}，并从目标数组的下标为0的位置开始储存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array_copy</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">                   <span class="type">int</span> aa[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">                   <span class="type">int</span> bb[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;;</span><br><span class="line">                   System.arraycopy(aa, <span class="number">0</span>, bb, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; aa.length; i++) &#123;</span><br><span class="line">                            System.out.print(aa[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println();</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bb.length; j++) &#123;</span><br><span class="line">                            System.out.print(bb[j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006171052217.png" class="" title="image-20221006171052217">





<h3 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h3><p>Arrays.sort(数组名)为数组排序的操作。但这个方法在 java.util 这个包里面,所以在用到的时候需要先将它导入。<br>Arrays.sort方法有两种常用方式，具体参数如下：<br>Arrays.sort(arr_name)<br>Arrays.sort(arr_name,fromIndex,toIndex)</p>
<p>arr_name：数组名称<br>fromIndex：排序的起始下标<br>toIndex：排序的终止下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArraySort_sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span>[ ] point = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        Arrays.sort(point);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;point.length;i++)&#123;</span><br><span class="line">            System.out.print(point[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006171303036.png" class="" title="image-20221006171303036">





<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>如果一维数组中的每一个元素也是一个数组，那么就是二维数组。以此类推，还可以有多维数组。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006172904195.png" class="" title="image-20221006172904195">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//给二维数组赋值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num[i].length;j++)&#123;</span><br><span class="line">        num[i][j] = i+j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num[i].length;j++)&#123;</span><br><span class="line">        System.out.print(num[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意，二维数组在内存中存储的时候是线性存储的，不是表的形式的。因为内存本身就是线性的。<strong>内存一个字节（8bit）就是一个单元</strong>，然后一个单元一个单元挨着的，因此是线性的。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006173144733.png" class="" title="image-20221006173144733">



<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006173649284.png" class="" title="image-20221006173649284">

<p>注意，数组名代表了数组首地址，因此，一维数组，那么数组名就是数组首地址，也就是arr[0]的地址。</p>
<p>二维数组，就是数组的数组，也就是每个元素本身又是一个一维数组。</p>
<p>如上，arr二维数组，首先看成是一维数组，元素为arr[0]，arr[1]，arr[2]，然后每个元素arr[0]，它本身又是一个一维数组，因此，arr[0]就表示了这个一维数组了，它就是这个一维数组的数组名了，表示首地址，因此，arr[0]就是一维数组的首地址，也就是arr[0][0]的地址，这里将arr[0]看成是一个整体即容易理解。</p>
<p>因此，arr表示整体二维数组首地址，维度是整个二维数组长度。而arr[0]是一维数组的首地址，维度是一维数组的长度。arr和arr[0]的值都是arr[0][0]元素的地址。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006174322577.png" class="" title="image-20221006174322577">



<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006174504273.png" class="" title="image-20221006174504273">

<p>实际内存中是线性存储的。</p>
<p><strong>注意，java中可以定义列数不等的二维数组。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>&#125;, &#123;<span class="number">9</span>&#125;&#125;; <span class="comment">//注意，此时不能指定任何维度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];<span class="comment">//注意，可以这样定义，此时不能使用&#123;&#125;来给定初值，需要通过循环依次给每个元素赋值，此时列数没有指定，那么可以定义列数不等的二维数组了。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		    <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;&#125;; </span><br><span class="line">		    System.out.println(arr);</span><br><span class="line">		    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">		    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">		    System.out.println(arr[<span class="number">2</span>]); </span><br><span class="line">		    System.out.println(arr[<span class="number">3</span>]); </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[I@6815ee24</span><br><span class="line">[I@77c5b2de</span><br><span class="line">[I@54624a40</span><br><span class="line">[I@f8db08</span><br><span class="line">[I@51f3eab7</span><br></pre></td></tr></table></figure>

<p>@:分隔符<br>6815ee24：十六进制内存地址<br>I：int 数组中存储的数据类型<br>[[： 几个中括号就代表几维数组</p>
<p><strong>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</strong></p>
<p>通过实验可以看到，java中二维数组不是线性存储的。而是以对象方式存储的。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006180131239.png" class="" title="image-20221006180131239">

<p>即如图，rating引用变量指向了一个一维数组对象，然后一维数组中每个元素又是一个引用变量指向了另一个一维数组对象。</p>
<p>C++中二维数组是连续存放的，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_arr</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> array[<span class="number">2</span>][<span class="number">3</span>] = &#123; </span><br><span class="line">  &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, </span><br><span class="line">  &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; </span><br><span class="line">    &#125;; </span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">test_arr</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffee4065820 0x7ffee4065824 0x7ffee4065828 </span><br><span class="line">0x7ffee406582c 0x7ffee4065830 0x7ffee4065834 </span><br></pre></td></tr></table></figure>

<p>注意地址为16进制，可以看出二维数组地址是连续一条线的。</p>
<p>一些录友可能看不懂内存地址，我就简单介绍一下， 0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相信数组元素地址差4个字节。</p>
<p>0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 &#x3D; c，c就是12。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006180435570.png" class="" title="image-20221006180435570">

<p>可以看出在C++中二维数组在地址空间上是连续的。</p>
<p>像Java，Python是没有指针的，同时也不对程序员暴漏其元素的地址，寻址操作完全交给虚拟机。</p>
<p>不同编程语言的数据结构在地址中的分布方式是不一样的，C++中我们是可以直接获取元素的地址，通过实验，我们也证实了二维数组的元素确实是相邻的。</p>
<p>在其他语言中，并没有指针，也获取不到每个元素的地址，以Java为例，通过实验可以推测可能Java里的二维数组是不相邻的。</p>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><h3 id="查找二维整型数组中的最大数及其位置。"><a href="#查找二维整型数组中的最大数及其位置。" class="headerlink" title="查找二维整型数组中的最大数及其位置。"></a>查找二维整型数组中的最大数及其位置。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulArrayMax2</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">                   <span class="type">int</span> array[][] = &#123; &#123; <span class="number">23</span>, <span class="number">2</span>, <span class="number">64</span>, <span class="number">16</span> &#125;, &#123; <span class="number">35</span>, <span class="number">56</span>, <span class="number">97</span>, <span class="number">28</span> &#125;,&#123; <span class="number">29</span>, <span class="number">10</span>, <span class="number">81</span>, <span class="number">12</span> &#125; &#125;;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">                                     <span class="keyword">if</span> (array[i][j] &gt; max) &#123;</span><br><span class="line">                                               max = array[i][j];</span><br><span class="line">                                               x = i + <span class="number">1</span>;</span><br><span class="line">                                               y = j + <span class="number">1</span>;</span><br><span class="line">                                    &#125;   </span><br><span class="line">                            &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println(<span class="string">&quot;该二维数组中最大值是:&quot;</span> + max);</span><br><span class="line">                   System.out.println(<span class="string">&quot;位置是第&quot;</span> + x + <span class="string">&quot;行，第&quot;</span> + y + <span class="string">&quot;列&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006181230809.png" class="" title="image-20221006181230809">





<h3 id="求最高分和学号。"><a href="#求最高分和学号。" class="headerlink" title="求最高分和学号。"></a>求最高分和学号。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 求最高分及对应的学号</span></span><br><span class="line">		<span class="type">int</span>[][] scores= &#123;&#123;<span class="number">10</span>,<span class="number">88</span>&#125;,&#123;<span class="number">20</span>,<span class="number">98</span>&#125;,&#123;<span class="number">30</span>,<span class="number">89</span>&#125;,&#123;<span class="number">40</span>,<span class="number">66</span>&#125;,&#123;<span class="number">50</span>,<span class="number">77</span>&#125;&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> scores[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> scores[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;scores.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(scores[i][<span class="number">1</span>]&gt;max)</span><br><span class="line">        	&#123;</span><br><span class="line">        		max=scores[i][<span class="number">1</span>];</span><br><span class="line">        		no=scores[i][<span class="number">0</span>];      		</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(max);</span><br><span class="line">        System.out.println(no);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>08-类、对象、封装、匿名对象</title>
    <url>/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="08-类、对象、封装、匿名对象"><a href="#08-类、对象、封装、匿名对象" class="headerlink" title="08-类、对象、封装、匿名对象"></a>08-类、对象、封装、匿名对象</h1><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p><strong>类：</strong>是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该<br>类事物。</p>
<p>现实中，描述一类事物：</p>
<p>属性：就是该事物的状态信息。</p>
<p>行为：就是该事物能够做什么。</p>
<p>举例：小猫。</p>
<p>属性：名字、体重、年龄、颜色。 行为：走、跑、叫。</p>
<p><strong>对象：</strong>是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性<br>和行为。对象即是某类事物的具体表现。</p>
<p>举例：一只小猫。</p>
<p>属性：tom、5kg、2 years、yellow。 行为：溜墙根走、蹦跶的跑、喵喵叫。</p>
<p><strong>类与对象的关系</strong></p>
<p>类是对一类事物的描述，是抽象的。</p>
<p>对象是一类事物的实例，是具体的。</p>
<p>类是对象的模板，对象是类的实体。</p>
<p><strong>事物与类的对比</strong></p>
<p>现实世界的一类事物：</p>
<p>属性：事物的状态信息。 </p>
<p>行为：事物能够做什么。</p>
<p>Java中用class描述事物也是如此：</p>
<p>成员变量：对应事物的属性</p>
<p>成员方法：对应事物的行为</p>
<p>java面向对象的语言</p>
<p>对象：真实存在唯一的事物。</p>
<p>类： 实际就是对某种类型事物的共性属性与行为的抽取。  抽象的概念….   车</p>
<p>我们从小的时候就不断的接触很多的对象，我们的大脑就会把这些具备相同属性与行为的事物进行分类。</p>
<p>在现实生活中就存在对象与类这两种事物。计算机是服务于人类，为了让计算机更加接近我们的生活，这时候就出现了面向对象的计算机语言。</p>
<p><strong>面向过程（C）                  面向对象（java）</strong></p>
<p>现实生活中 : 对象———&gt;类</p>
<p>在java中： 类————&gt;对象</p>
<p>面向对象的计算机语言核心思想： 找适合的对象做适合的事情。</p>
<p>如何找适合的对象：</p>
<pre><code>1. sun已经定义好了很多的类，我们只需要认识这些类，我们就可以通过这些类创建对象使用。 
1. 自定义类，通过自定义类来创建对象使用。
</code></pre>
<p><strong>类和对象的关系</strong></p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007231021744.png" class="" title="image-20221007231021744">





<p><strong>面向对象与面向过程</strong></p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007231047646.png" class="" title="image-20221007231047646">



<h2 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h2><p>在Java里的类分为两种：系统类和自定义类。</p>
<p>系统类就是Java自带的标准类，安装JDK后，在lib目录下，就保存了一些基本的类库，还有一些可以从网上下载。比如前面接触过的</p>
<p>System，String，BufferReader等，都是系统类。</p>
<p>自定义类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">public</span>][<span class="keyword">abstract</span>|<span class="keyword">final</span>]class 类名[extends父类][implements接口列表]</span><br><span class="line">&#123;  </span><br><span class="line">      属性声明及初始化；</span><br><span class="line">      方法声明及方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class之前出现了多个修饰符，这里的修饰符的作用是用来限定类的使用方式。其中：</p>
<p>public：表明此类为公有类</p>
<p>abstract：指明此类为抽象类</p>
<p>final：指明此类为终结类</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">自定义类创建对象的三步骤：</span><br><span class="line">	1. 自定义类。</span><br><span class="line">			格式：</span><br><span class="line">				class 类名&#123;</span><br><span class="line">					</span><br><span class="line">					事物的公共属性使用成员变量描述。</span><br><span class="line">					</span><br><span class="line">					事物的公共行为使用函数描述。</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">	2. 通过自定义类创建对象。</span><br><span class="line">			格式： </span><br><span class="line">				类名 变量名 =  new 类名();</span><br><span class="line">			</span><br><span class="line">	3. 访问(设置)对象的属性或者调用对象的功能。</span><br><span class="line">		1.访问对象属性的格式：</span><br><span class="line">			对象.属性名.</span><br><span class="line">		2.设置对象的属性：</span><br><span class="line">			对象.属性名 = 数据。</span><br><span class="line">		3. 调用对象的功能</span><br><span class="line">			对象.函数名();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//成员方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义类：就是定义类的成员，包括成员变量和成员方法。</p>
<p>成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。<strong>在类中，方法外。</strong></p>
<p>成员方法：和以前定义方法几乎是一样的。只不过把static去掉，static的作用在面向对象后面再详细说明。</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008112725794.png" class="" title="image-20221008112725794">





<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//事物的公共属性使用成员变量描述。</span></span><br><span class="line">	String	name; <span class="comment">//名字的属性</span></span><br><span class="line"></span><br><span class="line">	String	color; <span class="comment">//颜色属性</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> wheel;	<span class="comment">//轮子数</span></span><br><span class="line">					</span><br><span class="line">	<span class="comment">//事物的公共行为使用函数描述。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;飞快的跑起来啦...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo1</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//使用了Car类声明了一c变量， c变量指向了一个车对象。</span></span><br><span class="line"><span class="comment">		Car	c = new Car(); </span></span><br><span class="line"><span class="comment">		//设置车对象的属性值。</span></span><br><span class="line"><span class="comment">		c.name = &quot;BMW&quot;;</span></span><br><span class="line"><span class="comment">		c.color = &quot;白色&quot;;</span></span><br><span class="line"><span class="comment">		c.wheel = 4;</span></span><br><span class="line"><span class="comment">		//访问车对象的属性值</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;名字：&quot;+ c.name+&quot; 颜色:&quot;+ c.color+&quot; 轮子数：&quot;+c.wheel);</span></span><br><span class="line"><span class="comment">		c.run();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Car</span>	<span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(); </span><br><span class="line">		c1.name = <span class="string">&quot;宝马&quot;</span>;</span><br><span class="line">		<span class="type">Car</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">		c2.name = <span class="string">&quot;大众&quot;</span>;</span><br><span class="line">		c1 = c2; </span><br><span class="line">		System.out.println(<span class="string">&quot;名字：&quot;</span>+ c1.name);  <span class="comment">//大众  大众 \大众</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007230723802.png" class="" title="image-20221007230723802">





<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007230846662.png" class="" title="image-20221007230846662">



<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007230908919.png" class="" title="image-20221007230908919">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求： 使用java描述一个车与修车厂两个事物， 车具备的公共属性:轮子数、 名字、 颜色 ，还</span></span><br><span class="line"><span class="comment">具备跑的功能行为。跑之前要检测轮子是否少于了4个，如果少于了4个，那么要送到修车厂修理，</span></span><br><span class="line"><span class="comment">修车厂修理之后，车的轮子数要补回来4个。 然后车就继续的跑起来。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修车厂： 具备公共属性： 名字、 地址、 电话。</span></span><br><span class="line"><span class="comment">		 公共的行为： 修车。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">初学者的经典错误：</span></span><br><span class="line"><span class="comment">	1. 变量在同一个作用域(大括号)上是可以直接访问的。</span></span><br><span class="line"><span class="comment">	2. 如果一个类要访问另外一个类变量时，那么这时候就只能通过创建对象进行访问。（仅对于目前正确）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//事物的公共属性使用成员变量描述	</span></span><br><span class="line">	String name ; <span class="comment">// 名字</span></span><br><span class="line"></span><br><span class="line">	String color; <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> wheel; <span class="comment">//轮子数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//事物的公共行为使用函数描述</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(wheel&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">			System.out.println(name+wheel+<span class="string">&quot;个轮子飞快跑起来..&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(name+<span class="string">&quot;不够4个轮子了，赶快去修理&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修车厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name;<span class="comment">//名字</span></span><br><span class="line">	</span><br><span class="line">	String address ;	<span class="comment">//地址</span></span><br><span class="line">	</span><br><span class="line">	String tel;	<span class="comment">//电话</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//修车公共行为 ------ 返回值类型、 未知的参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repair</span><span class="params">(Car c)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(c.wheel&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;告诉你，费了很大力气修好了，给钱&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			c.wheel = <span class="number">4</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;修好了，给钱!!&quot;</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//0x98</span></span><br><span class="line"><span class="comment">		Car c = new Car();</span></span><br><span class="line"><span class="comment">		//给车对象赋予属性值</span></span><br><span class="line"><span class="comment">		c.name = &quot;陆丰&quot;;</span></span><br><span class="line"><span class="comment">		c.color = &quot;黑色&quot;;</span></span><br><span class="line"><span class="comment">		c.wheel = 4;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		for(int i = 0 ; i&lt;100 ; i++)&#123;</span></span><br><span class="line"><span class="comment">			c.run();</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		c.wheel = 3;</span></span><br><span class="line"><span class="comment">		c.run();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//创建修车厂对象</span></span><br><span class="line"><span class="comment">		CarFactory f = new CarFactory();</span></span><br><span class="line"><span class="comment">		//给修车厂赋予属性值</span></span><br><span class="line"><span class="comment">		f.name = &quot;集群宝修车厂&quot;;</span></span><br><span class="line"><span class="comment">		f.address = &quot;韵泰商业广场一楼&quot;;</span></span><br><span class="line"><span class="comment">		f.tel = &quot;020-1234567&quot;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//调用修车的修车</span></span><br><span class="line"><span class="comment">		f.repair(c);//0x98</span></span><br><span class="line"><span class="comment">		//</span></span><br><span class="line"><span class="comment">		c.run();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//需求： 调用一次repair方法。  前提： 该对象调用完一个方法之后，这个对象就不再使用了。</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>提示：类实际上是一种数据类型，叫做对象类型。类是Java中最小的单元。一切操作都需要定义在类中。</strong></p>
<h2 id="对象（实例）的使用"><a href="#对象（实例）的使用" class="headerlink" title="对象（实例）的使用"></a>对象（实例）的使用</h2><p>类是创建对象的模板，对象是类的实例</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008112848885.png" class="" title="image-20221008112848885">

<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008112919675-1665199761324-1.png" class="" title="image-20221008112919675">



<p>创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>

<p>使用对象访问类中的成员:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.成员变量；</span><br><span class="line">对象名.成员方法()；</span><br></pre></td></tr></table></figure>



<p>定义一个类后，就可以定义对象了，首先要声明对象，<strong>声明对象</strong>的语法结构如下</p>
<p>类名 对象名;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee  e1;</span><br></pre></td></tr></table></figure>

<p><strong>对象的声明并没有创建对象，这只是声明了一个引用变量。并没有真正的去创建对象呢。</strong></p>
<p><strong>注意，该引用变量也是在栈区的，并且此时是null（栈区没有初始化，是随机值，是不能直接使用的）。</strong></p>
<p><strong>当然如果它本身又是另外一个类的成员变量，那么它就是在堆区中了。并且初始值是null。</strong></p>
<p>但是创建一个基本数据类型的变量如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  i ;</span><br></pre></td></tr></table></figure>

<p><strong>这条语句创建了一个变量并为该变量i分配了适当的内存空间。</strong>i变量是在栈区中的。如果是成员变量，那么就在堆区中。</p>
<ol>
<li><p>创建对象 要为对象分配内存空间，还需要创建对象，这时就要使用new关键字，创建对象的语法结构如下：</p>
<p>对象名 &#x3D; new 构造方法名(参数列表); 例如： e1&#x3D; new Employee(); 或者 e2&#x3D;new Employee(“小明”,29,3000);</p>
</li>
<li><p>声明并创建对象 对象的声明和创建可以一步完成</p>
</li>
</ol>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008173623028.png" class="" title="image-20221008173623028">



<ul>
<li><ul>
<li>栈stack：栈的存取速度比堆快，效率高。在栈内保存基本数据类型的局部变量和对象的引用值（地址值）。</li>
<li>堆heap：堆可以保存那些对空间要求较大的变量。如对象的属性和数组的元素。在堆内存中开辟空间，只能通过内存分配操作符号new，凡是出现关键字new的地方必定分配了一个堆内存。</li>
<li>我们在实例化一个对象时，同时操作了栈内存和堆内存。在栈内保存对象的首地址，即引用；在堆内存中保存了对象的属性。对对象的所有操作只能通过引用完成，一旦引用变量出栈就会被释放，没有任何引用指向该对象，对象就变成垃圾失效。</li>
</ul>
</li>
</ul>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008174027445.png" class="" title="image-20221008174027445">

<p>8种基本类型之外，都是引用类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01_Student</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建对象格式：类名 对象名 = new 类名();</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;s:&quot;</span>+s); <span class="comment">//cn.itcast.Student@100363</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//直接输出成员变量值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span>+s.name); <span class="comment">//null</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年龄：&quot;</span>+s.age); <span class="comment">//0</span></span><br><span class="line">    System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//给成员变量赋值</span></span><br><span class="line">    s.name = <span class="string">&quot;赵丽颖&quot;</span>;</span><br><span class="line">    s.age = <span class="number">18</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//再次输出成员变量的值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span>+s.name); <span class="comment">//赵丽颖</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年龄：&quot;</span>+s.age); <span class="comment">//18</span></span><br><span class="line">    System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用成员方法</span></span><br><span class="line">    s.study(); <span class="comment">// &quot;好好学习，天天向上&quot;</span></span><br><span class="line">    s.eat(); <span class="comment">// &quot;学习饿了要吃饭&quot;</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>成员变量默认值</strong></p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007231616432.png" class="" title="image-20221007231616432">

<p><strong>定义成员变量，如果没有给定初始值，那么编译器将会赋予默认值。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义手机类：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">  <span class="comment">// 成员变量</span></span><br><span class="line">  String brand; <span class="comment">//品牌</span></span><br><span class="line">  <span class="type">int</span> price; <span class="comment">//价格</span></span><br><span class="line">  String color; <span class="comment">//颜色</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="comment">//打电话</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;给&quot;</span>+name+<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//发短信</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;群发短信&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义测试类：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02Phone</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//输出成员变量值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;品牌：&quot;</span>+p.brand);<span class="comment">//null</span></span><br><span class="line">    System.out.println(<span class="string">&quot;价格：&quot;</span>+p.price);<span class="comment">//0</span></span><br><span class="line">    System.out.println(<span class="string">&quot;颜色：&quot;</span>+p.color);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">    <span class="comment">//给成员变量赋值</span></span><br><span class="line">    p.brand = <span class="string">&quot;锤子&quot;</span>;</span><br><span class="line">    p.price = <span class="number">2999</span>;</span><br><span class="line">    p.color = <span class="string">&quot;棕色&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//再次输出成员变量值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;品牌：&quot;</span>+p.brand);<span class="comment">//锤子</span></span><br><span class="line">    System.out.println(<span class="string">&quot;价格：&quot;</span>+p.price);<span class="comment">//2999</span></span><br><span class="line">    System.out.println(<span class="string">&quot;颜色：&quot;</span>+p.color);<span class="comment">//棕色</span></span><br><span class="line">    System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用成员方法</span></span><br><span class="line">    p.call(<span class="string">&quot;紫霞&quot;</span>);</span><br><span class="line">    p.sendMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一个对象调用一个成员方法的内存结构图"><a href="#一个对象调用一个成员方法的内存结构图" class="headerlink" title="一个对象调用一个成员方法的内存结构图"></a>一个对象调用一个成员方法的内存结构图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007231930014.png" class="" title="image-20221007231930014">

<p><strong>注意，Java中的成员方法是多个对象共用的</strong>，可以理解成类似C++中的成员方法，编译之后，成为全局的方法，xx对象.yy(a,b,c)，这样调用的时候，转换为yy(xx对象,,a,b,c)，即将当前对象作为第一个隐含参数传入给yy方法内部的this引用变量，this的类型就是当前对象，xx对象的类型。因此，这个成员方法yy实际上编译之后就变成了一个在代码区中的一个全局方法了（所属类的内部的一个全局方法了），这个方法yy所属类的任何一个对象都可以调用它。</p>
<p><strong>说明：</strong></p>
<p>方法区中存放了.class文件的相关代码信息，注意，只是死的代码信息而已，真正方法的运行是要在栈中进行的。</p>
<p>首先运行，java DemoPhoneOne，JVM会找到DemoPhoneOne这个名字的class文件，即DemoPhoneOne.class，然后将其加载入代码区（方法区）中，然后解开，找到里面的类DemoPhoneOne，然后从static main作为入口运行main方法，此时main方法进入栈底部。</p>
<p><strong>Phone one，此时会在main方法调用栈中创建引用变量。此时该引用变量的值为null。</strong></p>
<p>new Phone()，创建对象，此时会在堆中创建该对象的内存空间，那么如何知道Phone这个类中有什么内容呢？需要到方法区中查看到该Phone类信息，从而知道创建的对象中都有哪些内容。因此，此时首先就在堆区中根据成员变量的类型以及个数，为对象分配对应的内存空间（注意，堆中的对象只有成员变量的部分，而不包含成员方法的）。对象空间分配之后，在堆中Phone的对象空间中创建了成员变量，并且赋予默认值，分别为，String brand为null，double price为0.0，String color为null。注意，这些都是在构造方法之前做的事，此时还没有调用构造方法呢。</p>
<p><strong>关于构造代码块，构造方法，以及显示初始化成员变量，它们的执行顺序，下节说明。</strong></p>
<p>接下来就是成员方法，对于成员方法来说，堆中Phone的对象空间中只存储了该成员方法在方法区中的地址值。因此，指向了方法区中的方法代码的地址。</p>
<p>对象构造完毕，返回对象在堆中的地址，赋值给one引用变量。</p>
<p>到此，对象构造出来。</p>
<p>接下来，3次out，输出默认值。</p>
<p>接下来，3次分别给成员变量赋值，同理，将方法区中Demo01PhoneOne.class中的main中的代码依次拿到栈中main的方法调用栈中来执行。通过one依次找到了堆中的对象，然后定位到对象中的成员变量，然后将成员变量赋值。</p>
<p>接下来，3次out，输出成员变量值。</p>
<p>接下来，one.call方法的调用，通过栈中的one找到堆中的对象，然后定位到堆中对象的存储的成员方法的地址值，然后定位到方法区中Phone.class中的的call方法代码，然后将其代码依次拿到栈中来运行，即进栈操作。注意，此时调用call方法，实际会转换为call(one)这样调用，将对象one作为第一个隐含参数传给call方法内部的this引用变量。此时栈中call在main的上方，此时开始运行call方法。当call方法运行结束之后，栈中call占据内存空间即释放销毁，因此，call的局部变量空间就会释放掉。重新回到栈中main方法中接着运行。</p>
<p><strong>注意，实际上这里是根据one变量的类型从而知道去代码区中那个类的字节码中找对应的要调用的那个全局call方法的。</strong></p>
<p><strong>对于多态的情况，也是如此，指向某个对象，那么就是运行期间知道该对象的对应的类型，从而找代码区中该类型字节码中那个要调用的全局方法的。</strong></p>
<p>接下来，one.sendMessage方法的调用，同理操作。</p>
<p>最后，当main方法运行结束之后，栈中，main方法占据的内存空间也会释放销毁。</p>
<p><strong>注意，所有的方法的运行，都是在栈中运行的，也叫做方法调用栈。</strong></p>
<p>方法区中存放的都是.class字节码中类的相关信息以及方法的相关信息，都是死的信息，运行不发生在方法区中。</p>
<p>在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量one指向堆内存中的空间，寻找方法信息，去执行该方法。</p>
<h3 id="两个对象使用同一个方法的内存结构图"><a href="#两个对象使用同一个方法的内存结构图" class="headerlink" title="两个对象使用同一个方法的内存结构图"></a>两个对象使用同一个方法的内存结构图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008092935662.png" class="" title="image-20221008092935662">



<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008093023599.png" class="" title="image-20221008093023599">

<p>实际上调用方法的时候，p.sendMessage()，首先是根据p引用变量的类型，知道它是Phone类型，因此，就到方法区的对应的Phone的class部分进行搜寻，找到了sendMessage方法，然后进行调用，sendMessage(p)，将p作为第一个隐藏参数传入。</p>
<p><strong>因此，成员方法，对于该类的所有对象来说，它就是一个全局的方法了。</strong></p>
<p>对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。</p>
<h3 id="两个引用指向同一个对象的内存结构图"><a href="#两个引用指向同一个对象的内存结构图" class="headerlink" title="两个引用指向同一个对象的内存结构图"></a>两个引用指向同一个对象的内存结构图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008093953689.png" class="" title="image-20221008093953689">



<h3 id="使用对象类型作为方法的参数的内存结构图"><a href="#使用对象类型作为方法的参数的内存结构图" class="headerlink" title="使用对象类型作为方法的参数的内存结构图"></a>使用对象类型作为方法的参数的内存结构图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008094039732.png" class="" title="image-20221008094039732">



<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008094238926.png" class="" title="image-20221008094238926">

<p><strong>引用类型作为参数，传递的值实际上是地址值。</strong></p>
<h3 id="使用对象类型作为方法的返回值的内存图"><a href="#使用对象类型作为方法的返回值的内存图" class="headerlink" title="使用对象类型作为方法的返回值的内存图"></a>使用对象类型作为方法的返回值的内存图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008094359863.png" class="" title="image-20221008094359863">



<h2 id="成员变量和局部变量区别"><a href="#成员变量和局部变量区别" class="headerlink" title="成员变量和局部变量区别"></a>成员变量和局部变量区别</h2><p>局部变量和成员变量</p>
<ol>
<li>定义的位置不一样【重点】<br>局部变量：在方法的内部<br>成员变量：在方法的外部，类内部，直接写在类当中</li>
<li>作用范围（作用域）不一样【重点】<br>局部变量：只有方法当中才可以使用，出了方法就不能再用<br>成员变量：整个类内部全都可以使用。类比C语言中函数和全局变量的关系</li>
<li>默认值不一样【重点】<br>局部变量：没有默认值，如果要想使用，必须手动进行赋值。如果不指定初始值，直接使用，会报错。<br>成员变量：如果没有赋值，会有默认值，规则和数组一样</li>
</ol>
<p>​		<strong>成员变量是有默认的初始值。</strong></p>
<p>​				数据类型     默认的初始值</p>
<p>​				int                 0</p>
<p>​				float              0.0f</p>
<p>​				double          0.0</p>
<p>​				boolean        false</p>
<p>​				char               ‘ ‘</p>
<p>​				String（引用数据类型） null</p>
<p>​		 <strong>局部变量是没有默认的初始值的，必须要先初始化才能使用。</strong></p>
<ol start="4">
<li>内存的位置不一样（了解）</li>
</ol>
<p>​		局部变量：位于栈内存，即位于方法调用栈中，即调用某个方法的时候，局部变量就位于这个方法所处的那个栈内存段中。</p>
<p>​		成员变量：位于堆内存</p>
<ol start="5">
<li>生命周期不一样（了解）</li>
</ol>
<p>​		局部变量：随着方法进栈而诞生，随着方法出栈而消失。局部变量在调用了对应的方法时执行到了创建该变量的语句时存在，局部变</p>
<p>​		量一旦出了自己的作用域那么马上从内存中消失。</p>
<p>​		成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</p>
<p>​		<strong>局部变量的生命周期是从进入到某一个方法体或者代码块的时候生命周期就开始了，但是它的作用域是从定义它的位置开始到方法		体或者代码块结束位置。</strong></p>
<p>成员变量整个类内部都可以使用，是说针对于某一个对象而言，例如，Person类的对象p1，那么成员变量就是该对象内部的，那对应的所有成员方法（实例方法，也叫作绑定到对象的方法）全部都可以使用它。而对于另外一个对象p2，那么就是p2这个对象中的成员变量，对于该类的所有成员方法都可以使用。因此，是分不同对象而言的。注意，这里说的这些成员方法（实例方法，也叫作绑定到对象的方法）都是同一个类的各个对象共用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01VariableDifference</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">(<span class="type">int</span> param)</span> &#123; <span class="comment">// 方法的参数就是局部变量</span></span><br><span class="line">        <span class="comment">// 参数在方法调用的时候，必然会被赋值的。所以这里直接输出局部变量不报错。</span></span><br><span class="line">        System.out.println(param);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> age; <span class="comment">// 局部变量</span></span><br><span class="line"><span class="comment">//        System.out.println(age); // 没赋值不能用，编译会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(num); // 错误写法！num作用域为methodA中，跨作用域访问，错误</span></span><br><span class="line">        System.out.println(name);<span class="comment">//成员变量，在类内部通用，谁都能访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008101506978.png" class="" title="image-20221008101506978">

<p>在类中的位置不同 重点</p>
<p>成员变量：类中，方法外</p>
<p>局部变量：方法中或者方法声明上(形式参数)</p>
<p>作用范围不一样 重点</p>
<p>成员变量：类中</p>
<p>局部变量：方法中</p>
<p>初始化值的不同 重点</p>
<p>成员变量：有默认值</p>
<p>局部变量：没有默认值。必须先定义，赋值，最后使用</p>
<p>在内存中的位置不同 了解</p>
<p>成员变量：堆内存</p>
<p>局部变量：栈内存</p>
<p>生命周期不同 了解</p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p>
<p>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</p>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>匿名对象：没有引用类型变量指向的对象称作为匿名对象。</p>
<p>需求： 使用 java类描述一个学生类。</p>
<p>匿名对象要注意的事项：</p>
<ol>
<li>我们一般不会给匿名对象赋予属性值，因为永远无法获取到。</li>
<li>两个匿名对象永远都不可能是同一个对象。</li>
</ol>
<p>匿名对象好处：简化书写。</p>
<p>匿名对象的应用场景：</p>
<ol>
<li>如果一个对象需要调用一个方法一次的时候，而调用完这个方法之后，该对象就不再使用了，这时候可以使用<br> 匿名对象。</li>
<li>可以作为实参调用一个函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line"></span><br><span class="line">	String name; <span class="comment">//名字</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;好好学习，为将来称为高帅富做准备!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">			<span class="comment">//创建一个学生对象</span></span><br><span class="line">		<span class="comment">//Student s = new Student();</span></span><br><span class="line">		<span class="comment">//new Student().name = &quot;狗娃&quot;; //匿名对象 </span></span><br><span class="line">		<span class="comment">//System.out.println(new Student().name); //null</span></span><br><span class="line">		System.out.println(<span class="keyword">new</span> <span class="title class_">Student</span>() == <span class="keyword">new</span> <span class="title class_">Student</span>()) ; <span class="comment">//false // &quot;==&quot; 用于引用类型变量时，比较的是内存地址。判断两个 对象是否为同一个对象.</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//需求： 调用Student的study方法。</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		s.study();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Student</span>().study();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用匿名对象的情况，如果对一个对象只需要进行一次方法调用，Java的垃圾回收机制是自动的，它保证程序健壮的主要手段，同时也避免了回收内存带来的代码繁琐。</p>
<p>垃圾回收机制实际上是JVM内部运行的一个优先级比较低的后台线程，这种多线程的模式使得java 具有更好的性能，完全不用程序员参与。垃圾回收机制仅仅作用于堆内存，于栈内存无关。对于程序员来说，<strong>对象何时变成垃圾呢？</strong></p>
<p><strong>对象的引用被赋值为null；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>( ); </span><br><span class="line">p = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>一次性使用的匿名对象;</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>( ).sayHello( );</span><br></pre></td></tr></table></figure>

<p><strong>超出生命周期的；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">int</span> <span class="variable">I</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量p 被实例化100次，每结束一次循环，变量p就超出生命周期（也除了它的作用域了），对象变为垃圾，垃圾回收机制如下图所示</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008174908276.png" class="" title="image-20221008174908276">

<p>注意，在垃圾回收器回收对象占据的内存的时候，首先会调用对象的finalize()方法，进行一些资源的释放操作，例如，打开的文件进行关闭，占用的网络资源的释放。调用了finalize()方法之后，回收器才会回收对象占用的内存。</p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>Java中主要有3种类型的变量：<br>● 局部变量：定义在方法体中的变量；或是方法的形参。</p>
<p>● 实例成员变量：即类的属性，也是类内的全局变量。</p>
<p>● 静态成员变量：在类中声明为static 的属性。</p>
<p><strong>变量作用域，作用域是指变量在程序中的可使用范围</strong></p>
<p>各种类别变量的作用域</p>
<p>● 类变量（static静态成员变量）：用static修饰的属性，它们在类被载入时创建，只要类存在，static变量就存在</p>
<p>● 实例变量：类体中声明的属性为全局变量，全局变量在类的对象的整个生命周期中都有效。</p>
<p>● 局部变量：方法体中声明的变量，方法中的参数，或代码块中声明的变量，都是局部变量，局部变量只在方法调用的过程（加载到方法调用栈中的栈内存段上）中有效，方法调用结束后失效。代码块中的局部变量，作用范围就是该代码块，出了代码块之后就失效了。</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008181237395.png" class="" title="image-20221008181237395">

<p>实例变量（类内部的全局变量）与局部变量。</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008181415774.png" class="" title="image-20221008181415774">

<p>局部变量作用域。</p>
<p>for循环头中定义的循环变量i，其作用域是整个for循环，而在循环内定义的局部变量a、b和c，它们的作用域都是<strong>从定义的地方开始，到包含它的块结束</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;局部变量 x=&quot;</span> + x);</span><br><span class="line">        System.out.println(<span class="string">&quot;全局变量 y=&quot;</span> + y);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        e.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例变量只能声明一次，但是在方法内不同的嵌套块中，可以多次声明名称相同的变量。 如果局部变量和一个实例变量同名，那么在局部变量的作用域内实例变量被隐藏。</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008181724950.png" class="" title="image-20221008181724950">













<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象三大特征：</p>
<ol>
<li>封装</li>
<li>继承</li>
<li>多态。</li>
</ol>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的<br>方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p>
<p><strong>原则</strong><br>将属性隐藏起来，若需要访问某个属性或者设置某个属性，提供公共方法对其访问和设置。</p>
<p><strong>封装:</strong></p>
<p><strong>权限修饰符：权限修饰符就是控制成员可见范围的。</strong></p>
<p>public :  公共的。 public修饰的成员变量或者成员方法任何人都可以直接访问。</p>
<p>private ： 私有的， private修饰的成员变量或者成员方法<strong>只能在本类中</strong>进行直接访问和使用。</p>
<p>封装的步骤：</p>
<ol>
<li>使用private修饰需要被封装的属性。</li>
<li>提供一个公共的方法设置或者获取该私有的成员属性。对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。<br> 命名规范：<br> set属性名();<br> get属性名();</li>
</ol>
<p>疑问： 封装一定要提供get或者set方法吗？<br>        不一定， 根据需求而定的。</p>
<p>规范 ： 在现实开发中一般实体类的所有成员属性（成员变量）都要封装起来。即封装为javabean。</p>
<p>实体类：实体类就是用于描述一类 事物的就称作为实体类。</p>
<p>封装的好处：</p>
<ol>
<li>提高数据的安全性。</li>
<li>操作简单。 </li>
<li>隐藏了实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>	String name; <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>	String sex; <span class="comment">//性别</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>	<span class="type">int</span> salary; <span class="comment">//薪水</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义一个公共的方法设置sex属性</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String s)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.equals(<span class="string">&quot;男&quot;</span>)||s.equals(<span class="string">&quot;女&quot;</span>))&#123; <span class="comment">//注意： 如果比较两个字符串的内容是否一致，不要使用==比较， 使用equals方法。</span></span><br><span class="line">			sex = s;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//默认是男</span></span><br><span class="line">			sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个公共的方法获取sex属性</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sex;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//聊天</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;聊得非常开心&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo5</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Member</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Member</span>();</span><br><span class="line">		m.name=<span class="string">&quot;狗娃&quot;</span>;</span><br><span class="line">		m.setSex(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">		m.salary  = <span class="number">800</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+ m.name+<span class="string">&quot; 性别：&quot;</span>+ m.getSex()+<span class="string">&quot; 薪水：&quot;</span>+ m.salary);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h3><p><strong>private的含义</strong></p>
<ol>
<li>private是一个权限修饰符，代表最小权限。</li>
<li>可以修饰成员变量和成员方法。</li>
<li>被private修饰后的成员变量和成员方法，只在本类中才能访问。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">面向对象三大特征：封装、继承、多态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装性在Java当中的体现：</span></span><br><span class="line"><span class="comment">1. 方法就是一种封装</span></span><br><span class="line"><span class="comment">2. 关键字private也是一种封装</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装就是将一些细节信息隐藏起来，对于外界不可见。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Method</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">5</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(array);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给我一个数组，我还给你一个最大值</span></span><br><span class="line">    <span class="comment">//方法就是一种封装</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。</span></span><br><span class="line"><span class="comment">解决方案：用private关键字将需要保护的成员变量进行修饰。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一旦使用了private进行修饰，那么本类当中仍然可以随意访问。</span></span><br><span class="line"><span class="comment">但是！超出了本类范围之外就不能再直接访问了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">间接访问private成员变量，就是定义一对儿Getter/Setter方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">必须叫setXxx或者是getXxx命名规则。</span></span><br><span class="line"><span class="comment">对于Getter来说，不能有参数，返回值类型和成员变量对应；</span></span><br><span class="line"><span class="comment">对于Setter来说，不能有返回值，参数类型和成员变量对应。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个成员方法，专门用于向age设置数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">100</span> &amp;&amp; num &gt;= <span class="number">9</span>) &#123; <span class="comment">// 如果是合理情况</span></span><br><span class="line">            age = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据不合理！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个成员方法，专门私语获取age的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.show();</span><br><span class="line"></span><br><span class="line">        person.name = <span class="string">&quot;赵丽颖&quot;</span>;</span><br><span class="line"><span class="comment">//        person.age = -20; // 直接访问private内容，错误写法！</span></span><br><span class="line">        person.setAge(<span class="number">20</span>);</span><br><span class="line">        person.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于基本类型当中的boolean值，Getter方法一定要写成isXxx的形式，而setXxx规则不变。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> male; <span class="comment">// 是不是爷们儿</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMale</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">        male = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> male;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        name = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        stu.setName(<span class="string">&quot;鹿晗&quot;</span>);</span><br><span class="line">        stu.setAge(<span class="number">20</span>);</span><br><span class="line">        stu.setMale(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + stu.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + stu.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;是不是爷们儿：&quot;</span> + stu.isMale());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 使用java类描述一个计算器类，计算器具备操作数1， 操作数2 、操作符三个公共 的属性</span></span><br><span class="line"><span class="comment">，还具备计算的功能行为。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要求： 不能直接对操作数1，操作数2，运算符这些属性进行直接 的赋值，要封装起来。 (+ - * /  )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">根据需求提供get或者set方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	需要提供set方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num1; <span class="comment">//操作数1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num2;  <span class="comment">//操作数2</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span>	<span class="type">char</span> option ; <span class="comment">//运算符</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供公共的方法设置属性值....					</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initCalculator</span><span class="params">(<span class="type">int</span> n1 , <span class="type">int</span> n2 , <span class="type">char</span> o)</span>&#123;</span><br><span class="line">		num1 = n1;</span><br><span class="line">		num2 = n2;</span><br><span class="line">		<span class="keyword">if</span>(o==<span class="string">&#x27;+&#x27;</span>||o==<span class="string">&#x27;-&#x27;</span>||o==<span class="string">&#x27;*&#x27;</span>||o==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">			option = o;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			option = <span class="string">&#x27;+&#x27;</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算的功能</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(option)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做加法运算,结果是：&quot;</span>+(num1+num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做减法运算,结果是：&quot;</span>+(num1-num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做乘法运算,结果是：&quot;</span>+(num1*num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做除法运算,结果是：&quot;</span>+(num1/num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo6</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建了一个计算器对象</span></span><br><span class="line">		<span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">		<span class="comment">//设置属性值</span></span><br><span class="line">		c.initCalculator(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="comment">//调用计算器的计算功能</span></span><br><span class="line">		c.calculate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>09-构造函数&amp;构造代码块&amp;static&amp;this</title>
    <url>/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&amp;static&amp;this/</url>
    <content><![CDATA[<h1 id="09-构造函数-amp-构造代码块-amp-static-amp-this"><a href="#09-构造函数-amp-构造代码块-amp-static-amp-this" class="headerlink" title="09-构造函数&amp;构造代码块&amp;static&amp;this"></a>09-构造函数&amp;构造代码块&amp;static&amp;this</h1><h2 id="上节内容复习"><a href="#上节内容复习" class="headerlink" title="上节内容复习"></a>上节内容复习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对象：真实存在的唯一的事物。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">类： 同一种类型的事物公共属性与公共行为的抽取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">java面向对象语言： </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">核心思想： 找适合的对象做适合的事情.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">找对象的方式：</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	方式一： sun已经定义好了很多了类，我们只需要认识这些类即可创建对象使用。</span></span><br><span class="line"><span class="comment">	方式二： 我们需要自定义类，通过自定义类创建对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在整理笔记的过程中对自己有疑问的概念使用代码验证或者推翻它。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">自定义类三步骤：</span></span><br><span class="line"><span class="comment">	1. 自定义一个类。</span></span><br><span class="line"><span class="comment">		  class 类&#123;</span></span><br><span class="line"><span class="comment">			事物 的公共属性 使用成员变量描述。</span></span><br><span class="line"><span class="comment">			事物的公共行为  使用函数描述。</span></span><br><span class="line"><span class="comment">		  &#125;</span></span><br><span class="line"><span class="comment">	2. 可以通过类创建对象。</span></span><br><span class="line"><span class="comment">	3. 访问(设置)对象的属性或者调用对象的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员变量与局部变量 的区别：</span></span><br><span class="line"><span class="comment">	1. 自定义的位置区别：</span></span><br><span class="line"><span class="comment">			1. 成员变量是定义在方法之外，类之内的变量。是类内部的全局变量。 </span></span><br><span class="line"><span class="comment">			2. 局部变量是声明在方法之内的变量。</span></span><br><span class="line"><span class="comment">	2. 作用上的区别： </span></span><br><span class="line"><span class="comment">			1. 成员变量的作用描述一类事物的属性。</span></span><br><span class="line"><span class="comment">			2. 局部变量的作用是提供一个变量给方法内部使用的。</span></span><br><span class="line"><span class="comment">	3. 生命周期的区别；</span></span><br><span class="line"><span class="comment">			1. 成员变量随着对象的创建而存在，随着对象的消失而消失。</span></span><br><span class="line"><span class="comment">			2. 局部变量是调用到了对应的方法执行 到了创建该变量的语句时存在，一旦出了自己的作用域马上从内存中消失。</span></span><br><span class="line"><span class="comment">	4. 初始值的区别：</span></span><br><span class="line"><span class="comment">			1. 成员变量是有默认的初始值的。</span></span><br><span class="line"><span class="comment">			2. 局部变量是没有默认的初始值的，必须要先初始化才能使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">匿名对象： 没有引用类型变量指向的对象就称作为匿名对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名对象要注意的细节：</span></span><br><span class="line"><span class="comment">		1. 一般不会给匿名对象的属性赋值，因为永远都没法获取到。</span></span><br><span class="line"><span class="comment">		2. 两个匿名对象永远都不可能是同一个对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名对象好处：简化书写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名对象的应用场景：</span></span><br><span class="line"><span class="comment">	1. 如果调用一个对象的方法一次时，然后这个对象就不再使用，那么这时候可以使用匿名对象。</span></span><br><span class="line"><span class="comment">	2. 可以作为实参调用一个函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装的步骤：</span></span><br><span class="line"><span class="comment">	1. 使用private修饰需要被封装的属性.</span></span><br><span class="line"><span class="comment">	2. 根据需要提供get或者set方法设置以及获取属性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装的好处：</span></span><br><span class="line"><span class="comment">	1. 提高了数据的安全性。</span></span><br><span class="line"><span class="comment">	2. 操作简单。</span></span><br><span class="line"><span class="comment">	3. 隐藏了实现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：一般实体类的属性我们都会封装起来。	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>java是 面向对象的语言： “万物皆对象”: 任何事物都可以使用类进行描述。</p>
<p>需求： 使用java类描述 一个婴儿.</p>
<p>在现实生活中有两种婴儿， 一种婴儿一出生就具备了名字(白户)，还有一种婴儿就是 出生之后才有名字 的(黑户)。</p>
<p><strong>构造函数：</strong></p>
<p><strong>构造函数的作用： 给对应的对象进行初始化。</strong></p>
<p><strong>构造函数的定义的格式：</strong></p>
<pre><code>修饰符  函数名(形式参数)&#123;
    函数体...
&#125;
</code></pre>
<p><strong>构造函数要注意的细节：</strong></p>
<ol>
<li>构造函数 是没有返回值类型的。构造函数没有返回值。不能写void，否则变成了一个普通成员函数了。构造方法不能return一个具体的返回值，但是return;这样写是可以的。</li>
<li>构造函数的函数名必须要与类名一致。</li>
<li>构造函数并不是由我们手动调用的，而是在创建对应的对象时，jvm就会主动调用到对应的构造函数。</li>
<li>如果一个类没有显式的写上一个构造方法时，那么java编译器会为该类添加一个默认的无参的空函数体的构造函数的。</li>
<li>如果一个类已经显式的写上一个构造方法时,那么java编译器则不会再为该类添加 一个默认无参 的构造方法。</li>
<li>构造函数是可以在一个类中以函数重载的形式存在多个 的。构造函数可以重载。</li>
</ol>
<p><strong>提示：</strong>无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效，即不再提供默认无参构造方法。</p>
<p>疑问：创建对象时，jvm就会调用到对应的构造方法，那么我们以前没有学构造方法，那么以前创建对象时，jvm是否也会调用构造方法呢？如果有？构造方法从何而来呢？</p>
<p>会调用， java编译器在编译的时候给加上去的。</p>
<p>jdk提供了一个java开发工具(javap.exe)给我们进行反编译的。javap，字节码反编译工具。</p>
<p><strong>javap 反编译工具的使用格式：</strong></p>
<p><strong>javap -c -l -private 类名</strong></p>
<p>注意，javap加载的是类，不是class字节码文件。因此，后面跟的是类名，区分大小写的。</p>
<p><strong>疑问： java编译器添加 的无参构造方法的权限修饰符是 什么？</strong></p>
<p><strong>与类的权限修饰是一致的。</strong></p>
<p><strong>构造函数与普通 函数的区别：</strong>	</p>
<ol>
<li>返回值类型的区别：</li>
<li>构造函数是没有返回值类型 的。</li>
<li>普通函数是有返回值类型的，即使函数没有返回值，返回值类型也要写上void。</li>
<li>函数名的区别：</li>
<li>构造函数的函数名必须要与类名一致。</li>
<li>普通函数的函数名只要符合标识符的命名规则即可。</li>
<li>调用方式的区别：</li>
<li>构造函数是 在创建对象的时候由jvm自动进行调用的。构造函数只会被调用一次的。</li>
<li>普通函数是由我们使用对象调用的，一个对象可以调用多次普通 的函数。</li>
<li>作用上的区别：</li>
<li>构造函数 的作用用于初始化一个对象。</li>
<li>普通函数是用于描述一类事物的公共行为的。</li>
<li>修饰符不同，和普通方法一样，构造方法可以有任何访问的修饰：public，protected，private或者没有修饰。不同于普通方法的是，<strong>构造方法不能有以下非访问性质的修饰</strong>：abstract，final， native，static或者synchronized。</li>
<li>返回值不同，返回类型也是非常重要的。普通方法能返回任何类型的值或者无返回值（void），构造方法没有返回值，也不需要void。</li>
<li>命名不同，构造方法使用和类相同的名字，而普通方法则不同。按照习惯，普通方法通常用小写字母开始，而构造方法通常用大写字母开始。<strong>构造方法通常是一个名词，因为它和类名相同</strong>；<strong>而普通方法通常更接近动词，因为它说明一个操作</strong></li>
</ol>
<p>注意，引用在Java中就是地址的意思。</p>
<p>在类内的方法（构造方法和普通成员方法）中，访问本类的属性和其它成员方法就可以直接访问了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223157368.png" class="" title="image-20221008223157368">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223214714.png" class="" title="image-20221008223214714">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223321136.png" class="" title="image-20221008223321136">

<p>成员变量默认值。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223351038.png" class="" title="image-20221008223351038">

<p>成员变量显示初始化。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223431202.png" class="" title="image-20221008223431202">

<p>此时可以看到，同一个类的不同对象，成员变量值都是一样的了。没有做到个性化。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223541630.png" class="" title="image-20221008223541630">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223620361.png" class="" title="image-20221008223620361">

<p><strong>构造方法不能够这样手动直接调用的，是jvm中创建对象的时候自动调用的。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223715627.png" class="" title="image-20221008223715627">

<p>构造函数是创建对象的时候自动调用的。此时没有创建对象。</p>
<p>54行的b1是在栈中创建了一个引用变量，此时还没有创建对象呢。只有new了才会创建对象。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223827957.png" class="" title="image-20221008223827957">

<p>可以看到，new的时候，是真正的在堆中创建对象的，并且调用了构造函数了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223915045.png" class="" title="image-20221008223915045">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223950508.png" class="" title="image-20221008223950508">

<p>通过构造函数对成员变量进行初始化。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224100271.png" class="" title="image-20221008224100271">

<p>默认提供的无参构造方法是java编译器编译的时候默认提供上去的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Calculator.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num1; <span class="comment">//操作数1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num2;  <span class="comment">//操作数2</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span>	<span class="type">char</span> option ; <span class="comment">//运算符</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供公共的方法设置属性值....					</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initCalculator</span><span class="params">(<span class="type">int</span> n1 , <span class="type">int</span> n2 , <span class="type">char</span> o)</span>&#123;</span><br><span class="line">		num1 = n1;</span><br><span class="line">		num2 = n2;</span><br><span class="line">		<span class="keyword">if</span>(o==<span class="string">&#x27;+&#x27;</span>||o==<span class="string">&#x27;-&#x27;</span>||o==<span class="string">&#x27;*&#x27;</span>||o==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">			option = o;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			option = <span class="string">&#x27;+&#x27;</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算的功能</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(option)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做加法运算,结果是：&quot;</span>+(num1+num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做减法运算,结果是：&quot;</span>+(num1-num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做乘法运算,结果是：&quot;</span>+(num1*num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做除法运算,结果是：&quot;</span>+(num1/num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个类没有构造方法。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224331797.png" class="" title="image-20221008224331797">

<p>重点关注这3个参数。</p>
<p>jdk提供了一个java开发工具(javap.exe)给我们进行反编译的。</p>
<p>javap 反编译工具的使用格式：</p>
<p>javap -c -l -private 类名</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224459119.png" class="" title="image-20221008224459119">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224526476.png" class="" title="image-20221008224526476">

<p><strong>因此，默认无参构造方法是java编译器提供的。而不是jvm虚拟机提供的。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224659284.png" class="" title="image-20221008224659284">

<p>我们提供一个构造方法。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224717257.png" class="" title="image-20221008224717257">

<p><strong>此时编译器不会再提供默认的无参默认的那个构造方法了。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224826164.png" class="" title="image-20221008224826164">

<p>javac编译器默认提供的那个无参构造方法的访问权限修饰符是什么？</p>
<p>public，private，还是没有呢？</p>
<p><strong>这3个选择都是错的。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224926856.png" class="" title="image-20221008224926856">

<p><strong>现在该类没有构造方法。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224950903.png" class="" title="image-20221008224950903">

<p>此时编译器提供的默认无参构造方法没有访问权限修饰符。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225032500.png" class="" title="image-20221008225032500">

<p>给类增加权限修饰符。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225112268.png" class="" title="image-20221008225112268">

<p>此时构造方法的权限修饰符就是public，说明它是和类的权限修饰符保持一致的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225135481.png" class="" title="image-20221008225135481">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225227432.png" class="" title="image-20221008225227432">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225246262.png" class="" title="image-20221008225246262">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225305526.png" class="" title="image-20221008225305526">

<p><strong>因为没有提供无参的构造方法。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225338504.png" class="" title="image-20221008225338504">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225352655.png" class="" title="image-20221008225352655">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225444067.png" class="" title="image-20221008225444067">

<p><strong>构造函数没有返回值类型的，如果人为指定了返回值类型，那么该函数就不是构造函数了，就变成了普通的函数了。</strong></p>
<p><strong>用到的示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//婴儿类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//身份证</span></span><br><span class="line"> </span><br><span class="line">	String  name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Baby</span><span class="params">(<span class="type">int</span> i , String n)</span>&#123;</span><br><span class="line">		id  = i;</span><br><span class="line">		name = n;</span><br><span class="line">		System.out.println(<span class="string">&quot;baby的属性初始化完毕！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参 的构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Baby</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;无参的构造函数被调用了..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//哭</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;哇哇哭...&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="comment">//创建一个baby对象</span></span><br><span class="line">		<span class="type">Baby</span> <span class="variable">b1</span> <span class="operator">=</span> 	<span class="keyword">new</span> <span class="title class_">Baby</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>); <span class="comment">//婴儿诞生   白户</span></span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ b1.id +<span class="string">&quot; 姓名：&quot;</span>+ b1.name);</span><br><span class="line">		b1.cry();</span><br><span class="line">		b1.cry();</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//黑户</span></span><br><span class="line"><span class="comment">		Baby b2 = new Baby();</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		b2.id = 112;</span></span><br><span class="line"><span class="comment">		b2.name = &quot;狗剩&quot;;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;编号：&quot;+ b2.id +&quot; 姓名：&quot;+ b2.name);</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008230939363.png" class="" title="image-20221008230939363">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008230957952.png" class="" title="image-20221008230957952">

<p>此时没有构造方法，同时成员变量也没有采用显示初始化。</p>
<p>可以看到，成员变量使用了默认值了都。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231101214.png" class="" title="image-20221008231101214">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231122789.png" class="" title="image-20221008231122789">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231142357.png" class="" title="image-20221008231142357">

<p><strong>注意，没有使用到包的时候，构造方法前面的public，不写也没问题。</strong></p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo3.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">描述一个员工类，员工具备 的属性：id\ name \ age 。</span></span><br><span class="line"><span class="comment">具备的公共行为： 工作。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要求：一旦创建一个员工对象 的时候，那么该员工对象就要对应 的属性值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> id;  <span class="comment">//编号</span></span><br><span class="line"></span><br><span class="line">	String name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> a, String b , <span class="type">int</span> c)</span>&#123;</span><br><span class="line">		id =a;</span><br><span class="line">		name = b;</span><br><span class="line">		age = c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;好好工作，努力挣钱!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建一个员工对象</span></span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Employee</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>,<span class="number">20</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ e.id+<span class="string">&quot; 名字：&quot;</span>+e.name +<span class="string">&quot; 年龄：&quot;</span>+ e.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231444545.png" class="" title="image-20221008231444545">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231501001.png" class="" title="image-20221008231501001">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231525761.png" class="" title="image-20221008231525761">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231545281.png" class="" title="image-20221008231545281">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231607939.png" class="" title="image-20221008231607939">

<p>出生就能够哭。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231705762.png" class="" title="image-20221008231705762">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231722681.png" class="" title="image-20221008231722681">

<p>无参构造方法中没有调用cry，因此，b2出生没哭。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231745562.png" class="" title="image-20221008231745562">

<p><strong>可以看到，12行和17行属于重复代码了，不好。</strong></p>
<p><strong>此时使用构造代码块来解决这个问题。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造代码块：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造代码块的作用：给所有对象进行统一的初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造函数的作用： 给对应的特定的一个对象进行初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两者的区别。构造函数是给对应的某一个对象初始化。而构造代码块是给所有的对象进行统一初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造代码块的格式：</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		构造代码块</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意： 构造代码块的大括号必须位于成员位置上。即和成员变量，成员方法都是并列的。</span></span><br><span class="line"><span class="comment">注意，构造代码块大括号必须位于成员位置上，也就是说，类内部，方法外部，意思就是说，和成员变量，成员方法是同一级别的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">代码块的类别：</span></span><br><span class="line"><span class="comment">	1. 构造代码块。</span></span><br><span class="line"><span class="comment">	2. 局部代码块.   大括号位于方法之内。  作用：缩短局部变量的生命周期，节省一点点内存。同时也是缩小了局部变量的作用域。</span></span><br><span class="line"><span class="comment">	3. 静态代码块  static </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232149828.png" class="" title="image-20221008232149828">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232445354.png" class="" title="image-20221008232445354">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232534379.png" class="" title="image-20221008232534379">

<p><strong>可以看到，构造代码块也是在创建对象的时候执行的。55行没有创建对象的，只是定义了一个引用变量而已。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232610763.png" class="" title="image-20221008232610763">

<p>可以看到，构造代码块也执行了。</p>
<p><strong>只要创建对象，那么构造代码块就会被执行的。跟构造函数的参数啥的没关系。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232656746.png" class="" title="image-20221008232656746">

<p><strong>这里说明一点，构造函数中调用普通成员函数cry()，实际就是this.cry()这样调用的。</strong></p>
<p><strong>也就是new的时候，首先根据方法区中class字节码中类的信息，知道了成员变量类型了，然后对对象在堆中根据成员变量类型来进行分配空间，然后我们在编译的时候，会对类体进行重新整理，将成员变量的声明通通提到类的最前面，然后将成员变量的显示初始化和构造代码块的初始化，通通放入到构造函数中进行，并且放在构造函数中最前面来执行，同时，显示初始化和构造代码块在构造函数中最前面的顺序，就依赖于成员变量显示初始化和构造代码块初始化在类体中书写的先后顺序了，谁在前，那么谁就在构造函数中的前面。待成员变量显示初始化和构造代码块初始化都完事了，才会执行构造函数本身的初始化操作。</strong></p>
<p><strong>当构造函数执行完毕之后，堆中这个对象才是真正的创建完毕了，将对象的引用返回给栈中的引用变量。</strong></p>
<p><strong>注意，在构造函数中调用普通成员函数，因为new对象的时候，首先就在堆中给对象分配内存空间了，对象已经存在了，在构造函数执行的时候，当前的这个对象已经有了，因此，执行构造函数的时候，实际上也是将当前对象作为第一个隐含参数传入给构造函数中的this了。因此，构造函数中调用cry，实际上就是this.cry()调用。在构造函数中给成员变量赋值，实际上也是this.xxx&#x3D;xxx，因为这个this就是指向当前的堆中分配了空间的那个对象了。调用cry的时候，就是this.cry()，实际上同理也是将当前对象作为第一个隐含参数传入，即为cry(this,xx,yy)这样的，传给了cry中的this了。因此，在cry中访问成员变量，也是this.xxx这样的了。</strong></p>
<p><strong>从另外一个角度理解，就是类中的成员方法和成员变量之间是可以互相随意访问的。类似C语言中的各个函数和全局变量的关系。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232713324.png" class="" title="image-20221008232713324">

<p><strong>将cry移动到构造代码块中调用。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008235846034.png" class="" title="image-20221008235846034">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008235923889.png" class="" title="image-20221008235923889">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000011237.png" class="" title="image-20221009000011237">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000032887.png" class="" title="image-20221009000032887">

<p>可以看到加上了局部代码块也没什么区别。</p>
<p>实际上，局部代码块，基本上没什么太大的作用。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000058898.png" class="" title="image-20221009000058898">

<p>局部代码块的唯一的一点作用。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000210096.png" class="" title="image-20221009000210096">

<p>此时的b1变量，和右边的new出来的对象的作用范围就是到69行，出了69行就消失了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000301737.png" class="" title="image-20221009000301737">

<p>此时b1和new出来的对象在出了61行就是垃圾对象和变量了，会被回收和释放。</p>
<p>因此，局部代码块用途不大，因为现在内存都足够。</p>
<p>构造代码块是有用的。</p>
<p>静态代码块，在学习static的时候，说明。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo4.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//身份证</span></span><br><span class="line"> </span><br><span class="line">	String  name;  <span class="comment">//名字</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造代码块...</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;构造代码块的代码执行了......&quot;);</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带参构造函数</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Baby</span><span class="params">(<span class="type">int</span> i , String n)</span>&#123;</span><br><span class="line">		id  = i;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//无参构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Baby</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;哇哇哭...&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Baby</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Baby</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>);  <span class="comment">//  狗娃 狗剩 铁蛋</span></span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ b1.id + <span class="string">&quot; 名字：&quot;</span>+b1.name);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;编号：&quot;+ b1.id + &quot; 名字：&quot;+b1.name);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		new Baby(110,&quot;狗娃&quot;);</span></span><br><span class="line"><span class="comment">		new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>构造代码块和成员变量显示初始化，在编译之后，会对类进行重新整理。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000656083.png" class="" title="image-20221009000656083">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000742938.png" class="" title="image-20221009000742938">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000813411.png" class="" title="image-20221009000813411">

<p>换个位置。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000826271.png" class="" title="image-20221009000826271">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000846322.png" class="" title="image-20221009000846322">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000854980.png" class="" title="image-20221009000854980">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000918305.png" class="" title="image-20221009000918305">

<p>将构造方法中的注释。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000929774.png" class="" title="image-20221009000929774">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000950990.png" class="" title="image-20221009000950990">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000958040.png" class="" title="image-20221009000958040">



<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造 代码块要注意的事项：</span></span><br><span class="line"><span class="comment">	1. java编译器编译一个java源文件的时候，会把成员变量的声明语句提前至一个类的最前端。</span></span><br><span class="line"><span class="comment">	2. 成员变量的初始化工作其实都是在构造函数中执行的。</span></span><br><span class="line"><span class="comment">	3. 一旦经过java编译器编译后，那么构造代码块的代码块就会被移动构造函数中执行，是在构造函数中的代码之前执行的，构造函数的中代码是最后执行 的。</span></span><br><span class="line"><span class="comment">	4. 成员变量的显示初始化与构造代码块 的代码是按照当前代码的书写顺序执行的。成员变量显示初始化，也是放在构造函数中进行的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo5</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo5</span><span class="params">()</span>&#123;   <span class="comment">//构造函数</span></span><br><span class="line">		i = <span class="number">300000000</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//构造代码块   //构造代码块的初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="number">200000000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100000000</span>;	 <span class="comment">//成员变量的显初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Demo5</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo5</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;i = &quot;</span>+d.i); <span class="comment">//    双、吴、刘 ：2000   ：</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093400820.png" class="" title="image-20221009093400820">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093409512.png" class="" title="image-20221009093409512">

<p>构造方法放在前面也没有问题，照样不报错的。</p>
<p>因此，虽然有多次不同地方赋值了，但是最后的执行的，还是构造函数。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093439163.png" class="" title="image-20221009093439163">

<p>反编译。</p>
<p>反编译的结果，可以看到，编译的时候对书写的代码进行了调整了。</p>
<p>将int i声明放在了类体的最前面了。因此，符合先定义后使用，所以，6行这里在9行前面使用，就不会报错。</p>
<p>另外，9行这里是声明时候就赋值了，而编译之后，可以看到，是先声明了，没有立即给i赋值。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093652122.png" class="" title="image-20221009093652122">

<p>可以看到，将赋值的操作通通放到了构造函数中去执行了。成员变量显示初始化也放在了构造函数中了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093731081.png" class="" title="image-20221009093731081">

<p>并且，可以看到，构造代码块内容也放到了构造函数中执行了，并且是在构造函数中的内容的前面。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094137208.png" class="" title="image-20221009094137208">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094155915.png" class="" title="image-20221009094155915">

<p>颠倒顺序。</p>
<p>可以看到，编译器将声明放到了类的最前面，然后所有的赋值都是在构造方法中进行的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094228285.png" class="" title="image-20221009094228285">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//身份证</span></span><br><span class="line"> </span><br><span class="line">	String  name;  <span class="comment">//名字</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造代码块...</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;构造代码块的代码执行了......&quot;);</span></span><br><span class="line">		cry();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带参构造函数</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Baby</span><span class="params">(<span class="type">int</span> i , String n)</span>&#123;</span><br><span class="line">		id  = i;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//无参构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Baby</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;哇哇哭...&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Baby</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Baby</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>);  <span class="comment">//  狗娃 狗剩 铁蛋</span></span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ b1.id + <span class="string">&quot; 名字：&quot;</span>+b1.name);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;编号：&quot;+ b1.id + &quot; 名字：&quot;+b1.name);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		new Baby(110,&quot;狗娃&quot;);</span></span><br><span class="line"><span class="comment">		new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094315613.png" class="" title="image-20221009094315613">

<p>此时是null。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094335545.png" class="" title="image-20221009094335545">

<p><strong>会将构造代码块中的cry()调用，拿到构造方法中的代码的前面了。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094448748.png" class="" title="image-20221009094448748">

<p>实际上编译之后，就是这样的了。</p>
<p><strong>而此时name还没有值呢，而成员变量String name;也没有赋值，所以就是null的。</strong></p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo04：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造代码块：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造代码块的作用：给对象进行统一的初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造函数的作用： 给对应的对象进行初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造代码块的格式：</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   &#123;</span></span><br><span class="line"><span class="comment">      构造代码块</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意： 构造代码块的大括号必须位于成员 位置上。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">代码块的类别：</span></span><br><span class="line"><span class="comment">   1. 构造代码块。</span></span><br><span class="line"><span class="comment">   2. 局部代码块.   大括号位于方法之内。  作用：缩短局部 变量 的生命周期，节省一点点内存。</span></span><br><span class="line"><span class="comment">   3. 静态代码块  static </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id; <span class="comment">//身份证</span></span><br><span class="line"></span><br><span class="line">    String  name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造代码块...</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;构造代码块的代码执行了......&quot;);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">Baby</span><span class="params">(<span class="type">int</span> i , String n)</span>&#123;</span><br><span class="line">        id  = i;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Baby</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;哇哇哭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Baby</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Baby</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>);  <span class="comment">//  狗娃 狗剩 铁蛋</span></span><br><span class="line">        System.out.println(<span class="string">&quot;编号：&quot;</span>+ b1.id + <span class="string">&quot; 名字：&quot;</span>+b1.name);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      System.out.println(&quot;编号：&quot;+ b1.id + &quot; 名字：&quot;+b1.name);</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">      new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">      new Baby();</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      new Baby(110,&quot;狗娃&quot;);</span></span><br><span class="line"><span class="comment">      new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">      new Baby();</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Demo05：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造 代码块要注意的事项：</span></span><br><span class="line"><span class="comment">   1. java编译器编译一个java源文件的时候，会把成员变量的声明语句提前至一个类的最前端。</span></span><br><span class="line"><span class="comment">   2. 成员变量的初始化工作其实都在在构造函数中执行的。</span></span><br><span class="line"><span class="comment">   3. 一旦经过java编译器编译后，那么构造代码块的代码块就会被移动构造函数中执行，是在构造函数中的代码之前执行的，构造函数的中代码是最后执行 的。</span></span><br><span class="line"><span class="comment">   4. 成员变量的显示初始化与构造代码块 的代码是按照当前代码的顺序执行的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo5</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo5</span><span class="params">()</span>&#123;   <span class="comment">//构造函数</span></span><br><span class="line">        i = <span class="number">300000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造代码块   //构造代码块的初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">200000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100000000</span>;  <span class="comment">//成员变量的显初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Demo5</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo5</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span>+d.i); <span class="comment">//    双、吴、刘 ：2000   ：</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p><strong>标准代码——JavaBean</strong></p>
<p>JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，<strong>要求类必须是具体的和公共（public）的，并且必须具有无参数的构造方法</strong>，提供用来操作成员变量的 set 和 get 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;<span class="comment">//必须是public的</span></span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="comment">//无参构造方法【必须】</span></span><br><span class="line">  <span class="comment">//有参构造方法【建议】</span></span><br><span class="line">  <span class="comment">//成员方法    </span></span><br><span class="line">  <span class="comment">//getXxx()</span></span><br><span class="line">  <span class="comment">//setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个标准的类(JavaBean)通常要拥有下面四个组成部分：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 所有的成员变量都要使用private关键字修饰</span></span><br><span class="line"><span class="comment">2. 为每一个成员变量编写一对儿Getter/Setter方法</span></span><br><span class="line"><span class="comment">3. 编写一个无参数的构造方法</span></span><br><span class="line"><span class="comment">4. 编写一个全参数的构造方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这样标准的类也叫做Java Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        stu1.setName(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        stu1.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + stu1.getName() + <span class="string">&quot;，年龄：&quot;</span> + stu1.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + stu2.getName() + <span class="string">&quot;，年龄：&quot;</span> + stu2.getAge());</span><br><span class="line">        stu2.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + stu2.getName() + <span class="string">&quot;，年龄：&quot;</span> + stu2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="this关键字第一种用法（指向当前调用者对象）"><a href="#this关键字第一种用法（指向当前调用者对象）" class="headerlink" title="this关键字第一种用法（指向当前调用者对象）"></a>this关键字第一种用法（指向当前调用者对象）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 使用java类描述一个动物。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">问题：存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是就近原则的机制访问的。)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字代表了所属函数的调用者对象。即谁调用了成员方法，那么谁就是那个this，也就是当前对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字作用：两个作用</span></span><br><span class="line"><span class="comment">	1. 如果存在同名成员变量与局部变量时，在方法内部默认是访问局部变量的数据（就近原则），可以通过this关键字指定访问成员变量的数据。</span></span><br><span class="line"><span class="comment">	2. 在一个构造函数中可以调用另外一个构造函数初始化对象。即通过类似this()方式，同时该语句必须是构造函数的第一条语句，它前面不能有任何其他的语句，否则报错。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字要注意事项：</span></span><br><span class="line"><span class="comment">	1. 存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是“就近原则”的机制访问的。)</span></span><br><span class="line"><span class="comment">	2. 如果在一个成员方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的 前面添加this关键字。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>this的含义</strong></p>
<p><strong>this代表所在类的当前对象的引用（地址值），即对象自己的引用。</strong></p>
<p><strong>记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</strong></p>
<p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。<br>如果需要访问本类当中的成员变量，需要使用格式：<br>this.成员变量名<br>“通过谁调用的方法，谁就是this。”</p>
<p>提示：方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。例如，方法中只有一个变量，即直接引用成员变量。注意，是直接使用这个变量，而不是新定义一个变量，直接使用这个变量，那么就是前面加上了this的，使用的就是成员变量，如果新定义了一个同名变量，那么就是局部变量了。</p>
<p><strong>this的两个作用：</strong></p>
<p>1、this表示当前对象，谁调用了方法，那么谁就是this。</p>
<p>2、this简化构造方法的调用。例如，this()或者this(1,2)。</p>
<p>实际上在实例方法形参中隐含的有一个变量this，就是用来接收调用这个实例方法的时候的对象的，然后this就指向了这个对象，实例方法中调用的成员变量，就是this去调用，然后this指向了哪个对象，那么就调用了哪个对象中的成员变量了。</p>
<p>这里类似python中的绑定方法，绑定给对象的方法，会自动将当前对象作为第一个参数传入给self。</p>
<p><strong>成员方法也可以叫做实例方法。</strong></p>
<p><strong>成员变量，也可以叫做实例数据成员变量。</strong></p>
<p>注意，this(1,1)，简化对类中其它构造函数的调用，这个this语句必须是这个当前的构造函数中的第一条语句。否则报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">100000</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Test02</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.i=<span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Test02</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>();</span><br><span class="line">		<span class="built_in">this</span>.i=i;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		i=<span class="number">30000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当存在this()方式调用其它构造函数的时候，查看编译之后，如何对成员变量显示初始化和构造代码块进行重整。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009113443277.png" class="" title="image-20221009113443277">

<p>可以看到，调用this()的时候，它必须是构造函数的第一条语句，因此，重整的时候，就不会在Test02(int)构造方法中添加了，只会在Test02()构造方法中添加成员变量显示初始化和构造代码块了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114045590.png" class="" title="image-20221009114045590">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114101087.png" class="" title="image-20221009114101087">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114110656.png" class="" title="image-20221009114110656">

<p>就近原则，现在在eat方法的方法调用栈中有name，因此，直接就拿到这个name了。如果在eat方法自己的方法调用栈中没有name，那么才会再去到堆内存的对象空间中去找name了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114749957.png" class="" title="image-20221009114749957">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114821015.png" class="" title="image-20221009114821015">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114827957.png" class="" title="image-20221009114827957">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114852767.png" class="" title="image-20221009114852767">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114905586.png" class="" title="image-20221009114905586">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114912860.png" class="" title="image-20221009114912860">

<p>可以看到，地址一样的。</p>
<p><strong>谁调用了函数，那么this就是谁。也就是哪个对象调用了函数，那么函数中的this就是哪个对象。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115556575.png" class="" title="image-20221009115556575">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115605514.png" class="" title="image-20221009115605514">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115612541.png" class="" title="image-20221009115612541">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115628783.png" class="" title="image-20221009115628783">

<p><strong>栈内存也称为方法栈。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115722878.png" class="" title="image-20221009115722878">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115730293.png" class="" title="image-20221009115730293">

<p><strong>现在内存中有两个对象，两份堆中的name的，那么为何34行输出的是猫的，而不是狗的呢？</strong></p>
<p><strong>如果在一个方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的 前面添加this关键字。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115827918.png" class="" title="image-20221009115827918">

<p><strong>因此，37行的name，编译之后，等价于是this.name了。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009151854088.png" class="" title="image-20221009151854088">

<p><strong>如果是这样，方法中有局部变量和成员变量同名的时候，那么编译之后，37行就不会有this.name这样的了。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009151937976.png" class="" title="image-20221009151937976">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009151945059.png" class="" title="image-20221009151945059">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152252882.png" class="" title="image-20221009152252882">

<p>因此，在Student方法内部使用的id和name，9行，10行左边的id和name都是局部变量id和name了，也就是形参定义的。就相当于是形参局部变量自己给自己赋值了。</p>
<p>相当于是如下这样</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152341917.png" class="" title="image-20221009152341917">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152410391.png" class="" title="image-20221009152410391">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152428080.png" class="" title="image-20221009152428080">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152448872.png" class="" title="image-20221009152448872">



<p><strong>案例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo6.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 使用java类描述一个动物。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">问题：存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是就近原则的机制访问的。)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字代表了所属函数的调用者对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字作用：</span></span><br><span class="line"><span class="comment">	1. 如果存在同名成员变量与局部变量时，在方法内部默认是访问局部变量的数据，可以通过this关键字指定访问成员变量的数据。</span></span><br><span class="line"><span class="comment">	2. 在一个构造函数中可以调用另外一个构造函数初始化对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字要注意事项：</span></span><br><span class="line"><span class="comment">	1. 存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是“就近原则”的机制访问的。)</span></span><br><span class="line"><span class="comment">	2. 如果在一个方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的 前面添加this关键字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name ;  <span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">	String color;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String n , String c)</span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		color = c;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//this关键字代表了所属函数的调用者对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;this:&quot;+ this);</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;老鼠&quot;</span>; <span class="comment">//局部变量</span></span><br><span class="line">		System.out.println(name+<span class="string">&quot;在吃...&quot;</span>); <span class="comment">//需求： 就要目前的name是成员变量的name.</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo6</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;狗&quot;</span>,<span class="string">&quot;白色&quot;</span>);  <span class="comment">//现在在内存中存在两份name数据。</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;猫&quot;</span>,<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">		cat.eat();</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="this关键字第二种用法（调用本类其它构造方法）"><a href="#this关键字第二种用法（调用本类其它构造方法）" class="headerlink" title="this关键字第二种用法（调用本类其它构造方法）"></a>this关键字第二种用法（调用本类其它构造方法）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;  <span class="comment">//身份证</span></span><br><span class="line"></span><br><span class="line">	String name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//目前情况：存在同名的成员变量与局部变量，在方法内部默认是使用局部变量的。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id,String name)</span>&#123;  <span class="comment">//一个函数的形式参数也是属于局部变量。</span></span><br><span class="line">		<span class="built_in">this</span>(name); <span class="comment">//调用了本类的一个参数的构造方法</span></span><br><span class="line">		<span class="comment">//this(); //调用了本类无参的 构造方法。与上面的this(name)不能同时出现，因为都必须是第一条语句，就矛盾了。</span></span><br><span class="line">		<span class="built_in">this</span>.id = id; <span class="comment">// this.id = id 局部变量的id给成员变量的id赋值</span></span><br><span class="line">		System.out.println(<span class="string">&quot;两个参数的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;无参的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		System.out.println(<span class="string">&quot;一个参数的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo7</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">110</span>,<span class="string">&quot;铁蛋&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ s.id +<span class="string">&quot; 名字：&quot;</span> + s.name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		Student s2 = new Student(&quot;金胖子&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;名字：&quot; + s2.name);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165221048.png" class="" title="image-20221009165221048">

<p>代码冗余。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165248764.png" class="" title="image-20221009165248764">

<p>这样是不行的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165409600.png" class="" title="image-20221009165409600">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165430128.png" class="" title="image-20221009165430128">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165437098.png" class="" title="image-20221009165437098">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165449324.png" class="" title="image-20221009165449324">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165455342.png" class="" title="image-20221009165455342">



<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo6.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 使用java类描述一个动物。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">问题：存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是就近原则的机制访问的。)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字代表了所属函数的调用者对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字作用：</span></span><br><span class="line"><span class="comment">	1. 如果存在同名成员变量与局部变量时，在方法内部默认是访问局部变量的数据，可以通过this关键字指定访问成员变量的数据。</span></span><br><span class="line"><span class="comment">	2. 在一个构造函数中可以调用另外一个构造函数初始化对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字要注意事项：</span></span><br><span class="line"><span class="comment">	1. 存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是“就近原则”的机制访问的。)</span></span><br><span class="line"><span class="comment">	2. 如果在一个方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的 前面添加this关键字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name ;  <span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">	String color;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String n , String c)</span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		color = c;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//this关键字代表了所属函数的调用者对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;this:&quot;+ this);</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;老鼠&quot;</span>; <span class="comment">//局部变量</span></span><br><span class="line">		System.out.println(name+<span class="string">&quot;在吃...&quot;</span>); <span class="comment">//需求： 就要目前的name是成员变量的name.</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo6</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;狗&quot;</span>,<span class="string">&quot;白色&quot;</span>);  <span class="comment">//现在在内存中存在两份name数据。</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;猫&quot;</span>,<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">		cat.eat();</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Demo7.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;  <span class="comment">//身份证</span></span><br><span class="line"></span><br><span class="line">	String name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//目前情况：存在同名 的成员 变量与局部变量，在方法内部默认是使用局部变量的。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id,String name)</span>&#123;  <span class="comment">//一个函数的形式参数也是属于局部变量。</span></span><br><span class="line">		<span class="built_in">this</span>(name); <span class="comment">//调用了本类的一个参数的构造方法</span></span><br><span class="line">		<span class="comment">//this(); //调用了本类无参的 构造方法。</span></span><br><span class="line">		<span class="built_in">this</span>.id = id; <span class="comment">// this.id = id 局部变量的id给成员变量的id赋值</span></span><br><span class="line">		System.out.println(<span class="string">&quot;两个参数的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;无参的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		System.out.println(<span class="string">&quot;一个参数的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo7</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">110</span>,<span class="string">&quot;铁蛋&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ s.id +<span class="string">&quot; 名字：&quot;</span> + s.name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		Student s2 = new Student(&quot;金胖子&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;名字：&quot; + s2.name);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>练习：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> id;<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 方法中的变量与属性重名</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		id++;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在一个构造方法中，调用其他重载的构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(name);</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 把this作为一个局部变量，它的值是当前对象的引用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Dog <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">		id++;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;it is &quot;</span> + name + <span class="string">&quot; number &quot;</span> + id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">wangcai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Cai Wang&quot;</span>);</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">wangwang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Wang Wang&quot;</span>);</span><br><span class="line">		wangcai.print();</span><br><span class="line">		wangwang.print();</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">wangcai1</span> <span class="operator">=</span> wangcai.clone();<span class="comment">//和wangcai指向了同一个对象了</span></span><br><span class="line">		wangcai1.print();</span><br><span class="line">		wangwang.clone().clone().print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">it is Cai Wang number <span class="number">1</span></span><br><span class="line">it is Wang Wang number <span class="number">1</span></span><br><span class="line">it is Cai Wang number <span class="number">2</span></span><br><span class="line">it is Wang Wang number <span class="number">3</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="static静态成员变量"><a href="#static静态成员变量" class="headerlink" title="static静态成员变量"></a>static静态成员变量</h2><p><strong>静态变量（类变量）</strong><br>static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属<br>于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</p>
<p><strong>定义和使用格式</strong><br><strong>类变量</strong><br><strong>当 static 修饰成员变量时，该变量称为类变量</strong>。该类的每个对象都共享同一个类变量的值。任何对象都可以更改<br>该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。<br><strong>类变量：使用 static关键字修饰的成员变量。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id; <span class="comment">// 学号</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">static</span> String room; <span class="comment">// 所在教室</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">idCounter</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 学号计数器，每当new了一个新对象的时候，计数器++</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01StaticField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;黄蓉&quot;</span>, <span class="number">16</span>);</span><br><span class="line">        two.room = <span class="string">&quot;101教室&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + two.getName()</span><br><span class="line">                + <span class="string">&quot;，年龄：&quot;</span> + two.getAge() + <span class="string">&quot;，教室：&quot;</span> + two.room</span><br><span class="line">                + <span class="string">&quot;，学号：&quot;</span> + two.getId());</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭靖&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + one.getName()</span><br><span class="line">                + <span class="string">&quot;，年龄：&quot;</span> + one.getAge() + <span class="string">&quot;，教室：&quot;</span> + one.room</span><br><span class="line">                + <span class="string">&quot;，学号：&quot;</span> + one.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo9.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static(静态)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求：描述一下学生类。  都是中国人....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">目前存在的问题： 所有的学生都是中国 的，有n个学生就会有n份中国的 数据存内存中，这样子</span></span><br><span class="line"><span class="comment">会浪费内存。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">目前方案： 把“中国”这个数据移动 到数据共享区中，共享这个数据给所有的Student对象使用即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">问题2： 如何才能把这个数据移动 到数据共享区中共享呢？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决方案： 只需要使用static修饰该数据即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">静态的成员变量只会在数据共享区中维护一份，而非静态成员变量的数据会在每个对象中都维护一份的。。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用了static修饰country，那么这时候country就是一个共享的数据。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>	<span class="type">String</span>  <span class="variable">country</span>  <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;	<span class="comment">//国籍</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo9</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;陈七&quot;</span>);</span><br><span class="line"></span><br><span class="line">		s1.country = <span class="string">&quot;小日本&quot;</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+s1.name+<span class="string">&quot; 国籍：&quot;</span>+ s1.country); <span class="comment">//  中国   </span></span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+s2.name+<span class="string">&quot; 国籍：&quot;</span>+ s2.country); <span class="comment">// 小日本</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172533239.png" class="" title="image-20221009172533239">

<p>现在country是成员变量，那么每创建一个对象，对象的堆内存中都会有一个成员变量country的，并且值都是一样的，冗余了。</p>
<p>使用static静态成员变量。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172633328.png" class="" title="image-20221009172633328">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172707352.png" class="" title="image-20221009172707352">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172724350.png" class="" title="image-20221009172724350">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172817051.png" class="" title="image-20221009172817051">



<p><strong>静态的成员变量只会在数据共享区（方法区）中维护一份，而非静态成员变量的数据会在每个对象中都维护一份的。。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172913661.png" class="" title="image-20221009172913661">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172922014.png" class="" title="image-20221009172922014">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172955579.png" class="" title="image-20221009172955579">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo10.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static(静态\修饰符)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	1. static修饰成员变量 ：如果有数据需要被共享给所有对象使用时，那么就可以使用static修饰。</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		静态成员变量的访问方式：</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">				方式1： 可以使用对象进行访问。</span></span><br><span class="line"><span class="comment">					格式： 对象.变量名。</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">				方式二： 可以使用类名进行访问。</span></span><br><span class="line"><span class="comment">					格式： 类名.变量名;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">			注意： </span></span><br><span class="line"><span class="comment">				1. 非静态的成员变量只能使用对象进行访问，不能使用类名进行访问。</span></span><br><span class="line"><span class="comment">				2. 千万不要为了方便访问数据而使用static修饰成员变量，只有成员变量的数据是真正需要被共享的时候</span></span><br><span class="line"><span class="comment">				才使用static修饰。</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		static修饰成员变量的应用场景： 如果一个数据需要被所有对象共享使用的时候，这时候即可好实用static修饰。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	2. static修饰成员函数:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>	String name;  <span class="comment">//非静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>	<span class="type">String</span>  <span class="variable">country</span>  <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;	  <span class="comment">//静态的成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;狗娃&quot;</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;狗剩&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//System.out.println(&quot;国籍：&quot;+ Student.country);</span></span><br><span class="line">		System.out.println(<span class="string">&quot;名字：&quot;</span>+ s1.name);</span><br><span class="line">		System.out.println(<span class="string">&quot;名字：&quot;</span>+ s2.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>静态成员变量的访问方式：</strong></p>
<p>​              <strong>方式1： 可以使用对象进行访问。</strong></p>
<p>​                  格式： 对象.变量名。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009173248959.png" class="" title="image-20221009173248959">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009173304330.png" class="" title="image-20221009173304330">



<p>​				<strong>方式二： 可以使用类名进行访问。</strong></p>
<p>​                  	格式： 类名.变量名;</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009173354111.png" class="" title="image-20221009173354111">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009173403493.png" class="" title="image-20221009173403493">



<p>注意，static成员（成员变量和成员方法）是属于类的，而不是属于某个对象的。</p>
<p>通过对象去访问static成员实际上仍然是根据对象找到对应的方法区中的类型信息，然后通过类去访问的static成员的。</p>
<p><strong>注意：</strong> </p>
<p>​              <strong>1. 非静态的成员变量只能使用对象进行访问，不能使用类名进行访问否则编译报错。</strong></p>
<p>​              <strong>2. 千万不要为了方便访问数据而使用static修饰成员变量，只有成员变量的数据是真正需要被共享的时候</strong></p>
<p>​              <strong>才使用static修饰。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174243163.png" class="" title="image-20221009174243163">

<p>对普通成员变量，也增加上static了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174332807.png" class="" title="image-20221009174332807">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174340841.png" class="" title="image-20221009174340841">

<p>可以看到，全是同名的了。这就是成员变量使用了static修饰导致的。</p>
<h2 id="static修饰成员变量的应用"><a href="#static修饰成员变量的应用" class="headerlink" title="static修饰成员变量的应用"></a>static修饰成员变量的应用</h2><img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174547961.png" class="" title="image-20221009174547961">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174607476.png" class="" title="image-20221009174607476">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174632110.png" class="" title="image-20221009174632110">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174645210.png" class="" title="image-20221009174645210">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174721287.png" class="" title="image-20221009174721287">



<p>这样为了统计创建的对象个数，不管调用的哪个构造方法，里面都需要写count++，代码冗余了。</p>
<p>因此，将其放到构造代码块。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174745812.png" class="" title="image-20221009174745812">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 统计一个类被使用了多少次创建对象，该类对外显示被创建的次数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//非静态的成员变量。</span></span><br><span class="line">	<span class="keyword">static</span>	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造代码块</span></span><br><span class="line">	&#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">()</span>&#123;  <span class="comment">//每创建一个对象的时候都会执行这里 的代码</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCount</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;创建了&quot;</span>+ count+<span class="string">&quot;个对象&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo11</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Emp</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">		<span class="type">Emp</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">		<span class="type">Emp</span> <span class="variable">e3</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">		e3.showCount();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="static静态成员方法"><a href="#static静态成员方法" class="headerlink" title="static静态成员方法"></a>static静态成员方法</h2><p><strong>静态方法（类方法）</strong></p>
<p>当 static 修饰成员方法时，该方法称为<strong>类方法</strong> 。静态方法在声明中有 static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。</p>
<p><strong>类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名 (参数列表)&#123; </span><br><span class="line">    <span class="comment">// 执行语句 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态方法调用的注意事项：</strong></p>
<p>静态方法可以直接访问类变量（static静态变量）和静态方法。</p>
<p>静态方法不能直接访问普通成员变量或普通成员方法。反之，普通成员方法可以直接访问类变量或静态方法。</p>
<p>静态方法中，不能使用this，super关键字。</p>
<p><strong>静态方法只能访问静态成员。</strong>即静态的只能访问静态的，非静态的可以任意访问。</p>
<p>被static修饰的成员可以并且建议通过类名直接访问。<strong>虽然也可以通过对象名访问静态成员</strong>，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问类变量</span></span><br><span class="line">类名.类变量名；</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">类名.静态方法名(参数)； </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> numStatic; <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个成员方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 成员方法可以访问成员变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="comment">// 成员方法可以访问静态变量</span></span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个静态方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态方法可以访问静态变量</span></span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">        <span class="comment">// 静态不能直接访问非静态【重点】</span></span><br><span class="line"><span class="comment">//        System.out.println(num); // 错误写法！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法中不能使用this关键字。</span></span><br><span class="line"><span class="comment">//        System.out.println(this); // 错误写法！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</span></span><br><span class="line"><span class="comment">如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。</span></span><br><span class="line"><span class="comment">静态变量：类名称.静态变量</span></span><br><span class="line"><span class="comment">静态方法：类名称.静态方法()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 静态不能直接访问非静态。</span></span><br><span class="line"><span class="comment">原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。</span></span><br><span class="line"><span class="comment">“先人不知道后人，但是后人知道先人。”</span></span><br><span class="line"><span class="comment">2. 静态方法当中不能用this。</span></span><br><span class="line"><span class="comment">原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。也就是说，要有这个对象才行，而静态内容初始化的时候，对象还不存在呢。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02StaticMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 首先创建对象</span></span><br><span class="line">        <span class="comment">// 然后才能使用没有static关键字的内容</span></span><br><span class="line">        obj.method();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。</span></span><br><span class="line">        obj.methodStatic(); <span class="comment">// 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”</span></span><br><span class="line">        MyClass.methodStatic(); <span class="comment">// 正确，推荐</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于本类当中的静态方法，可以省略类名称</span></span><br><span class="line">        myMethod();<span class="comment">//与下面等价</span></span><br><span class="line">        Demo02StaticMethod.myMethod(); <span class="comment">// 完全等效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自己的方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非静态方法，称为实例方法。也叫做对象方法。</p>
<p>非静态变量，称为实例变量。也叫做对象属性。</p>
<p>静态方法，在类加载的时候，就给这个静态方法分配了代码空间了，那么这个时候，还没有产生对象呢，那么此时在静态方法中访问实例变量或者实例方法是不行的，因为，实例变量和实例方法是需要先new出一个对象之后，在堆中才会有对应的对象存在的，才能够去使用对象的实例变量和实例方法。因此，静态方法中调用非静态成员变量，就是非法操作。</p>
<p><strong>又因为对于实例方法来说，内部都有this的，指向当前调用者对象，因此，对于static方法来说，就不能够调用它，因为，此时对象还没有呢，那么就没有给this传递的当前调用者对象。</strong></p>
<p>在类加载的时候，意思是说当第一次使用到类的时候，才会对其进行加载，懒惰模式，例如，Student stu;当定义引用变量的时候，那么此时JVM就会将Student类对应的字节码文件加载到方法区中了，此时就加载Student类了，注意，此时没有对象呢。因此，不需要new，只有定义引用变量的操作，那么就会将类进行加载了。此时静态变量，静态代码块，静态方法，都会被加载了。注意，类加载之后，就会一直存在于方法区中的，生命周期直到程序结束。</p>
<p>类变量，类方法，当类加载的时候，它们就已经具有了内存空间了。而非静态方法，要想能够被调用，必须要首先有对象产生，而这个时候，静态成员变量和静态成员方法已经具有了内存空间，因此，就可以调用了。</p>
<p>静态不能够访问非静态。只能访问静态。</p>
<p>非静态可以访问静态，以及非静态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意，main方法也是静态方法，在c/c++中也有main方法，但是它不是属于某个类的，它是一个全局的main方法，</span><br><span class="line">因此，当执行程序的时候，c++编译器很容易就能够找到这个main方法。</span><br><span class="line">而java程序的执行时，它都是以类作为程序的组织单元，当执行的时候，不知道这个main方法在哪个类中，也不知道是否要产生一个这个类的对象，</span><br><span class="line">因此，为了解决程序的运行问题，将这个main定义为<span class="keyword">static</span>，这样当执行java代码的时候，输入java Point的时候，那么首先就是找到对应的Point.class字节码文件，然后将其加载到内存中方法区中，然后解开，然后找到类Point，然后就会在这个类中去调用这个静态的main方法，加载到方法调用栈上去执行了，而不需要产生Point这个类的对象。</span><br><span class="line">当加载Point这个类的时候（即java Point的时候，就会加载该类），这个main方法就被加载了（因此是先加载的类，然后才会执行main），</span><br><span class="line">作为java程序的入口函数。而如果不是<span class="keyword">static</span>的main，那么就需要首先产生一个Point的对象，才能够调用这个main。这样程序没法运行了。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于静态变量，由于它是属于类的，因此，所有的类对象，都是共享同一个静态变量的。静态方法也是同理，所有对象都共享同一个静态方法。</span><br><span class="line">对于非静态方法，它实际上在内存中也只是存在一份拷贝，但是仍然要区分静态方法和非静态方法。虽然都存放在方法区的字节码位置上，但是仍然要区分开。</span><br><span class="line">静态变量，通常可以用来做统计计数。因为多个对象用的是同一个变量。</span><br></pre></td></tr></table></figure>



<h2 id="static内存原理图"><a href="#static内存原理图" class="headerlink" title="static内存原理图"></a>static内存原理图</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03StaticStudent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先设置一下教室，这是静态的东西，应该通过类名称进行调用</span></span><br><span class="line">        Student.room = <span class="string">&quot;101教室&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭靖&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;one的姓名：&quot;</span> + one.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;one的年龄：&quot;</span> + one.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;one的教室：&quot;</span> + Student.room);</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;黄蓉&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;two的姓名：&quot;</span> + two.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;two的年龄：&quot;</span> + two.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;two的教室：&quot;</span> + Student.room);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009214657924.png" class="" title="image-20221009214657924">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009214722518.png" class="" title="image-20221009214722518">



<p><strong>static 修饰的内容：</strong><br><strong>是随着类的加载而加载的，且只加载一次。</strong></p>
<p>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</p>
<p>它优先于对象存在，所以，可以被所有对象共享。</p>
<p>注意，静态区是存放在方法区中的。</p>
<p>注意，即使使用对象.静态变量，这样访问，实际上编译之后，也是将其翻译成了通过类去找静态变量的。因此，也是直接到方法区中的类的class文件中找到static内容的地址，然后根据地址找到静态区中的值。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009215144863.png" class="" title="image-20221009215144863">

<hr>
<h2 id="static静态代码块"><a href="#static静态代码块" class="headerlink" title="static静态代码块"></a>static静态代码块</h2><p><strong>静态代码块：定义在成员位置，使用static修饰的代码块{ }。</strong></p>
<p><strong>位置：类中，方法外。</strong></p>
<p><strong>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 执行语句 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：给类变量进行初始化赋值。</p>
<p>static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。下面说的两个工具类，就体现static 方法的便利。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态代码块的格式是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public class 类名称 &#123;</span></span><br><span class="line"><span class="comment">    static &#123;</span></span><br><span class="line"><span class="comment">        // 静态代码块的内容</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特点：当第一次用到本类时，静态代码块执行唯一的一次。</span></span><br><span class="line"><span class="comment">静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">静态代码块的典型用途：</span></span><br><span class="line"><span class="comment">用来一次性地对静态成员变量进行赋值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Static</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//如果这里根本就没有写Person类，那么右键运行，Person类是不会被加载的，那么里面的static代码块也不会被执行的。</span></span><br><span class="line">		<span class="comment">//static代码块以及静态的变量，静态的方法，都是在类被加载的时候，只被执行一次，也就是只会加载一次，后续使用这个类的全程中不会再次执行的。</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		输出结果：</span></span><br><span class="line"><span class="comment">			静态代码块执行！</span></span><br><span class="line"><span class="comment">			构造方法执行！</span></span><br><span class="line"><span class="comment">			构造方法执行！</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		i=<span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009220716026.png" class="" title="image-20221009220716026">

<p>可以看到，编译之后，对代码进行了重整，将静态的i声明放在了类体最前面。然后将静态变量显示初始化和静态代码块中的初始化，通通放到了静态代码块中来做了，按照书写顺序从上到下执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		i=<span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009220933717.png" class="" title="image-20221009220933717">

<p>可以看到，在静态代码块中使用的i是在后面声明定义的，没有报错，原因就是编译之后，对代码重整了，将i的声明放到了最前面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		i=<span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		f=<span class="number">36.7f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">float</span> f=<span class="number">23.5f</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代码块，静态变量显示初始化，构造代码块，实例变量显示初始化。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009221525565.png" class="" title="image-20221009221525565">

<p>可以看到将静态变量声明放在了最前面，然后才是实例变量的声明。</p>
<p>静态变量显示初始化和静态代码块初始化，最后通通放在了静态代码块中了，且按照书写顺序从上到下。</p>
<p>实例变量显示初始化和构造代码块初始化，最后通通放在了构造函数中了，且按照书写顺序从上到下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		i=<span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> f=<span class="number">23.5f</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		f=<span class="number">36.7f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//float f=23.5f;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009221831743.png" class="" title="image-20221009221831743">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>（静态、修饰符）</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>修饰成员变量时：<span class="keyword">static</span>修饰成员变量时,那么该成员变量的数据就是一个共享的数据.</span><br><span class="line">	</span><br><span class="line">		静态成员变量的访问方式：</span><br><span class="line">			</span><br><span class="line">				方式一： 使用对象进行访问。</span><br><span class="line">						对象.属性名</span><br><span class="line">				方式二：可以使用类名进行访问。</span><br><span class="line">						类名.属性名</span><br><span class="line">		注意：</span><br><span class="line">			<span class="number">1.</span> 非静态成员变量不能类名直接访问，只能使用对象进行访问。</span><br><span class="line">			<span class="number">2.</span> 千万不要为了方便访问成员变量而使用<span class="keyword">static</span>修饰，一定要是该数据是共享数据 时才使用<span class="keyword">static</span>修饰。</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>修饰方法（静态的成员方法）:</span><br><span class="line">		</span><br><span class="line">		访问方式：</span><br><span class="line">			</span><br><span class="line">			方式一：可以使用对象进行访问。</span><br><span class="line">					对象.静态的函数名();</span><br><span class="line"></span><br><span class="line">			方式二：可以使用类名进行访问。</span><br><span class="line">					类名.静态函数名字。</span><br><span class="line">		</span><br><span class="line">		推荐使用是类名直接访问静态的成员。不推荐使用对象来访问，因为使用对象访问静态的成员，首先还需要创建出一个对象来，浪费了内存了。因此，直接通过类名访问，节省内存。</span><br><span class="line">注意，这里面所说的成员，就包括了成员变量与成员方法了，下面也同理。</span><br><span class="line"></span><br><span class="line">静态函数要注意的事项：</span><br><span class="line">	<span class="number">1.</span> 静态函数是可以调用类名或者对象进行调用的，而非静态函数只能使用对象进行调用。</span><br><span class="line">	<span class="number">2.</span> 静态的函数可以直接访问静态的成员，但是不能直接访问非静态的成员。	</span><br><span class="line">		原因：静态函数是可以使用类名直接调用的，这时候可能还没有存在对象，</span><br><span class="line">		而非静态的 成员数据是随着对象 的存在而存在的。</span><br><span class="line"></span><br><span class="line">	<span class="number">3.</span> 非静态的函数是可以直接访问静态与非静态的成员。</span><br><span class="line">		原因：非静态函数只能由对象调用，当对象存在的时候，静态数据老早就已经存在了，而非静态数据也随着对象的创建而存在了。</span><br><span class="line"></span><br><span class="line">	<span class="number">4.</span> 静态函数不能出现<span class="built_in">this</span>或者<span class="built_in">super</span>关键字。非静态的函数中可以有<span class="built_in">this</span>和<span class="built_in">super</span>关键字。</span><br><span class="line">		原因：因为静态的函数是可以使用类名调用的，一旦使用类名调用这时候不存在对象，而<span class="built_in">this</span></span><br><span class="line">		关键字是代表了一个函数 的调用者对象，这时候产生了冲突。</span><br><span class="line"></span><br><span class="line">静态的数据的生命周期：静态的成员变量数据是优先于对象存在的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222603907.png" class="" title="image-20221009222603907">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222612438.png" class="" title="image-20221009222612438">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222622461.png" class="" title="image-20221009222622461">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222629942.png" class="" title="image-20221009222629942">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222645436.png" class="" title="image-20221009222645436">

<p>构造代码块与普通的成员变量，都是在创建对象的时候，就会被执行了。</p>
<p>而加上了static，如下</p>
<p>Static {</p>
<p>}</p>
<p>Static String name;</p>
<p>这样就是在类加载的时候，就会被执行了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222801481.png" class="" title="image-20221009222801481">

<p><strong>对于static成员变量和static代码块，是按照从上到下的顺序来执行的。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222830815.png" class="" title="image-20221009222830815">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222835840.png" class="" title="image-20221009222835840">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222958985.png" class="" title="image-20221009222958985">

<p>可以看到，static代码块和static成员变量是按照从上到下顺序执行的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009223015917.png" class="" title="image-20221009223015917">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009223055377.png" class="" title="image-20221009223055377">

<p>可以看到，这里6行报错，7行正确。原因是编译之后，代码重整，会将10行的作为声明，static int i;提到最前面。然后在static代码块中进行统一初始化都是没有问题的，但是不能直接使用静态变量i，使用的话，就都会报错。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009224703914.png" class="" title="image-20221009224703914">

<p><strong>如图，只要在静态代码块中使用了i就会报错，但是统一初始化就没有问题。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225013336.png" class="" title="image-20221009225013336">

<p>如图，b的作用域就是在static静态代码块中了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225201311.png" class="" title="image-20221009225201311">

<p>静态代码块中不能再使用static关键字了。只能使用final关键字。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225328188.png" class="" title="image-20221009225328188">

<p>静态代码块中使用final没问题，但是后续只能使用它，不能再对其修改了。因此，如果不使用final，那么在静态代码块作用域内就可以修改b了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态的成员变量与非静态的成员变量的区别：</span><br><span class="line">	<span class="number">1.</span> 作用上的区别：</span><br><span class="line">		<span class="number">1.</span> 静态的成员变量的作用共享一个 数据给所有的对象使用。</span><br><span class="line">		<span class="number">2.</span> 非 静态的成员变量的作用是描述一类事物的公共属性。</span><br><span class="line">	<span class="number">2.</span> 数量与存储位置上的区别：</span><br><span class="line">		<span class="number">1.</span> 静态成员变量是存储方法 区内存中，而且只会存在一份数据。</span><br><span class="line">		<span class="number">2.</span> 非静态的成员变量是存储在堆内存中，有n个对象就有n份数据。</span><br><span class="line">	<span class="number">3.</span> 生命周期的区别：</span><br><span class="line">		<span class="number">1.</span> 静态的成员变量数据是随着类的加载而存在，随着类文件的消失而消失，一般都是程序执行结束之后，加载的类文件才会卸载掉。</span><br><span class="line">		<span class="number">2.</span>非静态的成员数据是随着对象的创建而存在，随着 对象被垃圾回收器回收而消失。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span>什么时候修饰一个函数？</span><br><span class="line">	如果一个函数没有直接访问到非静态的成员时，那么就可以使用<span class="keyword">static</span>修饰了。 一般用于工具类型的方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>静态函数不能访问非静态的成员？注意，这里没说是直接访问。</p>
<p>​     静态函数只要存在有对象，那么也可以访问非 静态的数据。只是不能<strong>直接</strong>访问而已。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225659495.png" class="" title="image-20221009225659495">

<p>注意，这个this代表的是，调用sleep函数的那个对象，而不是s这个对象的。</p>
<p><strong>Static静态函数中，不能使用this和super。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225851529.png" class="" title="image-20221009225851529">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225858996.png" class="" title="image-20221009225858996">

<p>当执行这个，就要执行Demo2类的代码了，此时就要执行Demo2类中的main方法了。此时jvm就会将Demo2.class文件加载到内存中，加载到方法区中，此时还不会加载Student.class，因为还没有执行到Student语句呢，还没要使用Student这个类，jvm采用的是懒惰型加载，只有用到了某个类的时候，才会进行加载。当加载了Demo2.class文件到内存的方法区之后，就会将这个文件解剖，看里面有哪些成员，发现只有一个main方法，此时就看到了main方法的字节码了，就放在方法区中那个位置了，然后要执行main方法，由于这个main方法在方法区中，只是一个字节码而已，也就是代码而已，没有执行的呢，因此，此时main要执行，jvm就将方法区中的main方法的代码，加载到栈内存中，此时jvm会在栈内存中开辟一个空间，给这个main方法来用，此时main在栈中开始执行，执行的第一条语句就是Student那个语句，此时就要用到Student了，此时，jvm就将Student.class加载到方法区中，然后解剖这个class文件，看里面有哪些成员方法，有哪些成员变量，此时就看到Student.class文件中，有sleep()，study()方法，还发现里面有一个静态的成员变量country，然后会将这个静态的成员变量country，放到方法区中的静态数据共享区中，也就是静态的成员变量都放到了静态数据共享区中了。因此，静态变量，静态方法，是在class文件加载到内存中的时候，就已经有了。但是此时对象还没有呢，name成员变量也就没有呢。</p>
<p>然后要执行sleep()方法，那么就将sleep()代码加载到栈内存中，开始执行sleep()方法。</p>
<p>然后执行main中的Student s &#x3D; new Student(“狗娃”)，此时需要new Student，那么此时不会重新加载这个Student.class了，因为类文件加载过一次之后，在这个程序跑完之前，这个类文件是不会被卸载掉的了，因此，会使用之前加载过的这个Student.class了，来在堆内存中创建对象，然后才有实例变量name。</p>
<p>注意，类文件xx.class只要被jvm加载了，那么就只有等到整个程序执行结束了之后，才会卸载了，整个过程中，是不会卸载掉这个class文件的。</p>
<p>注意，一个方法执行完毕之后，那么这个方法在栈内存中所占用的空间就会马上被释放掉。因此，sleep()执行完毕之后，那么在栈内存中的空间就会马上释放掉。</p>
<p>注意，方法区中的Demo2.class字节码，以及里面的main方法字节码，是一直会加载在方法区中的，直到整个程序执行完毕，才会释放的。生命周期是加载到内存中之后直到整个程序执行完毕。</p>
<p>静态成员是在类加载的时候，执行，因此，它只被执行一次的。</p>
<p>注意，静态方法与非静态方法的字节码文件是同时存在内存中的。 只是静态的成员变量数据是优先于对象存在而已。</p>
<p>因为方法，都是字节码，都是在方法区中的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009230322413.png" class="" title="image-20221009230322413">

<p>方法区中的存放的都是字节码而已，就是代码而已，没有被执行的，死的。因此，只要class文件加载了，那么不管是静态方法还是非静态方法，它们的代码就都在方法区中了。而只有执行了这个方法，也就是调用了这个方法的时候，这个方法的代码（字节码）才会放到栈内存中去执行了。</p>
<p> 因此，对于非静态方法来说，它也是优先于对象而存在的，因为加载了class文件，那么非静态方法就在方法区中了。</p>
<p> <strong>This，代表调用者，也就是调用某个函数的那个对象。</strong></p>
<p> 对于非静态方法来说，调用它只能通过对象，那么此时对象就已经存在了，那么此时静态的成员变量老早就有了，同时实例变量也随着对象的创建而存在了的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name; <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>	<span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>; <span class="comment">//国籍</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态代码块 ：静态代码块是在Student.class文件加载到内存的时候就马上执行的。</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;静态代码块执行了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//非静态的成员函数</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;好好学习&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;  <span class="comment">//静态方法与非静态方法的字节码文件是同时存在内存中 的。 只是静态的成员变量数据是优先于对象存在而已。</span></span><br><span class="line">		Student s= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;铁蛋&quot;</span>);</span><br><span class="line">		System.out.println(s.name+<span class="string">&quot;呼呼大睡...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		Student.sleep();</span><br><span class="line">	<span class="comment">//	Student s = new Student(&quot;狗娃&quot;);</span></span><br><span class="line">	<span class="comment">//  s.sleep();//通过对象能够访问静态方法。</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>10-main方法&amp;工具类</title>
    <url>/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&amp;%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="10-main方法-amp-工具类"><a href="#10-main方法-amp-工具类" class="headerlink" title="10-main方法&amp;工具类"></a>10-main方法&amp;工具类</h1><h2 id="static成员变量默认值（补充）"><a href="#static成员变量默认值（补充）" class="headerlink" title="static成员变量默认值（补充）"></a>static成员变量默认值（补充）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="comment">//final int b=200;</span></span><br><span class="line">		<span class="comment">//System.out.println(i);</span></span><br><span class="line">		<span class="comment">//i=20;</span></span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">		<span class="comment">//b=300;</span></span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> f=<span class="number">23.5f</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		f=<span class="number">36.7f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//float f=23.5f;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void display()&#123;</span></span><br><span class="line"><span class="comment">//		System.out.println(b);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>0</p>
<p><strong>因此，对于静态成员变量也是有默认值的。</strong></p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010100801599.png" class="" title="image-20221010100801599">

<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010100855545.png" class="" title="image-20221010100855545">

<p>上节已经说过，对于静态成员变量，如果在static代码块后面声明定义的，那么编译之后代码会重整，将static int i;这种声明提到类体最前面，然后静态代码块中只能对静态成员变量进行统一的初始化操作，即会将13行的初始化操作放入到static代码块中，但是在静态代码块中不能够直接使用这个静态成员变量，否则就会报错。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010101228790.png" class="" title="image-20221010101228790">

<p>充分说明static代码块中只能对static成员变量进行统一初始化，不能直接使用（当static成员变量定义在了static代码块后面的时候）。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010101406272.png" class="" title="image-20221010101406272">

<p>static成员变量，定义在static代码块前面的情况下就不会有这些问题。</p>
<hr>
<h2 id="main入口方法"><a href="#main入口方法" class="headerlink" title="main入口方法"></a>main入口方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main函数的详解：</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	public ： 公共的。 权限是最大，在任何情况下都可以访问。 不能使用private  </span></span><br><span class="line"><span class="comment">		原因： 为了保证让jvm在任何情况下都可以访问到main方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	static:  静态。静态可以让jvm调用main函数的时候更加的方便。不需要通过对象调用。</span></span><br><span class="line"><span class="comment">		不使用static的麻烦：</span></span><br><span class="line"><span class="comment">1.	需要创建对象调用。</span></span><br><span class="line"><span class="comment">2.	Jvm不知道如何创建对象，因为创建对象有些是需要参数的，参数传递什么东西呢？因为，我们没有办法人为指定参数，JVM不知道参数传什么。</span></span><br><span class="line"><span class="comment">	void:  没有返回值。 因为返回的数据是 给 jvm，而jvm使用这个数据是没有意义的。所以就不要了。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	main: 函数名。   注意： main并不是关键字,只不过是jvm能识别的一个特殊的函数名而已。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	arguments ：担心某些程序在启动需要参数。即某些程序可能启动的时候需要传入一些参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;数组的长度：&quot;</span>+ args.length);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;args.length ; i++)&#123;</span><br><span class="line">			System.out.print(args[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Args这个参数是只有运行程序那个时候，一次让用户输入的信息的，而且没有提示信息的。</p>
<p>而使用Scanner的话，可以程序过程中，任何时候，让用户输入数据的，而且还可以给用户提示输入什么信息。</p>
<p>因此，Scanner更加灵活的，args让用户输入信息这个现在很少有人用了。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010095122718.png" class="" title="image-20221010095122718">

<p>这个是jvm的启动文件，因此，jvm也是一个程序的。</p>
<p>因此，为了main能够让jvm这个程序调用到，也就是jvm在任何情况下都能够访问到这个main函数，因此，需要将main设置为public的。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010095328635.png" class="" title="image-20221010095328635">

<p>如果是private的话，那么出了这个类，外部就无法访问这个main了。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010095355172.png" class="" title="image-20221010095355172">

<p>如果只是使用无参的构造方法来创建对象，那么jvm是可以做到的。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010100330937.png" class="" title="image-20221010100330937">

<p>而如果这个类没有无参的构造方法，只有有参的构造方法，那么jvm不知道传递什么参数给这个构造方法的，因此，就没法创建对象了，也就没法调用main方法了。</p>
<p>因此，jvm为了避免这种情况，就定义main方法必须是static的了。</p>
<hr>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="自定义工具类"><a href="#自定义工具类" class="headerlink" title="自定义工具类"></a>自定义工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求：编写一个数组的工具类。</span></span><br><span class="line"><span class="comment">	Arrays.toString（）   [1,2,3,4];</span></span><br><span class="line"><span class="comment">	sort()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayTool</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span>  <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  i &lt; arr.length ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">				result+=<span class="string">&quot;[&quot;</span>+arr[i]+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==(arr.length-<span class="number">1</span>))&#123;</span><br><span class="line">				result+= arr[i]+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				result+=arr[i]+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span> ; j&lt;arr.length ; j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">					arr[i] = arr[j];</span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">456</span>,<span class="number">165</span>&#125;;</span><br><span class="line">		<span class="comment">//ArrayTool tool = new ArrayTool();</span></span><br><span class="line"></span><br><span class="line">		ArrayTool.sort(arr);</span><br><span class="line">		<span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> ArrayTool.toString(arr);</span><br><span class="line">		System.out.println(<span class="string">&quot;数组的元素：&quot;</span>+ info);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上就是<span class="keyword">static</span>修饰方法的应用场景，用于工具类。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3...]）</span></span><br><span class="line"><span class="comment">public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">备注：</span></span><br><span class="line"><span class="comment">1. 如果是数值，sort默认按照升序从小到大</span></span><br><span class="line"><span class="comment">2. 如果是字符串，sort默认按照字母升序</span></span><br><span class="line"><span class="comment">3. 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（后续章节介绍）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Arrays</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] intArray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="comment">// 将int[]数组按照默认格式变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">intStr</span> <span class="operator">=</span> Arrays.toString(intArray);</span><br><span class="line">        System.out.println(intStr); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        Arrays.sort(array1);</span><br><span class="line">        System.out.println(Arrays.toString(array1)); <span class="comment">// [1, 2, 3, 6, 10]</span></span><br><span class="line"></span><br><span class="line">        String[] array2 = &#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(array2);</span><br><span class="line">        System.out.println(Arrays.toString(array2)); <span class="comment">// [aaa, bbb, ccc]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">请使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02ArraysPractise</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;asv76agfqwdfvasdfvjh&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何进行升序排列：sort</span></span><br><span class="line">        <span class="comment">// 必须是一个数组，才能用Arrays.sort方法</span></span><br><span class="line">        <span class="comment">// String --&gt; 数组，用toCharArray</span></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars); <span class="comment">// 对字符数组进行升序排列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chars.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Math工具类"><a href="#Math工具类" class="headerlink" title="Math工具类"></a>Math工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static double abs(double num)：获取绝对值。有多种重载。</span></span><br><span class="line"><span class="comment">public static double ceil(double num)：向上取整。</span></span><br><span class="line"><span class="comment">public static double floor(double num)：向下取整。</span></span><br><span class="line"><span class="comment">public static long round(double num)：四舍五入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Math.PI代表近似的圆周率常量（double）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Math</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取绝对值</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">3.14</span>)); <span class="comment">// 3.14</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">2.5</span>)); <span class="comment">// 2.5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.9</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.1</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.0</span>)); <span class="comment">// 3.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下取整，抹零</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">30.1</span>)); <span class="comment">// 30.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">30.9</span>)); <span class="comment">// 30.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">31.0</span>)); <span class="comment">// 31.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Math.round(<span class="number">20.4</span>)); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.5</span>)); <span class="comment">// 11</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//[0.0,1.0)之间的伪随机double值</span></span><br><span class="line">        <span class="comment">//random()   产生一个随机数. 大于等于 0.0 且小于 1.0 的伪随机 double 值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;随机数：&quot;</span>+Math.random());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010160013469.png" class="" title="image-20221010160013469">

<p><strong>获取到的是[0.0,1.0)之间的伪随机double值。</strong></p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010160026036.png" class="" title="image-20221010160026036">

<p>这个random方法不是很好用，例如，如果获取0-10之间的随机数，那么它还得乘以10，然后取整才行。</p>
<p>Ceil是天花板的意思，所以是向上取整。</p>
<p>获取随机数，我们一般使用Random这个类来获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">计算在-10.8到5.9之间，绝对值大于6或者小于2.1的整数有多少个？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 既然已经确定了范围，for循环</span></span><br><span class="line"><span class="comment">2. 起点位置-10.8应该转换成为-10，两种办法：</span></span><br><span class="line"><span class="comment">    2.1 可以使用Math.ceil方法，向上（向正方向）取整</span></span><br><span class="line"><span class="comment">    2.2 强转成为int，自动舍弃所有小数位</span></span><br><span class="line"><span class="comment">3. 每一个数字都是整数，所以步进表达式应该是num++，这样每次都是+1的。</span></span><br><span class="line"><span class="comment">4. 如何拿到绝对值：Math.abs方法。</span></span><br><span class="line"><span class="comment">5. 一旦发现了一个数字，需要让计数器++进行统计。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">备注：如果使用Math.ceil方法，-10.8可以变成-10.0。注意double也是可以进行++的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04MathPractise</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 符合要求的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> -<span class="number">10.8</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">5.9</span>;</span><br><span class="line">        <span class="comment">// 这样处理，变量i就是区间之内所有的整数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) min; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">abs</span> <span class="operator">=</span> Math.abs(i); <span class="comment">// 绝对值</span></span><br><span class="line">            <span class="keyword">if</span> (abs &gt; <span class="number">6</span> || abs &lt; <span class="number">2.1</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;总共有：&quot;</span> + count); <span class="comment">// 9</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>11-常用API之Scanner&amp;Random</title>
    <url>/2022/10/10/Java/JavaSE/11-%E5%B8%B8%E7%94%A8API%E4%B9%8BScanner&amp;Random/</url>
    <content><![CDATA[<h1 id="11-常用API之Scanner-amp-Random-amp-ArrayList"><a href="#11-常用API之Scanner-amp-Random-amp-ArrayList" class="headerlink" title="11-常用API之Scanner&amp;Random&amp;ArrayList"></a>11-常用API之Scanner&amp;Random&amp;ArrayList</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。</p>
<p><strong>API使用步骤</strong></p>
<ol>
<li>打开帮助文档。</li>
<li>点击显示，找到索引，看到输入框。</li>
<li>你要找谁？在输入框里输入，然后回车。</li>
<li>看包。<strong>java.lang下的类不需要导包，自动导入的，其他需要。</strong></li>
<li>看类的解释和说明。</li>
<li>学习构造方法。</li>
<li>使用成员方法。</li>
</ol>
<h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><p><strong>Scanner类：一个可以解析基本类型和字符串的简单文本扫描器。</strong> 例如，以下代码使用户能够从 System.in 中读取一个数。</p>
<p>提示：System.in 系统输入指的是通过键盘录入数据。</p>
<p><strong>Scanner使用步骤</strong></p>
<p><strong>查看类</strong></p>
<p>java.util.Scanner ：该类需要import导入后使用。</p>
<p><strong>查看构造方法</strong></p>
<p>public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。</p>
<p><strong>查看成员方法</strong></p>
<p>public int nextInt() ：将输入信息的下一个标记扫描为一个 int 值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 1. 导包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Scanner类的功能：可以实现键盘输入数据，到程序当中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">引用类型的一般使用步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 导包</span></span><br><span class="line"><span class="comment">import 包路径.类名称;</span></span><br><span class="line"><span class="comment">如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。</span></span><br><span class="line"><span class="comment">只有java.lang包下的内容不需要导包（自动导入的），其他的包都需要import语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 创建</span></span><br><span class="line"><span class="comment">类名称 对象名 = new 类名称();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 使用</span></span><br><span class="line"><span class="comment">对象名.成员方法名()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">获取键盘输入的一个int数字：int num = sc.nextInt();//当执行到nextInt的时候，程序会阻塞在这里，等待用户输入</span></span><br><span class="line"><span class="comment">获取键盘输入的一个字符串：String str = sc.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Scanner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 创建</span></span><br><span class="line">        <span class="comment">// 备注：System.in代表从键盘进行输入，表示标准输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//将Scanner对象和标准输入对象关联</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取键盘输入的int数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//程序执行到这里会阻塞，等待用户输入内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入的int数字是：&quot;</span> + num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取键盘输入的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的字符串是：&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>练习</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">键盘输入两个int数字，并且求出和值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 既然需要键盘输入，那么就用Scanner</span></span><br><span class="line"><span class="comment">2. Scanner的三个步骤：导包、创建、使用</span></span><br><span class="line"><span class="comment">3. 需要的是两个数字，所以要调用两次nextInt方法</span></span><br><span class="line"><span class="comment">4. 得到了两个数字，就需要加在一起。</span></span><br><span class="line"><span class="comment">5. 将结果打印输出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02ScannerSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">键盘输入三个int数字，然后求出其中的最大值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 既然是键盘输入，肯定需要用到Scanner</span></span><br><span class="line"><span class="comment">2. Scanner三个步骤：导包、创建、使用nextInt()方法</span></span><br><span class="line"><span class="comment">3. 既然是三个数字，那么调用三次nextInt()方法，得到三个int变量</span></span><br><span class="line"><span class="comment">4. 无法同时判断三个数字谁最大，应该转换成为两个步骤：</span></span><br><span class="line"><span class="comment">    4.1 首先判断前两个当中谁最大，拿到前两个的最大值</span></span><br><span class="line"><span class="comment">    4.2 拿着前两个中的最大值，再和第三个数字比较，得到三个数字当中的最大值</span></span><br><span class="line"><span class="comment">5. 打印最终结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03ScannerMax</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第三个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先得到前两个数字当中的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a &gt; b ? a : b;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> temp &gt; c ? temp : c;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值是：&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用匿名对象方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Anonymous</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通使用方式</span></span><br><span class="line"><span class="comment">//        Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        int num = sc.nextInt();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名对象的方式</span></span><br><span class="line"><span class="comment">//        int num = new Scanner(System.in).nextInt();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;输入的是：&quot; + num);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一般写法传入参数</span></span><br><span class="line"><span class="comment">//        Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        methodParam(sc);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用匿名对象来进行传参</span></span><br><span class="line"><span class="comment">//        methodParam(new Scanner(System.in));</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> methodReturn();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的是：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodParam</span><span class="params">(Scanner sc)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的是：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title function_">methodReturn</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        return sc;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//使用匿名对象作为方法的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>Random类：生成伪随机数。</p>
<p><strong>Random使用步骤：</strong></p>
<p><strong>查看类</strong></p>
<p>java.util.Random ：该类需要 import导入使后使用。</p>
<p><strong>查看构造方法</strong></p>
<p>public Random() ：创建一个新的随机数生成器。</p>
<p><strong>查看成员方法</strong></p>
<p>public int nextInt(int n) ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的int 值。<strong>左闭右开的。</strong></p>
<p><strong>提示：</strong>创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数。</p>
<img src="/2022/10/10/Java/JavaSE/11-%E5%B8%B8%E7%94%A8API%E4%B9%8BScanner&Random/image-20221010160621306.png" class="" title="image-20221010160621306">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Random类用来生成随机数字。使用起来也是三个步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 导包</span></span><br><span class="line"><span class="comment">import java.util.Random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 创建</span></span><br><span class="line"><span class="comment">Random r = new Random(); // 小括号当中留空即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 使用</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（范围是int类型的所有范围，有正负两类数字）：int num = r.nextInt()</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（参数代表了范围，左闭右开区间）：int num = r.nextInt(3)</span></span><br><span class="line"><span class="comment">实际上代表的含义是：[0,3)，也就是0~2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Random</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;随机数是：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">//生成100个0到10之间的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Random</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>); <span class="comment">// 范围实际上是0~9</span></span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：</span></span><br><span class="line"><span class="comment">根据int变量n的值，来获取随机数字，范围是[1,n]，可以取到1也可以取到n。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 定义一个int变量n，随意赋值</span></span><br><span class="line"><span class="comment">2. 要使用Random：三个步骤，导包、创建、使用</span></span><br><span class="line"><span class="comment">3. 如果写10，那么就是0~9，然而想要的是1~10，可以发现：整体+1即可。</span></span><br><span class="line"><span class="comment">4. 打印随机数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Random</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 本来范围是[0,n)，整体+1之后变成了[1,n+1)，也就是[1,n]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> r.nextInt(n) + <span class="number">1</span>;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">用代码模拟猜数字的小游戏。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 首先需要产生一个随机数字，并且一旦产生不再变化。用Random的nextInt方法</span></span><br><span class="line"><span class="comment">2. 需要键盘输入，所以用到了Scanner</span></span><br><span class="line"><span class="comment">3. 获取键盘输入的数字，用Scanner当中的nextInt方法</span></span><br><span class="line"><span class="comment">4. 已经得到了两个数字，判断（if）一下：</span></span><br><span class="line"><span class="comment">    如果太大了，提示太大，并且重试；</span></span><br><span class="line"><span class="comment">    如果太小了，提示太小，并且重试；</span></span><br><span class="line"><span class="comment">    如果猜中了，游戏结束。</span></span><br><span class="line"><span class="comment">5. 重试就是再来一次，循环次数不确定，用while(true)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04RandomGame</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>) + <span class="number">1</span>; <span class="comment">// [1,100]</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你猜测的数字：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">guessNum</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 键盘输入猜测的数字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessNum &gt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;太大了，请重试。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guessNum &lt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;太小了，请重试。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;恭喜你，猜中啦！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果猜中，不再重试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;游戏结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提示：while中的定义的guessNum是一个局部变量，出了while之后，就无法使用了，看不到。</strong></p>
<h3 id="验证码案例"><a href="#验证码案例" class="headerlink" title="验证码案例"></a>验证码案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.other;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">随机数类</span></span><br><span class="line"><span class="comment">Random</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求： 编写一个函数随机产生四位的验证码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Random random = new Random();</span></span><br><span class="line"><span class="comment">		int randomNum = random.nextInt(10)+1; //产生 的 随机数就是1-10之间</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;随机数：&quot;+ randomNum);</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="type">char</span>[] arr = &#123;<span class="string">&#x27;中&#x27;</span>,<span class="string">&#x27;国&#x27;</span>,<span class="string">&#x27;传&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="comment">//需要四个随机数，通过随机数获取字符数组中的字符，</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">0</span> ; i&lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(arr.length);  <span class="comment">//产生的 随机数必须是数组的索引值范围之内的。</span></span><br><span class="line">			sb.append(arr[index]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;验证码：&quot;</span>+ sb);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/10/10/Java/JavaSE/11-%E5%B8%B8%E7%94%A8API%E4%B9%8BScanner&Random/image-20221010160933262.png" class="" title="image-20221010160933262">

<p>这就是验证码生成的方式。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>13-再谈继承与多态</title>
    <url>/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="13-再谈继承与多态"><a href="#13-再谈继承与多态" class="headerlink" title="13-再谈继承与多态"></a>13-再谈继承与多态</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo6.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在现实生活中事物与事物之间是存在关系.</span></span><br><span class="line"><span class="comment">	球员----&gt;球队  整体与部分关系   has a 关系  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	学生-----&gt;人    继承的关系      is a 关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//球员类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> num; <span class="comment">//编码</span></span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Player</span><span class="params">(<span class="type">int</span> num , String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.num = num;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;开跑...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//球队类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Team</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;  <span class="comment">//球队的名字</span></span><br><span class="line"></span><br><span class="line">	Player p1;  <span class="comment">//球员1</span></span><br><span class="line"> </span><br><span class="line">	Player p2;   <span class="comment">//球员2</span></span><br><span class="line"></span><br><span class="line">	Player p3;  <span class="comment">//球员3</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Team</span><span class="params">(String name,Player p1,Player p2,Player p3)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.p1 = p1;</span><br><span class="line">		<span class="built_in">this</span>.p2 = p2;</span><br><span class="line">		<span class="built_in">this</span>.p3 = p3;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//开始比赛</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startGame</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;开赛啦！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo6</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Player</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="number">12</span>,<span class="string">&quot;梅西&quot;</span>);</span><br><span class="line">		<span class="type">Player</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="number">7</span>,<span class="string">&quot;C罗&quot;</span>);</span><br><span class="line">		<span class="type">Player</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="number">11</span>,<span class="string">&quot;内马尔&quot;</span>);</span><br><span class="line">		<span class="comment">//球队</span></span><br><span class="line">		<span class="type">Team</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Team</span>(<span class="string">&quot;恒大&quot;</span>,p1,p2,p3);</span><br><span class="line">		t.startGame();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;名字：&quot;</span>+ t.p2.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo7.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目前存在的问题：</span></span><br><span class="line"><span class="comment">	1. 无法描述清楚这两个类之间的继承关系。</span></span><br><span class="line"><span class="comment">	2. 存在着重复代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">面向对象的三大特征：</span></span><br><span class="line"><span class="comment">	1. 封装</span></span><br><span class="line"><span class="comment">	2. 继承</span></span><br><span class="line"><span class="comment">	3. 多态.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承：继承是通过关键字extends体现的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承的格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	class 类名1 extends 类名2&#123;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承要注意的事项：</span></span><br><span class="line"><span class="comment">	1. 千万不要为了减少重复代码而去继承，只有真正存在着继承关系的时候才去继承。</span></span><br><span class="line"><span class="comment">	2. 父类私有的成员不能被继承。</span></span><br><span class="line"><span class="comment">	3. 父类的构造函数不能被继承。</span></span><br><span class="line"><span class="comment">	4. 创建子类对象时默认会先调用父类无参的构造函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//人类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Person类的构造方法被调用了....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;在吃饭...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;  <span class="comment">// Student 就称作为Person类的子类， Person类就称作为Student的父类(超类、基类)</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student类的构造方法被调用了....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;good good study , day day up&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo7</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		s.name = &quot;狗娃&quot;;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;名字：&quot;+ s.name);</span></span><br><span class="line"><span class="comment">		s.eat();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，private成员和构造函数，都不能够被继承的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo8.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">疑问： 为什么要调用父类的构造方法啊？这样子做的意义在那？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用父类 的构造方法是可以初始化从父类继承下去的属性的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu类d带参的构造方法...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu类无参的构造方法...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name); <span class="comment">//指定调用父类一个参数的构造函数。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;x1 = &quot;</span>+ x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo8</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>(<span class="string">&quot;大头儿子&quot;</span>); </span><br><span class="line">		System.out.println(<span class="string">&quot;name= &quot;</span>+z.name);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo9.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字代表了父类空间的引用。代表的是子类对象中父类部分的引用，也代表了对代码区中父类字节码部分的引用，因为要调父类的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字的 作用：super的两个作用</span></span><br><span class="line"><span class="comment">	1. 子父类存在着同名的成员时，在子类中默认是访问子类的成员，可以通过super关键字指定访问父类的成员。</span></span><br><span class="line"><span class="comment">	2. 创建子类对象时，默认会先调用父类无参的构造方法，可以通过super关键字指定调用父类的构造方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字调用父类构造方法要注意的事项：</span></span><br><span class="line"><span class="comment">	1. 如果在子类的构造方法上没有指定调用父类的构造方法，那么java编译器会在子类的构造方法上面第一条语句默认加上super()语句。表示对父类无参构造方法的调用。</span></span><br><span class="line"><span class="comment">	2. super关键字调用父类的构造函数时，该语句必须要是子类构造函数中的第一个语句。</span></span><br><span class="line"><span class="comment">	3. super与this关键字不能同时出现在同一个构造函数中调用其他的构造函数。因为两个语句都需要第一个语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字与this关键字的区别：</span></span><br><span class="line"><span class="comment">	1. 代表的事物不一致。</span></span><br><span class="line"><span class="comment">			1. super关键字代表的是父类空间的引用。	</span></span><br><span class="line"><span class="comment">			2. this关键字代表的是所属函数的调用者对象。</span></span><br><span class="line"><span class="comment">	2. 使用前提不一致。</span></span><br><span class="line"><span class="comment">			1. super关键字必须要有继承关系才能使用。</span></span><br><span class="line"><span class="comment">			2. this关键字不需要存在继承关系也可使用。</span></span><br><span class="line"><span class="comment">	3. 调用构造函数的区别：</span></span><br><span class="line"><span class="comment">			1. super关键字是调用父类的构造函数。</span></span><br><span class="line"><span class="comment">			2. this关键字是调用本类的构造函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu类无参的构造方法..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu类带参的构造方法..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;小头爸爸吃番薯..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name); <span class="comment">//指定调用了父类带参的 构造方法...</span></span><br><span class="line">		<span class="built_in">this</span>(); <span class="comment">// 调用本类无参构造方法.. 会报错，this()和super()这种形式在构造方法中不能同时出现</span></span><br><span class="line">		<span class="comment">//super(); //指定调用了父类无参构造方法。。。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Zi类带参的构造方法..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Zi类无参的构造方法..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;x = &quot;</span> +<span class="built_in">super</span>.x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;大头儿子吃龙虾..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo9</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>(<span class="string">&quot;狗娃&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法的覆盖（重写）"><a href="#方法的覆盖（重写）" class="headerlink" title="方法的覆盖（重写）"></a>方法的覆盖（重写）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目前的问题：父类的功能无法满足子类的需求。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法重写的前提： 必须要存在继承的关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法重写要注意的事项：</span></span><br><span class="line"><span class="comment">	1.方法重写时， 方法名与形参列表，必须一致。</span></span><br><span class="line"><span class="comment">	2.方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。</span></span><br><span class="line"><span class="comment">	3.方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。</span></span><br><span class="line"><span class="comment">	4.方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。</span></span><br><span class="line"><span class="comment">			Exception(最坏)</span></span><br><span class="line"><span class="comment">			RuntimeException(小坏)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法重载的要求</span></span><br><span class="line"><span class="comment">	1. 函数名要一致。</span></span><br><span class="line"><span class="comment">	2. 形参列表不一致（形参的个数或形参 的类型不一致）</span></span><br><span class="line"><span class="comment">	3. 与返回值类型无关。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;  <span class="comment">//大的数据 类型 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;  <span class="comment">//Fish小 的数据类型。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line"></span><br><span class="line">	String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo10</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>(<span class="string">&quot;大头儿子&quot;</span>);</span><br><span class="line">		z.eat();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。"><a href="#方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。" class="headerlink" title="方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。"></a>方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">protected</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;<span class="comment">//error</span></span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011172047637.png" class="" title="image-20221011172047637">

<p><strong>子类重写的方法，不能够降低访问权限修饰。</strong></p>
<h3 id="方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。"><a href="#方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。" class="headerlink" title="方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。"></a>方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Fish <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;<span class="comment">//error</span></span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011173611466.png" class="" title="image-20221011173611466">

<p>父类方法的返回值类型为Fish，子类覆盖方法的返回值类型是Animal，比父类的大了，不满足。</p>
<h3 id="方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。"><a href="#方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。" class="headerlink" title="方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。"></a>方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。</h3><p><strong>子类方法不能抛出比父类方法更多的异常。子类方法抛出的异常必须和父类方法抛出的异常相同，或者子类方法抛出的异常类是父类方法抛出的异常类的子类。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">public</span> Fish <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;<span class="comment">//error</span></span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011173926194.png" class="" title="image-20221011173926194">

<p>子类覆盖的方法比父类方法抛出更大的异常了，错误。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011174154348.png" class="" title="image-20221011174154348">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011174207646.png" class="" title="image-20221011174207646">

<p>这样是没问题的，只要抛出的不是更大的异常就没问题，可以抛出多个异常的。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011180022491.png" class="" title="image-20221011180022491">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011180049218.png" class="" title="image-20221011180049218">

<p>子类抛出了和父类没有任何关系的一个异常，错误。</p>
<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求：使用java描述一下普通的学生、 java基础班的学生、 就业班的学生。</span></span><br><span class="line"><span class="comment">所有的学生都会学习。但是学习的内容不一样。</span></span><br><span class="line"><span class="comment">普通 的学生： 马克思列宁主义。</span></span><br><span class="line"><span class="comment">基础班的学生：学习的是 javase。</span></span><br><span class="line"><span class="comment">就业班学生： javaee+android.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;学习马克思列宁主义&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础班的学生是属于学生中一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">BaseStudent</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用父类构造函数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;学习javase..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//就业班学生 也是属于普通学生中一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造 函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">WorkStudent</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//重写</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;学习javaee+android..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo11</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">BaseStudent</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaseStudent</span>(<span class="string">&quot;居东东&quot;</span>);</span><br><span class="line">		s.study();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建一个就业班的学生</span></span><br><span class="line">		<span class="type">WorkStudent</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkStudent</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		w.study();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">instanceof 关键字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">instanceof关键字的作用：判断一个对象是否属于指定的类别。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">instanceof关键字的使用前提：判断的对象与指定的类别必须要存在继承或者实现的关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">instanceof关键字的使用格式：</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		对象  instanceof 类别</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">instanceof关键字的作用： 目前没用。但是后天我们学习 到了多态之后就非常有用。</span></span><br><span class="line"><span class="comment">一般我们做强制类型转换之前都会使用该关键字先判断一把，然后在进行转换的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	String color;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, String color)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//狗是属于动物中一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name,String color)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name,color); <span class="comment">//指定调用父类两个 参数的构造函数。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bite</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;咬人!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//老鼠 也是属于动物中一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span>  <span class="title class_">Animal</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Mouse</span><span class="params">(String name,String color)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name,color);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dig</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;打洞..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo12</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;哈士奇&quot;</span>,<span class="string">&quot;白色&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;狗是狗类吗？&quot;</span>+ (d <span class="keyword">instanceof</span> Dog));</span><br><span class="line">		System.out.println(<span class="string">&quot;狗是动物类吗？&quot;</span>+ (d <span class="keyword">instanceof</span> Animal));	</span><br><span class="line">		<span class="comment">//System.out.println(&quot;狗是老鼠类吗？&quot;+ (d instanceof Mouse));		// error编译报错 Incompatible conditional operand types Dog and Mouse</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;狗娃&quot;</span>,<span class="string">&quot;黄色&quot;</span>); <span class="comment">//狗娃是人</span></span><br><span class="line">		System.out.println(<span class="string">&quot;动物都是狗吗？&quot;</span>+ (a <span class="keyword">instanceof</span> Dog));<span class="comment">//编译正确，执行结果为false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011194704449.png" class="" title="image-20221011194704449">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011194736189.png" class="" title="image-20221011194736189">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011194813333.png" class="" title="image-20221011194813333">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011194851032.png" class="" title="image-20221011194851032">

<p><strong>注意，分为编译和运行时两个阶段。</strong></p>
<p><strong>编译时，只看左右两边操作数的类型是否是同一个继承树上，如果是，有继承关系，那么就没问题，如图蓝线部分。编译可以通过。</strong></p>
<p><strong>运行时，就看实际左边操作数引用变量实际指向的对象是谁，然后看它是否是右边操作数的实例了。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011195055084.png" class="" title="image-20221011195055084">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011195108736.png" class="" title="image-20221011195108736">

<p><strong>注意，new int[4]，它的类型是int[]，因为正常定义时int[] a &#x3D; new int[4];这样的，a的类型就是int[]。</strong></p>
<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承描述的是事物之间的所属关系，这种关系是： is-a 的关系。例如，图中兔子属于食草动物，食草动物属于动<br>物。可见，父类更通用，子类更具体。</p>
<p><strong>继承：</strong>就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接<br>访问父类中的<strong>非私有的属性和行为</strong>。</p>
<p>将相同类型的对象，进行抽象，得到类。相同对象中相同的内容，抽象为了类变量。</p>
<p>将各个类共有的内容进行抽象，得到父类。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011195755278.png" class="" title="image-20221011195755278">

<p>继承的好处：</p>
<ol>
<li>提高代码的复用性。</li>
<li>类与类之间产生了关系，是多态的前提。</li>
</ol>
<p>语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类：员工</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个员工的子类：讲师</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了员工的另一个子类：助教</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Assistant</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在继承的关系中，“子类就是一个父类”。也就是说，子类可以被当做父类看待。</span></span><br><span class="line"><span class="comment">例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义父类的格式：（一个普通的类定义）</span></span><br><span class="line"><span class="comment">public class 父类名称 &#123;</span></span><br><span class="line"><span class="comment">    // ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义子类的格式：</span></span><br><span class="line"><span class="comment">public class 子类名称 extends 父类名称 &#123;</span></span><br><span class="line"><span class="comment">    // ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Extends</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建了一个子类对象</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        <span class="comment">// Teacher类当中虽然什么都没写，但是会继承来自父类的method方法。</span></span><br><span class="line">        teacher.method();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建另一个子类助教的对象</span></span><br><span class="line">        <span class="type">Assistant</span> <span class="variable">assistant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Assistant</span>();</span><br><span class="line">        assistant.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="继承后成员变量问题"><a href="#继承后成员变量问题" class="headerlink" title="继承后成员变量问题"></a>继承后成员变量问题</h3><p>当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？</p>
<p><strong>成员变量不重名</strong><br>如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。</p>
<p><strong>成员变量重名</strong><br>如果子类父类中出现重名的成员变量，这时的访问是有影响的。</p>
<p>子父类中出现了同名的成员变量时，在子类中需要访问父类中<strong>非私有成员变量</strong>时，需要使用 super 关键字，修饰<br>父类成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.父类成员变量名</span><br></pre></td></tr></table></figure>

<p><strong>Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的（private成员和构造方法不会被继承）。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</strong></p>
<p><strong>私有的成员变量和私有成员方法，是不能够被继承的。</strong></p>
<p><strong>构造方法也不能够被继承。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numFu</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodFu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用的是本类当中的，不会向下找子类的</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numZi</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodZi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 因为本类当中有num，所以这里用的是本类的num，等价于this.num方式。</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">直接通过子类对象访问成员变量：</span></span><br><span class="line"><span class="comment">    等号左边是谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment">间接通过成员方法访问成员变量：</span></span><br><span class="line"><span class="comment">    该方法属于谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ExtendsField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fu</span> <span class="variable">fu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fu</span>(); <span class="comment">// 创建父类对象</span></span><br><span class="line">        System.out.println(fu.numFu); <span class="comment">// 只能使用父类的东西，没有任何子类内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(zi.numFu); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(zi.numZi); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等号左边是谁，就优先用谁</span></span><br><span class="line">        System.out.println(zi.num); <span class="comment">// 优先子类，200</span></span><br><span class="line"><span class="comment">//        System.out.println(zi.abc); // 到处都没有，编译报错！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个方法是子类的，优先用子类的，没有再向上找</span></span><br><span class="line">        zi.methodZi(); <span class="comment">// 200等价于methodZi(zi)</span></span><br><span class="line">        <span class="comment">// 这个方法是在父类当中定义的，</span></span><br><span class="line">        zi.methodFu(); <span class="comment">// 100等价于methodFu(zi)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011204327527.png" class="" title="image-20221011204327527">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011210826337.png" class="" title="image-20221011210826337">



<p>&#x2F;&#x2F; 这个方法是子类的，优先用子类的，没有再向上找</p>
<p>zi.methodZi(); &#x2F;&#x2F; 200等价于methodZi(zi)</p>
<p>&#x2F;&#x2F; 这个方法是在父类当中定义的</p>
<p>zi.methodFu(); &#x2F;&#x2F; 100等价于methodFu(zi)</p>
<p>说明：</p>
<p>zi.methodZi()等价于methodZi(zi)，因为看到zi是Zi类型的，因此，编译转换成对Zi类中的methodZi(zi)这种调用方式，因此，zi传递给methodZi中的this，methodZi的原型为public void methodZi(Zi this){}这样的，因此，this的类型为Zi，因此，zi对象传递给了this，因此，就是this.num这样，<strong>编译的时候</strong>，根据等号左边类型编译，因此，this的类型为Zi，里面有num，因此，编译通过，如果没有子类中没有num，那么就会去看继承的父类中是否有num，有，那么编译通过。<strong>然后运行的时候</strong>，this指向的是zi对象，因此，首先会在zi对象中找子类中的num，如果有就打印的就是zi对象中的子类中的num，如果没有就去找zi对象中从父类继承而来的那个num了。</p>
<p>zi.methodFu()等价于methodFu(zi)，因为看到zi是Zi类型，<strong>编译时候，</strong>因此，编译转换为了对Zi类型中的methodFu调用，但是Zi类型中没有methodFu方法的，但是它继承子Fu类，而父类中有methodFu方法的，因此，编译通过，去调用父类Fu中methodFu方法。因此，就是methodFu(zi)，将zi传递给了methodFu中的this，类型为Fu this，因为，父类型的引用指向子类型的对象，多态了。然后methodFu中打印num，即为this.num，编译阶段，this是Fu类型，里面有num，因此，编译通过。<strong>运行的时候，</strong>由于this指向的是子类的对象，但是this的类型是Fu，并且调用的是在Fu类中的methodFu方法中的，因此，其中的this表示指向调用者对象，那么这个调用者实际上就是子类对象中从父类继承过来的那个部分，也就是所谓的super了。因此，打印的时候，只能访问到Fu类中的num。</p>
<p><strong>因此，父类中的方法只能访问打印父类中的属性。子类中的方法可以打印访问子类中的属性，也可以打印访问从父类中继承而来的属性。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">	num=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    num=<span class="number">200</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fu fu&#x3D;new Zi();</p>
<p>fu.method()等给予method(fu)</p>
<p>编译的时候，看到fu是Fu类型，然后看到Fu中有method，因此，编译通过。</p>
<p>运行的时候，fu.method()会转换为method(fu)这种方式调用，因为多态，fu指向的是子类对象，因此，调用子类中的method方法，因此，fu传给子类method中的Zi this变量，这就是向下类型转换了，Zi this&#x3D;(Zi)fu;因此，this指向了子类对象，此时打印num，就是this.num，因此，打印子类对象中的num。如果子类中没有num，那么此时就会拿到子类对象中从父类继承而来的num了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">200</span>;</span><br><span class="line"><span class="comment">//    void method()&#123;</span></span><br><span class="line"><span class="comment">//       System.out.println(num);//等价于this.num</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo13</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">		zi.method();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="comment">//int num=200;</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo13</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">		zi.method();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>



<h3 id="继承后成员方法问题"><a href="#继承后成员方法问题" class="headerlink" title="继承后成员方法问题"></a>继承后成员方法问题</h3><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p>
<p><strong>成员方法不重名</strong> </p>
<p>如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。</p>
<p>对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu类中的show方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zi类中的show2方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">ExtendsDemo04</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        <span class="comment">//子类中没有show方法，但是可以找到父类方法去执行</span></span><br><span class="line">        z.show(); </span><br><span class="line">        z.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 30，局部变量</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num); <span class="comment">// 20，本类的成员变量，如果没有局部变量，那么这里的this可以省略，因为先找局部变量，没有，就找到成员变量，如果成员变量也没有，那么就找父类中的成员变量了。</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num); <span class="comment">// 10，父类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">局部变量：         直接写成员变量名</span></span><br><span class="line"><span class="comment">本类的成员变量：    this.成员变量名</span></span><br><span class="line"><span class="comment">父类的成员变量：    super.成员变量名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ExtendsField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"></span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="成员方法重名—重写-Override"><a href="#成员方法重名—重写-Override" class="headerlink" title="成员方法重名—重写(Override)"></a>成员方法重名—重写(Override)</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011214258838.png" class="" title="image-20221011214258838">

<p>如果子类中出现与父类的成员方法重名的，这时的访问是一种特殊情况，叫做<strong>方法重写 (Override)。</strong></p>
<p><strong>方法重写 ：</strong>子类中出现与父类一模一样的方法时（<strong>返回值类型，方法名和参数列表都相同</strong>），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。<strong>注意，重写不要求返回值类型一致的。只需要方法名和参数列表一致即可。</strong></p>
<p><strong>重写时，用到super.父类成员方法，表示调用父类的成员方法。</strong></p>
<p><strong>注意事项</strong> </p>
<p>1、子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</p>
<p>2、子类方法覆盖父类方法，函数名和参数列表都要一模一样。</p>
<p><strong>方法覆盖重写的注意事项：</strong></p>
<ol>
<li>必须保证父子类之间方法的名称相同，参数列表也相同。<br>@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。<br>这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</li>
<li>子类方法的返回值类型范围必须【小于等于】父类方法的返回值类型范围。<br>小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</li>
<li>子类方法的权限必须【大于等于】父类方法的权限修饰符。<br>小扩展提示：public &gt; protected &gt; (default) &gt; private<br>备注：(default)不是关键字default，而是什么都不写，留空。</li>
<li>子类方法不能抛出比父类方法更多的异常。即子类方法抛出的异常必须和父类方法抛出的异常相同，或者子类方法抛出的异常类是父类方法抛出的异常类的子类。</li>
</ol>
<p>针对第4条：</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011223050869.png" class="" title="image-20221011223050869">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011223203851.png" class="" title="image-20221011223203851">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011223249643.png" class="" title="image-20221011223249643">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodFu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类重名方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodZi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类重名方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</span></span><br><span class="line"><span class="comment">    创建的对象是谁，就优先用谁，如果没有则向上找。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">重写（Override）</span></span><br><span class="line"><span class="comment">概念：在继承关系当中，方法的名称一样，参数列表也一样，返回值类型一样。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">重写（Override）：方法的名称一样，参数列表【也一样】，返回值类型一样。覆盖、覆写。</span></span><br><span class="line"><span class="comment">重载（Overload）：方法的名称一样，参数列表【不一样】。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ExtendsMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"></span><br><span class="line">        zi.methodFu();</span><br><span class="line">        zi.methodZi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建的是new了子类对象，所以优先用子类方法</span></span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="comment">//子类重写了父类的show方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zi show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo05</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        <span class="comment">// 子类中有show方法，只执行重写后的show方法</span></span><br><span class="line">        z.show();  <span class="comment">// Zi show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>重写应用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来电显示号码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用父类已经存在的功能使用super</span></span><br><span class="line">        <span class="built_in">super</span>.showNum();</span><br><span class="line">        <span class="comment">//增加自己特有显示姓名和图片功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显示来电姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;显示头像&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">NewPhone</span> <span class="variable">np</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewPhone</span>()；</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用父类继承而来的方法</span></span><br><span class="line">        np.call();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 调用子类重写的方法</span></span><br><span class="line">        np.showNum();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重写时，用到<strong>super.父类成员方法，表示调用父类的成员方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法覆盖重写的注意事项：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 必须保证父子类之间方法的名称相同，参数列表也相同。</span></span><br><span class="line"><span class="comment">@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。</span></span><br><span class="line"><span class="comment">这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 子类方法的返回值类型范围必须【小于等于】父类方法的返回值类型范围。</span></span><br><span class="line"><span class="comment">小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 子类方法的权限必须【大于等于】父类方法的权限修饰符。</span></span><br><span class="line"><span class="comment">小扩展提示：public &gt; protected &gt; (default) &gt; private</span></span><br><span class="line"><span class="comment">备注：(default)不是关键字default，而是什么都不写，留空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Override</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2. 子类方法的返回值必须【小于等于】父类方法的返回值范围。</span></span><br><span class="line"><span class="comment">	public class Fu &#123;</span></span><br><span class="line"><span class="comment">		public Object method() &#123;</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	public class Zi extends Fu &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		@Override</span></span><br><span class="line"><span class="comment">		public String method() &#123;//子类重写的方法的返回值类型小于等于父类的方法返回值类型正确。</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	public class Fu &#123;</span></span><br><span class="line"><span class="comment">		public String method() &#123;</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	public class Zi extends Fu &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		@Override</span></span><br><span class="line"><span class="comment">		public String method() &#123;//子类重写的方法的返回值类型小于等于父类的方法返回值类型正确。</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	public class Fu &#123;</span></span><br><span class="line"><span class="comment">		public String method() &#123;</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	public class Zi extends Fu &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		@Override</span></span><br><span class="line"><span class="comment">		public Object method() &#123;//子类重写的方法的返回值类型大于父类的方法返回值类型，错误。</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="继承后的构造方法"><a href="#继承后的构造方法" class="headerlink" title="继承后的构造方法"></a>继承后的构造方法</h3><p>首先我们要回忆两个事情，构造方法的定义格式和作用。</p>
<p>1、构造方法的名字是与类名一致的。<strong>所以子类是无法继承父类构造方法的</strong>。构造方法不能继承。</p>
<p>2、构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构<br>造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">  Fu()&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Fu()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">  Zi()&#123;</span><br><span class="line">    <span class="comment">// super（），调用父类构造方法</span></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;Zi（）&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo07</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Fu（）</span><br><span class="line">Zi（）</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类有参构造！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 在调用父类无参构造方法</span></span><br><span class="line"><span class="comment">//        super(20); // 在调用父类重载的构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承关系中，父子类构造方法的访问特点：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。</span></span><br><span class="line"><span class="comment">2. 子类构造可以通过super关键字来指定调用父类中重载的不同的构造方法。</span></span><br><span class="line"><span class="comment">3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">子类必须调用父类构造方法，不写则赠送super()，即默认提供一个无参的super()调用；写了则用写的指定的super调用，super只能有一个，还必须是子类构造方法的第一条语句。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Constructor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字的用法有三种：</span></span><br><span class="line"><span class="comment">1. 在子类的成员方法中，访问父类的成员变量。</span></span><br><span class="line"><span class="comment">2. 在子类的成员方法中，访问父类的成员方法。</span></span><br><span class="line"><span class="comment">3. 在子类的构造方法中，访问父类的构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodZi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num); <span class="comment">// 父类中的num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.method(); <span class="comment">// 访问父类中的method</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：</span></span><br><span class="line"><span class="comment">this用法也有三种：</span></span><br><span class="line"><span class="comment">1. 在本类的成员方法中，访问本类的成员变量。</span></span><br><span class="line"><span class="comment">2. 在本类的成员方法中，访问本类的另一个成员方法。</span></span><br><span class="line"><span class="comment">3. 在本类的构造方法中，访问本类的另一个构造方法。</span></span><br><span class="line"><span class="comment">在第三种用法当中要注意：</span></span><br><span class="line"><span class="comment">A. this(...)调用也必须是构造方法的第一个语句，唯一一个。</span></span><br><span class="line"><span class="comment">B. super和this两种构造调用，不能同时使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        super(); // 这一行不再赠送</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">123</span>); <span class="comment">// 本类的无参构造，调用本类的有参构造</span></span><br><span class="line"><span class="comment">//        this(1, 2); // 错误写法！当有了上面的this(123)的时候，这行就不能再有了。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num); <span class="comment">// 本类中的成员变量</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num); <span class="comment">// 父类中的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.methodA();<span class="comment">//此时this可以省略不写。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，同一个类中的成员之间可以随意访问的，可以不使用this的。</strong></p>
<p><strong>图解：</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011230100475.png" class="" title="image-20221011230100475">

<p>[[super_class]]是javac编译之后，字节码中的一个特殊标记。它指向了父类。意思就是知道了它的父类是谁，就类似extends关键字一样，知道父类是谁了。<br>注意，堆中的子类对象中包含了一个完整的从父类继承而来内容。因此，肯定是先构造出父类内容，然后才在父类内容之外构造出子类对象的内容的。可以看到，堆中，只有一个子类对象的，只是这个子类对象中包含了从父类继承而来的内容。<br>父类内容中的0x method，这个是存的一个地址值，指向的是方法区中Fu.class中的method。<br><strong>this代表的就是子类对象。super就是代表的就是堆中子类对象中，父类内容这个部分。</strong><br>因此，现在对象就是一个两层嵌套结构，里面有父类的内容。</p>
<p>注意，子类中的method中调用super.method()，寻找过程也是先从super定位到堆中对象的父类内容这里，然后定位到0x method这个地址，然后通过它定位到方法区中的父类Fu.class中的method。</p>
<p><strong>注意，堆内存中只有一个子类对象的，只是该对象中包含了父类的内容。</strong></p>
<p>super两个含义，一个就表示了子类对象中从父类继承过来的那部分。另外一个就是字节码中子类部分指向父类的部分。</p>
<p>super.method()等价于method(super)，super传给了父类method方法中的Fu this变量了，因此，父类method中this.num，打印的就是子类对象中从父类继承而来的那部分。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011231250120.png" class="" title="image-20221011231250120">

<p>在每次创建子类对象时，现在堆区开辟空间，先初始化继承的父类成员部分的空间，再创建其子类成员部分空间。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。</p>
<p><strong>注意，父类中的private属性，在子类继承的时候，创建子类对象的时候，这个private属性也是在子类对象的堆空间中的，只是不能够直接访问到它，需要借助父类的方法去访问它而已。</strong></p>
<p><strong>因此，实际上private属性和方法也是可以被继承的。</strong></p>
<p><strong>super和this的含义</strong><br>    <strong>super ：代表父类的存储空间标识(可以理解为父类的引用)。即对子类对象中从父类继承而来的部分的引用，这个继承而来的部分也可以叫做父类对象，因此，也可以理解为super是对父类对象的引用。</strong><br>    <strong>this ：代表当前对象的引用(谁调用就代表谁)。</strong></p>
<p>this.成员变量       ‐‐    本类的</p>
<p>super.成员变量      ‐‐    父类的</p>
<p>this.成员方法名()    ‐‐    本类的    </p>
<p>super.成员方法名()   ‐‐    父类的</p>
<p>this(…)       ‐‐    本类的构造方法</p>
<p>super(…)      ‐‐    父类的构造方法</p>
<p>子类的每个构造方法中均有默认的super()，调用父类的无参构造。手动调用父类构造会覆盖默认的super()。</p>
<p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p>
<p><strong>构造方法和private成员变量成员方法，是不能够被继承的。</strong></p>
<p>这里说的private属性和方法不能继承，是说子类中不能够像继承了之后直接去使用他们，而实际上是继承了，只是需要借助父类去访问到它们的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal : eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat : eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eat();   <span class="comment">// this  调用本类的方法</span></span><br><span class="line">        <span class="built_in">super</span>.eat();  <span class="comment">// super 调用父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        a.eat();</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.eatTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">输出结果为：</span><br><span class="line">animal : eat</span><br><span class="line">cat : eat</span><br><span class="line">animal : eat</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.method(); <span class="comment">// 调用了父类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 30</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"></span><br><span class="line">        zi.show();</span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super，在子类重写的方法中又想调用父类中的被重写的方法，可以使用super。</p>
<p>super就代表父类。</p>
<p>特殊变量super，提供了对父类的访问。</p>
<p>可以使用super访问父类被子类隐藏的变量或者覆盖的方法。</p>
<p>每个子类构造方法的第一条语句，都是隐含的调用super()，如果父类没有这种形式的构造方法，那么编译就会报错。</p>
<p>注意，对于构造方法来说，是不能被继承的。不像其它的方法可以继承，构造方法是不能够被继承的。</p>
<p>由于构造方法不能够继承，所以，子类构造方法的第一条语句就是隐含的调用父类的构造方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="type">int</span> height,weight;</span><br><span class="line">	Animal(<span class="type">int</span> height,<span class="type">int</span> weight)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	Fish()&#123;</span><br><span class="line">		Animal(<span class="number">30</span>,<span class="number">40</span>);<span class="comment">//由于构造方法不能够继承的，所以这样写错误的。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，super的含义，就是指向父类对象。this，就是指向当前对象。</p>
<h3 id="Java继承的三个特点"><a href="#Java继承的三个特点" class="headerlink" title="Java继承的三个特点"></a>Java继承的三个特点</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012153912672.png" class="" title="image-20221012153912672">

<p>方法的覆盖，发生在子类和父类之间的。</p>
<p>方法的重载，发生在同一个类中。</p>
<p>对于成员变量也是同理，子类定义类与父类同名的成员变量，即覆盖了父类的成员变量。</p>
<p><strong>private方法，出了当前类就无法访问，因此，也就无法覆盖。也就是private方法是不能被继承的。即使我们在子类中对父类的private方法覆盖，编译也没报错，但是，其实是没有覆盖成功的。实际上只是产生了一个新的private方法在子类中。</strong></p>
<p><strong>static方法同理，也是不能覆盖基类的static方法的。对于static成员，子类定义相同的是对父类的隐藏，而不是覆盖。</strong></p>
<p><strong>Private，static方法，不能够被继承，自然不能够被覆盖了。</strong></p>
<p><strong>private私有方法，构造方法，static方法，都不能够被继承。</strong></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012154516057.png" class="" title="image-20221012154516057">

<p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。<strong>我们把没有方法主体的方法称为抽象方法</strong>。Java语法规定，<strong>包含抽象方法的类就是抽象类。</strong></p>
<p><strong>定义</strong> </p>
<p>​	<strong>抽象方法 ： 没有方法体的方法。</strong></p>
<p>​	<strong>抽象类：包含抽象方法的类。</strong></p>
<p><strong>抽象方法</strong> </p>
<p>使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<p><strong>抽象类</strong> </p>
<p>如果一个类包含抽象方法，那么该类必须是抽象类。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名字 &#123; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象的使用</strong> </p>
<p>继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的所有抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小猫在墙头走~~~&quot;</span>)；     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 调用run方法</span></span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">小猫在墙头走~~~</span><br></pre></td></tr></table></figure>

<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法。</strong></p>
<p><strong>注意事项</strong></p>
<p><strong>1、抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</strong></p>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
<p><strong>2、抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</strong></p>
<p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p>
<p><strong>3、抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</strong></p>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设<br>计。</p>
<p><strong>4、抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象</strong><br><strong>类。</strong></p>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有<br>意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。</span></span><br><span class="line"><span class="comment">抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如何使用抽象类和抽象方法：</span></span><br><span class="line"><span class="comment">1. 不能直接创建new抽象类对象。</span></span><br><span class="line"><span class="comment">2. 必须用一个子类来继承抽象父类。</span></span><br><span class="line"><span class="comment">3. 子类必须覆盖重写抽象父类当中所有的抽象方法。</span></span><br><span class="line"><span class="comment">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</span></span><br><span class="line"><span class="comment">4. 创建子类对象进行使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是普通的成员方法</span></span><br><span class="line"><span class="comment">//    public void normalMethod() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Animal animal = new Animal(); // 错误写法！不能直接创建抽象类对象</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//抽象类中是可以有构造方法的，提供创建子类对象时初始化父类中成员变量的作用。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象父类构造方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// super();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        zi.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个抽象类不一定含有抽象方法，</span></span><br><span class="line"><span class="comment">只要保证抽象方法所在的类是抽象类，即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这样没有抽象方法的抽象类，也不能直接创建对象，在一些特殊场景下有用途。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyAbstract</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最高的抽象父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类也是一个抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public abstract void sleep();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog2Ha</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘿嘿嘿……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogGolden</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;呼呼呼……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Animal animal = new Animal(); // 错误！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Dog dog = new Dog(); // 错误，这也是抽象类</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Dog2Ha</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog2Ha</span>(); <span class="comment">// 这是普通类，可以直接new对象。</span></span><br><span class="line">        ha.eat();</span><br><span class="line">        ha.sleep();</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DogGolden</span> <span class="variable">golden</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogGolden</span>();</span><br><span class="line">        golden.eat();</span><br><span class="line">        golden.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="综合案例：群主发红包"><a href="#综合案例：群主发红包" class="headerlink" title="综合案例：群主发红包"></a>综合案例：群主发红包</h3><p>群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则：</p>
<ol>
<li>群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。</li>
<li>成员领取红包后，保存到成员余额中。</li>
</ol>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012161844760.png" class="" title="image-20221012161844760">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> money; <span class="comment">// 余额，也就是当前用户拥有的钱数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示一下当前用户有多少钱</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫：&quot;</span> + name + <span class="string">&quot;，我有多少钱：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">// 群主的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">send</span><span class="params">(<span class="type">int</span> totalMoney, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先需要一个集合，用来存储若干个红包的金额</span></span><br><span class="line">        ArrayList&lt;Integer&gt; redList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先看一下群主自己有多少钱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMoney</span> <span class="operator">=</span> <span class="built_in">super</span>.getMoney(); <span class="comment">// 群主当前余额</span></span><br><span class="line">        <span class="keyword">if</span> (totalMoney &gt; leftMoney) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> redList; <span class="comment">// 返回空集合</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扣钱，其实就是重新设置余额</span></span><br><span class="line">        <span class="built_in">super</span>.setMoney(leftMoney - totalMoney);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发红包需要平均拆分成为count份</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">avg</span> <span class="operator">=</span> totalMoney / count;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> totalMoney % count; <span class="comment">// 余数，也就是甩下的零头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除不开的零头，包在最后一个红包当中</span></span><br><span class="line">        <span class="comment">// 下面把红包一个一个放到集合当中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            redList.add(avg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一个红包</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> avg + mod;</span><br><span class="line">        redList.add(last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">// 普通成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Member</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Member</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Member</span><span class="params">(String name, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">// 从多个红包当中随便抽取一个，给我自己。</span></span><br><span class="line">        <span class="comment">// 随机获取一个集合当中的索引编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(list.size());</span><br><span class="line">        <span class="comment">// 根据索引，从集合当中删除，并且得到被删除的红包，给我自己</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> list.remove(index);</span><br><span class="line">        <span class="comment">// 当前成员自己本来有多少钱：</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="built_in">super</span>.getMoney();</span><br><span class="line">        <span class="comment">// 加法，并且重新设置回去</span></span><br><span class="line">        <span class="built_in">super</span>.setMoney(money + delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainRedPacket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;群主&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Member</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;成员A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Member</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;成员B&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Member</span> <span class="variable">three</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;成员C&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        manager.show(); <span class="comment">// 100</span></span><br><span class="line">        one.show(); <span class="comment">// 0</span></span><br><span class="line">        two.show(); <span class="comment">// 0</span></span><br><span class="line">        three.show(); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 群主总共发20块钱，分成3个红包</span></span><br><span class="line">        ArrayList&lt;Integer&gt; redList = manager.send(<span class="number">20</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 三个普通成员收红包</span></span><br><span class="line">        one.receive(redList);</span><br><span class="line">        two.receive(redList);</span><br><span class="line">        three.receive(redList);</span><br><span class="line"></span><br><span class="line">        manager.show(); <span class="comment">// 100-20=80</span></span><br><span class="line">        <span class="comment">// 6、6、8，随机分给三个人</span></span><br><span class="line">        one.show();</span><br><span class="line">        two.show();</span><br><span class="line">        three.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>abstract，抽象类，含有抽象方法的类就是抽象类。如果一个子类没有实现抽象基类中的所有的抽象方法，那么这个子类也是一个抽象类。我们可以将一个没有任何抽象方法的类声明为abstract，从而避免由这个类产生任何的对象。抽象类不能够实例化的。</p>
<p>java中就提供了这样的类，里面的所有方法都是实现了的，但是都是空实现，然后将这个类定义为抽象类，然后我们要去继承这个类，然后至少重写其中的一个方法，然后用这个类去实例化对象，这样实例化出的对象才有意义。适配器模式</p>
<p>抽象类通常是将共性的东西抽象出来，例如，Animal类，其中的sleep方法定义为抽象方法，然后Animal自然就是抽象类，然后子类中去实现这个sleep方法，站着睡觉的就站着，躺着睡觉的就躺着实现的。</p>
<hr>
<h2 id="以下内容来自读书笔记"><a href="#以下内容来自读书笔记" class="headerlink" title="以下内容来自读书笔记"></a>以下内容来自读书笔记</h2><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012170556312.png" class="" title="image-20221012170556312">

<p>注意，这里说的sub继承了父类中的内容，是说sub子类的方法中可以直接访问的意思。</p>
<p>例如，同一个包中，子类可以继承父类中的public，protected，default的成员，意思是说子类的方法中可以直接访问这些成员的。而对于父类中的private成员，实际上在创建子类对象的时候，会调用父类构造方法，也对这些父类中的private成员进行初始化的，这些内容也是放在了堆中子类对象空间中的，只是子类的方法中没有办法直接访问到它而已。</p>
<p>对于不同包中，也是同理。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012171015496.png" class="" title="image-20221012171015496">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012171202196.png" class="" title="image-20221012171202196">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012172327161.png" class="" title="image-20221012172327161">



<h3 id="继承注意事项"><a href="#继承注意事项" class="headerlink" title="继承注意事项"></a>继承注意事项</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012173201014.png" class="" title="image-20221012173201014">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012173221688.png" class="" title="image-20221012173221688">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012173331321.png" class="" title="image-20221012173331321">





<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012173618521.png" class="" title="image-20221012173618521">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174015393.png" class="" title="image-20221012174015393">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174221077.png" class="" title="image-20221012174221077">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174334234.png" class="" title="image-20221012174334234">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174436178.png" class="" title="image-20221012174436178">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174752383.png" class="" title="image-20221012174752383">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174833381.png" class="" title="image-20221012174833381">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174925165.png" class="" title="image-20221012174925165">

<p>说明：注意，new Sub()的时候，是堆中先开辟对象的空间，然后该对象就有了，然后调用构造方法的时候，将该对象传入，即类似Sub(sub)这样，然后构造方法中Sub this接收这个对象，子类构造方法第一条语句就是隐含调用super()，即调用父类构造方法初始化子类对象中从父类继承而来的部分。调用super()，类似this.super()这样，即子类对象调用super()这样，子类没有就去找父类中的方法，实际上就是调父类中的Base()方法，然后this传入，super(this)，即Base(this)，然后Base this接收传入的这个this（父类引用指向了子类对象），传入的this是子类对象，因此，Base()构造方法中的this也指向了子类这个对象了，然后Base()中调用method，等价于this.method()（编译的时候根据等号左边引用变量类型找方法，this是Base类型，因此，它里面有method方法，编译通过），this现在指向子类对象的，因此，运行的时候，动态绑定，多态，因此，指向谁就调谁的方法，因此，调的就是子类对象中的method方法了，如果子类没有重写，那么就调父类中的method方法了。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200533496.png" class="" title="image-20221012200533496">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200917581.png" class="" title="image-20221012200917581">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200932443.png" class="" title="image-20221012200932443">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200944976.png" class="" title="image-20221012200944976">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200957897.png" class="" title="image-20221012200957897">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201007680.png" class="" title="image-20221012201007680">



<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201431209.png" class="" title="image-20221012201431209">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201459999.png" class="" title="image-20221012201459999">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201521268.png" class="" title="image-20221012201521268">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201615650.png" class="" title="image-20221012201615650">

<p><strong>参数签名：参数的类型，个数，顺序</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201708712.png" class="" title="image-20221012201708712">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201759241.png" class="" title="image-20221012201759241">



<h3 id="方法覆盖（重写）"><a href="#方法覆盖（重写）" class="headerlink" title="方法覆盖（重写）"></a>方法覆盖（重写）</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201916678.png" class="" title="image-20221012201916678">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012203241526.png" class="" title="image-20221012203241526">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">public</span> Fish <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;<span class="comment">//ok</span></span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明，实际上，子类要覆盖的方法的返回值类型小于等于父类方法的返回值类型即可，不一定非要一致。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204016404.png" class="" title="image-20221012204016404">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204128338.png" class="" title="image-20221012204128338">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204226544.png" class="" title="image-20221012204226544">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204406488.png" class="" title="image-20221012204406488">

<p><strong>父类的静态方法不能被子类覆盖为非静态方法。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204505020.png" class="" title="image-20221012204505020">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204742596.png" class="" title="image-20221012204742596">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012205312174.png" class="" title="image-20221012205312174">

<p><strong>注意，static方法只能被隐藏，而不能被覆盖的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span>&#123;<span class="comment">//error</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012205211564.png" class="" title="image-20221012205211564">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012205440063.png" class="" title="image-20221012205440063">

<p><strong>非静态不能覆盖为静态。</strong></p>
<p><strong>静态也不能覆盖为非静态。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012205549915.png" class="" title="image-20221012205549915">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012210033273.png" class="" title="image-20221012210033273">

<p>如果Base中的showMe改成public，那么运行的时候就是多态动态绑定机制了。</p>
<p>Base中的print中的调用showMe，等价于this.showMe()，sub.print()的时候，等价于print(sub)，因此，Base中的Base this接收sub，父类引用指向子类对象，然后运行的时候，this.showMe()，由于子类的showMe()对父类的showMe()不构成覆盖关系，因此，根据多态，Base this现在指向sub子类对象，根据多态，找子类中的覆盖的showMe()，但是现在没有，因此，就向上找继承的父类中的showMe()，虽然父类的showMe()是private，不能继承的，但是仍然可以这样理解，不冲突。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211511585.png" class="" title="image-20221012211511585">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211659102.png" class="" title="image-20221012211659102">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211745677.png" class="" title="image-20221012211745677">

<p><strong>实例方法可以覆盖为抽象方法。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211921105.png" class="" title="image-20221012211921105">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211936675.png" class="" title="image-20221012211936675">



<h3 id="super-1"><a href="#super-1" class="headerlink" title="super"></a>super</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012212330410.png" class="" title="image-20221012212330410">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012213113031.png" class="" title="image-20221012213113031">

<p>注意，最后两个等价的。</p>
<p>注意，super的类型就是Base，因此，super.method()，编译的时候根据变量类型，看里面有method方法，编译通过。执行的时候，super指向的就是子类对象中的父类对象部分，因此，调用的就是父类中的method方法。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012214512052.png" class="" title="image-20221012214512052">

<p><strong>静态方法和静态代码块中不能使用this和super。</strong></p>
<p>因为this和super都是指向子类对象和子类对象中继承来的父类部分的，而静态方法和静态代码块，是可以没有对象的。</p>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012215632209.png" class="" title="image-20221012215632209">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012215747775.png" class="" title="image-20221012215747775">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012215807440.png" class="" title="image-20221012215807440">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012215912513.png" class="" title="image-20221012215912513">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220524259.png" class="" title="image-20221012220524259">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220553576.png" class="" title="image-20221012220553576">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220646449.png" class="" title="image-20221012220646449">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220752921.png" class="" title="image-20221012220752921">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220923111.png" class="" title="image-20221012220923111">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220943663.png" class="" title="image-20221012220943663">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012221439049.png" class="" title="image-20221012221439049">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012221611489.png" class="" title="image-20221012221611489">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012221750898.png" class="" title="image-20221012221750898">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012221820731.png" class="" title="image-20221012221820731">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012222213284.png" class="" title="image-20221012222213284">

<p><strong>注意，只有实例方法和引用变量实际指向的对象，才是动态绑定（运行期行为）。其他的都是静态绑定（编译器行为）。</strong></p>
<p><strong>对于实例变量，who.var访问的也是base中的，实际上就是堆中子类对象中的父类部分的内容。这不是多态，因为编译阶段，就可以知道who的类型是Base，然后想要拿到的就是父类中的内容，也就是子类对象中的父类部分的内容。虽然运行的时候who指向的是子类对象，但是这是编译期行为已经确定了，因此，虽然who运行时指向的是子类对象，但是拿到是子类对象中从父类继承而来的那个部分的内容。</strong></p>
<p><strong>对于静态的变量和方法，都是跟类绑定的，属于类，而不属于具体的实例对象的。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012223301303.png" class="" title="image-20221012223301303">

<p>说明：这里属于动态绑定了，调用test()，test()中的是this.method()，this是CLASS A类型的，此时this指向子类对象new B()，那么运行的时候，根据动态绑定机制，指向的是子类对象，因此，调用子类中的方法method。可以思考内存图。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012224342117.png" class="" title="image-20221012224342117">





<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012224428395.png" class="" title="image-20221012224428395">



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下mysql手动安装方式</title>
    <url>/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Windows环境下mysql手动方式安装"><a href="#Windows环境下mysql手动方式安装" class="headerlink" title="Windows环境下mysql手动方式安装"></a>Windows环境下mysql手动方式安装</h1><p><a href="https://mirrors.huaweicloud.com/mysql/Downloads/MySQL-6.0/">https://mirrors.huaweicloud.com/mysql/Downloads/MySQL-6.0/</a></p>
<p>下载地址</p>
<img src="/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/Image.png" class="" title="Image">

<p>32位或者64位均可</p>
<img src="/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/Image-1664900250792-2.png" class="" title="Image">

<p>解压放在一个非中文目录下</p>
<img src="/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/Image-1664900274221-4.png" class="" title="Image">

<p>配置环境变量。</p>
<p>将配置文件复制到目录中，并且名称必须是my.ini，否则就需要通过参数指定配置文件了。</p>
<img src="/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/Image-1664900317498-6.png" class="" title="Image">

<p>my.ini文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">port=3306</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=gbk</span><br><span class="line">[mysqld]</span><br><span class="line">port=3306</span><br><span class="line">basedir=&quot;C:/App/mysql-6.0.11-alpha-win32&quot;</span><br><span class="line">datadir=&quot;C:/App/mysql-6.0.11-alpha-win32/data&quot;</span><br><span class="line">default-character-set=gbk</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">sql-mode=&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</span><br><span class="line">max_connections=800</span><br><span class="line">query_cache_size=84M</span><br><span class="line">table_cache=1520</span><br><span class="line">tmp_table_size=30M</span><br><span class="line">thread_cache_size=38</span><br><span class="line">myisam_max_sort_file_size=100G</span><br><span class="line">myisam_sort_buffer_size=30M</span><br><span class="line">key_buffer_size=129M</span><br><span class="line">read_buffer_size=64K</span><br><span class="line">read_rnd_buffer_size=256K</span><br><span class="line">sort_buffer_size=256K</span><br><span class="line">innodb_additional_mem_pool_size=6M</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_log_buffer_size=3M</span><br><span class="line">innodb_buffer_pool_size=250M</span><br><span class="line">innodb_log_file_size=50M</span><br><span class="line">innodb_thread_concurrency=10</span><br></pre></td></tr></table></figure>

<p>注意，该配置文件是从图形界面方式安装的mysql之后，从其my.ini配置文件中提取出来的内容。</p>
<p>之后，可以将mysql安装为Windows服务</p>
<p>PS C:\Users\Administrator&gt; mysqld –install MySQL –defaults-file&#x3D;”C:\App\mysql-6.0.11-alpha-win32\my.ini”</p>
<p>Service successfully installed.</p>
<p>PS C:\Users\Administrator&gt;</p>
<p>之后，就可以在services.msc中看到MySQL这个名字的Windows服务了。</p>
<p>这里要注意，上面mysqld命令的参数顺序，不要颠倒了，否则不生效。</p>
<p>PS C:\Users\Administrator&gt; mysqld –defaults-file&#x3D;”C:\App\mysql-6.0.11-alpha-win32\my.ini” –install MySQL</p>
<p>PS C:\Users\Administrator&gt;</p>
<p>这样就不行。</p>
<p>如果想要安装的Windows服务，不是自动启动的，可以–install-manual参数。</p>
<p>如果不想安装为Windows服务，想要直接在命令行下运行，并且看到实时输出，可以如下：</p>
<p>mysqld –defaults-file&#x3D;”C:\App\mysql-6.0.11-alpha-win32\my.ini” –console 即可。</p>
<p>删除MySQL服务</p>
<p>mysqld –remove MySQL即可。</p>
<hr>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>Install</category>
      </categories>
      <tags>
        <tag>MySQL-install</tag>
      </tags>
  </entry>
  <entry>
    <title>12-继承与多态</title>
    <url>/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="12-继承与多态"><a href="#12-继承与多态" class="headerlink" title="12-继承与多态"></a>12-继承与多态</h1><h2 id="方法重载复习"><a href="#方法重载复习" class="headerlink" title="方法重载复习"></a>方法重载复习</h2><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010170742931.png" class="" title="image-20221010170742931">

<p>方法重载（Overload）。表示两个或多个方法名字相同，但方法参数不同。</p>
<p>方法参数不同有两层含义：</p>
<p>1）参数个数不同。</p>
<p>2）参数类型不同。 </p>
<p>【注意】：方法的返回值对重载没有任何影响。</p>
<p><strong>不能根据返回值的类型来重载两个方法。</strong></p>
<p>构造方法也是可以重载的。</p>
<p>如果自己不定义构造方法，那么java会提供一个不带参数的默认构造方法，函数体是空的。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200659438.png" class="" title="image-20221010200659438">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200705686.png" class="" title="image-20221010200705686">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200713902.png" class="" title="image-20221010200713902">

<p>构造方法没有返回值。</p>
<p>构造方法之间也可以互相之间进行调用。但是注意，构造方法不能直接通过方法名来进行调用的，需要通过this来调用。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200821097.png" class="" title="image-20221010200821097">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200831348.png" class="" title="image-20221010200831348">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200840333.png" class="" title="image-20221010200840333">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200859875.png" class="" title="image-20221010200859875">

<p>这样写this报错。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200913085.png" class="" title="image-20221010200913085">

<p>编译错误。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200923724.png" class="" title="image-20221010200923724">

<p><strong>构造方法重载：</strong>只需看参数即可。如果想在一个构造方法中调用另外一个构造方法，那么可以使用this()的方式调用，this()括号中的参数表示目标构造方法的参数。this()必须要作为构造方法的第一条语句，换句话说，this()之前不能有任何可执行的代码。</p>
<p>为什么说方法的返回值对重载没有任何影响？对比如下两个程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b + c;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">OverloadTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OverloadTest</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> test.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">		System.out.println(result);</span><br><span class="line">		System.out.println(result2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src\Lesson <span class="number">1</span>&gt;java OverloadTest</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">OverloadTest2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OverloadTest2</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test.method(<span class="number">1</span>);</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> test.method(<span class="number">2</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010201054480.png" class="" title="image-20221010201054480">

<p>原因如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test.method(<span class="number">1</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> test.method(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>也可以写成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">test.method(<span class="number">1</span>);</span><br><span class="line">   test.method(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>当写成这种形式时，程序无法判断是否要调用哪个method方法，尽管他们返回值也不一样，所以返回值不能做重载的依据，重载的依据是根据它的参数来定的。</p>
<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010201720019.png" class="" title="image-20221010201720019">

<p><strong>继承（Inheritence）：Java是单继承的</strong>，意味着一个类只能从另一个类继承（被继承的类叫做父类【基类，base class】,继承的类叫做子类），<strong>Java中的继承使用extends关键字</strong>。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010201835653.png" class="" title="image-20221010201835653">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010201842422.png" class="" title="image-20221010201842422">

<p>首先new Child()的时候，会调用子类的不带参数的构造方法，找到，然后子类构造方法又会去调用父类的不带参数的构造方法。因此，是先调用父类构造方法，然后再执行子类构造方法。</p>
<p><strong>没有父亲，就没有孩子。注意，内存模型想象成就只有一个子类对象，然后这个子类对象中有需要父类对象的东西而已，就像孩子继承了父亲的一些特点一样，例如，眼睛，鼻子的特点，但是孩子仍然是单独的自己一个对象。不要认为在内存中是两个对象，一个父类对象，一个子类对象，这样不正确。</strong></p>
<p><strong>当执行子类的构造方法的时候，首先在执行第一行语句之前，首先是去寻找父类的不带参数的构造方法。</strong>即子类构造方法的第一句都是隐含的调用super()。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204500101.png" class="" title="image-20221010204500101">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204506951.png" class="" title="image-20221010204506951">

<p><strong>根据提示，是找父类的不带参数的那个构造方法，也就是默认的构造方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204652409.png" class="" title="image-20221010204652409">

<p><strong>注意，这里说法有问题，堆内存中就一个子类对象，只是子类对象中包含了从父类继承而来的属性，也可以简单的理解为这是父类对象。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204822093.png" class="" title="image-20221010204822093">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204838623.png" class="" title="image-20221010204838623">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;no args parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="super第一种用法（调用父类指定构造方法）"><a href="#super第一种用法（调用父类指定构造方法）" class="headerlink" title="super第一种用法（调用父类指定构造方法）"></a>super第一种用法（调用父类指定构造方法）</h3><p><strong>super</strong>，表示对父类对象的引用。即对堆内存中唯一的子类对象中父类属性部分的引用，也可以简单理解为对父类对象的引用。指向父类对象</p>
<p><strong>this，表示对当前自己的这个对象的引用。</strong>指向当前对象</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010205230808.png" class="" title="image-20221010205230808">

<p><strong>显示指定，调用父类的哪个构造方法</strong>。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010205255628.png" class="" title="image-20221010205255628">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">super</span>(<span class="number">7</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	public Parent()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;no args parent&quot;);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>super关键字：super表示对父类对象的引用。注意与this的关键字的区别</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010205535976.png" class="" title="image-20221010205535976">

<p><strong>如果子类使用super()显式调用父类的某个构造方法，那么在执行的时候就会寻找与super()所对应的构造方法而不会再去寻找父类的不带参数的构造方法。与this一样，super也必须要作为构造方法的第一条执行语句，前面不能有其他可执行语句。</strong></p>
<p>因此，可以知道，super()和this()不能在构造方法中同时出现的。</p>
<p>Super的目的，就是严格保证必须要先生成父类对象，然后再生成子类对象。否则父类对象没生成，那么子类就什么都干不了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">this</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//error Constructor call must be the first statement in a constructor</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(a,b);</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010205844149.png" class="" title="image-20221010205844149">

<p>父类对象和子类对象的内存地址排列是这样的，也就是内存地址中有两个对象了，一个是child一个是parent，它们在内存中是挨着放置的，连着放置的，然后child指向的是孩子这个对象，又，子类对象可以使用父类对象的某些东西，原因就是地址是连着存放的，因此，子类能够拿到父类对象的东西，知道父类对象在什么地方。</p>
<p>因此，一定要记住，继承的时候，一定是生成多个对象，每个层次都会生成对应的对象的。</p>
<p><strong>这里的说法是错误的。</strong></p>
<p><strong>注意，上面说法是错误的，堆中只有一个new的子类的那个对象，只是该对象中属性分为两部分，分别是来自继承父类的属性和子类自己的属性。注意，如果有多个层次继承关系，那么每个层次的属性，最终都会在new的最终这个子类对象当中的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210643613.png" class="" title="image-20221010210643613">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210650805.png" class="" title="image-20221010210650805">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210803343.png" class="" title="image-20221010210803343">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210818793.png" class="" title="image-20221010210818793">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">		System.out.println(apple.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;fruit&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>





<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210908959.png" class="" title="image-20221010210908959">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210917981.png" class="" title="image-20221010210917981">

<p>子类继承了，但是可以覆盖成自己的特点。</p>
<p><strong>可以对父类的属性name进行修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">		System.out.println(apple.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;fruit&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210944059.png" class="" title="image-20221010210944059">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210951972.png" class="" title="image-20221010210951972">

<p>这个表示的就是父类没有的属性，子类可以有。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">		System.out.println(apple.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	String name = &quot;fruit&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010211155026.png" class="" title="image-20221010211155026">

<p><strong>关于继承的3点：</strong></p>
<p>a) 父类有的，子类也有</p>
<p>b) 父类没有的，子类可以增加</p>
<p>c) 父类有的，子类可以改变</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010211224785.png" class="" title="image-20221010211224785">

<p><strong>关于继承的注意事项</strong></p>
<p>a) <strong>构造方法不能被继承</strong></p>
<p>b) 方法和属性可以被继承</p>
<p>c) <strong>子类的构造方法隐式地调用父类的不带参数的构造方法</strong></p>
<p>d) 当父类没有不带参数的构造方法时，子类需要使用super来显式地调用父类的构造方法，super指的是对父类的引用</p>
<p>e) super关键字必须是构造方法中的第一行语句。</p>
<p><strong>如果不显示调用super方法，那么每个子类构造方法的第一条语句都是隐含调用super()的。</strong></p>
<hr>
<h2 id="多态剖析"><a href="#多态剖析" class="headerlink" title="多态剖析"></a>多态剖析</h2><p>继承过程中，方法和属性类似，但是方法多点内容。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010211919029.png" class="" title="image-20221010211919029">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010211947387.png" class="" title="image-20221010211947387">

<p>说明，成员方法都是在代码区中被当前这个类的所有对象共享的，只有一份。可以理解为C++编译之后，将类中方法都解析为了代码区中的全局唯一的方法了。</p>
<p>当调用方法的时候，编译器转换为run(dog,xx,yy,zz)这样，即将当前对象作为第一个隐含参数传入给成员方法内部的this，而每个类的成员方法中的this的类型，就是当前这个类，例如，Animal中的run中的this，类型就是Animal，Dog中的成员方法中的this的类型就是Dog。</p>
<p>上例中，dog.run()调用run方法，首先根据dog的类型是Dog，因此，在代码区中Dog字节码区域中找run方法（注意，编译的时候，根据等号左边变量类型进行编译查看是调用哪个类中的成员方法的），发现没有，然后就会它的父类Animal中找这个继承的run方法，找到了，可以调用，然后将dog传入给Animal中run中的this，this的类型是Animal，可以接收子类对象，父类引用指向子类对象。但是此时在Animal中的run方法就只能访问到父类中的属性，而没有办法拿到子类中的特有的自己的属性了，原因是父类中方法run中的this是Animal类型的，它指向子类对象，但是类型是父类型，编译的时候是看等号左边根据类型进行编译，因此，this是Animal类型，那么run中就只能访问Animal中的属性。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010213205024.png" class="" title="image-20221010213205024">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010213444368.png" class="" title="image-20221010213444368">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010213528369.png" class="" title="image-20221010213528369">

<p><strong>方法的，名字一样，返回类型，参数也一样，这就是子类将父类的方法覆盖掉了。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010214158847.png" class="" title="image-20221010214158847">

<p><strong>方法重写（Override）：又叫做覆盖</strong>，子类与父类的方法<strong>返回类型一样、方法名称一样，参数一样</strong>，这样我们说子类与父类的方法构成了重写关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		dog.run();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;	</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010214406265.png" class="" title="image-20221010214406265">

<p><strong>此时两个run就不构成重写的关系了。</strong></p>
<p>所谓重写，就是子类将从父类继承过来的覆盖掉了，看不到了，用的就是子类中的了。</p>
<p><strong>上图中，就是从父类继承过来了一个run()方法，同时子类中自己又增加了一个run(int i)，这两个run之间构成了重载关系（应该不是重载，重载只是发生在同一个类中）。不构成覆盖关系。</strong></p>
<p>此时上面的dog.run调用的时候，如果dog.run()，调用的就是从父类继承而来的run了。</p>
<p><strong>注意，重载只是发生的同一个类中的。覆盖是发生在父类子类之间的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		dog.run(<span class="number">1</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">	&#123;	</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java InheritenceTest2</span><br><span class="line">dog is running</span><br></pre></td></tr></table></figure>

<p>【说明】次处就不应该是重写，子类从父类当中继承了run()方法，而本身一个带参数的run(int i)的方法，所以只能说子类对父类的run()方法进行了重载，此时子类当中应该有两个run方法，一个是带参数的，一个是不带参数的，所以如果main方法中传递不带参数的run方法，则程序执行结果不同，参考以下程序。<br><strong>注意，两个run方法仍然是分别在代码区中两个类Animal和Dog自己的字节码当中的。只是从逻辑上讲子类继承了父类，父类的方法也在子类中了而已。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		dog.run();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">	&#123;	</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java InheritenceTest2</span><br><span class="line">animal is running</span><br></pre></td></tr></table></figure>

<p>注意，编译的时候，是根据赋值号&#x3D;左边的变量类型来看对应类中是否有要调用的成员方法或者要访问的成员变量，如果有，那么编译通过的，如果没有，编译失败。而运行的时候，是看具体引用变量指向的是哪个对象，从而调用对应那个对象所属类型的方法的（这是多态内容）。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220242889.png" class="" title="image-20221010220242889">

<p><strong>方法重写与方法重载之间的关系：重载发生在同一个类内部的两个或多个方法。重写发生在父类与子类之间。重载是一种平行的关系，重写是一种层次关系，伴随着继承而发生的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220403437.png" class="" title="image-20221010220403437">

<p>在子类中不仅想执行自己的方法，还想调用父类被覆盖的方法。这个时候，可以使用super，表示对父类的引用。</p>
<h3 id="super第二种用法（子类覆盖父类成员方法之后，仍然想调用被覆盖的父类方法）"><a href="#super第二种用法（子类覆盖父类成员方法之后，仍然想调用被覆盖的父类方法）" class="headerlink" title="super第二种用法（子类覆盖父类成员方法之后，仍然想调用被覆盖的父类方法）"></a>super第二种用法（子类覆盖父类成员方法之后，仍然想调用被覆盖的父类方法）</h3><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220514961.png" class="" title="image-20221010220514961">

<p><strong>通过super调用父类中被覆盖了的方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220707682.png" class="" title="image-20221010220707682">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220718947.png" class="" title="image-20221010220718947">

<p><strong>Super是对父类对象的引用。因此super.run()，就是对父类对象的方法的调用。</strong></p>
<p>这里的super可以理解为堆区中new的子类对象中的从父类继承来的父类的属性那些部分所组成的部分，认为是父类对象。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221132394.png" class="" title="image-20221010221132394">

<p>super.run()，可以理解为run(super)，由于super是Animal类型，因此，调用的run自然是父类型中的run。因此，super传给父类型run方法中的this。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221308790.png" class="" title="image-20221010221308790">

<p><strong>这样是可以的，因为这里的super不是调用的父类的构造方法，是调用的父类的普通的方法，那么既然能够调用父类的普通方法，说明父类对象已经生成出来了。</strong></p>
<p><strong>而如果是构造方法中，那么就必须先去构造父类对象，然后才能构造子类对象。因此，对于构造方法来说，必须super()是第一条语句。而对于普通方法来说，就无所谓了。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221357409.png" class="" title="image-20221010221357409">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221421889.png" class="" title="image-20221010221421889">

<p>当两个方法形成重写关系时，可以在子类方法中通过super.run()形式调用父类的run()方法，其中super.run()不必放在第一行语句【此处super.run()与super();是不同的】，因为此时父类对象已经构造完毕，先调用父类的run()方法还是先调用子类的run()方法是根据程序的逻辑决定的。</p>
<p><strong>Java中类没有显示的继承，那么就是继承Object类的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221617310.png" class="" title="image-20221010221617310">

<p>在定义一个类的时候，如果没有显式指定该类的父类，那么该类就会继承于java.lang.Object类（JDK提供的一个类，Object类是Java中所有类的直接或间接父类）。Object类是Java中所有类的直接或间接父类。Object中的定义的十个方法每个都很重要，后续说明。</p>
<p><strong>当继承层次很多的时候，那么生成最底层子类对象的时候，上面每一层的构造方法都会自动被调用，创建对应的层次类的对象。</strong></p>
<p>继承中构造方法调用顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandpa</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Grandpa</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;grandpa&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">Grandpa</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java InheritenceTest3</span><br><span class="line">grandpa</span><br><span class="line">father</span><br><span class="line">son</span><br></pre></td></tr></table></figure>



<h3 id="多态基础"><a href="#多态基础" class="headerlink" title="多态基础"></a>多态基础</h3><p><strong>多态：多种形态。构建在封装以及继承基础之上的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222027981.png" class="" title="image-20221010222027981">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222035061.png" class="" title="image-20221010222035061">

<p>现在是Flower类型的引用变量，指向了Rose类型的对象。奔驰叫车是汽车。</p>
<p><strong>子类就是父类，这就是多态。男人是人。但是反之是不对的。</strong></p>
<p>Flower rose &#x3D; new Rose()，这里Rose()本身也是花，虽然本身玫瑰，但是子类就是父类，因此，可以认为就是花。因此，Flower类型的引用可以指向Rose类型的对象。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222132752.png" class="" title="image-20221010222132752">

<p>多态（Polymorphism）：我们说子类就是父类（玫瑰是花，男人是人），因此<strong>多态的意思就是：父类型的引用可以指向子类的对象</strong>。多态是构建在封装和继承之上的。</p>
<p>反之不行，不能用子类型的引用指向父类型的对象。</p>
<p><strong>查看java编程思想3版中的第七章，多态。看summary。总结。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222306412.png" class="" title="image-20221010222306412">

<p>多态就是不同形式。面向对象中，你有相同的脸（基类中通用的接口）和使用那个脸的不同的形式：动态绑定方法的不同的版本。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222340053.png" class="" title="image-20221010222340053">

<p>如果没有数据抽象（封装）和继承，那么我们不可能创建理解，创建一个多态的例子。多态是一个不能被孤立看待的一个特征，相反，应该在一个大的类关系的场景中，多态存在的，<strong>人们经常被其它的java中的非面向对象的特征所困扰，例如，方法重载，有时候被当作面向对象的特征，不要被愚弄，如果不是晚绑定，那么它就不是多态。对于方法的重载，它不是晚绑定，它是早绑定。</strong></p>
<p><strong>早绑定，编译期间的，也就是编译的时候，java编译器就知道参数是什么样的，如何进行调用的。</strong></p>
<p><strong>晚绑定，就是运行的时候，java才知道如何执行，编译的时候，java是不知道的。也就是只有运行的时候，才知道父类型的引用变量到底指向的是哪个子类的对象。这个在编译的时候，编译器只是看等号两边的类型是否是同一颗继承树上的，来判断语法是否正确，但是不知道这个引用变量到底指向哪个对象，因为对象还没创建呢。</strong></p>
<p><strong>方法重载，不是晚绑定，不是面向对象的特征，多态不是由它来决定的。多态是晚绑定的。如果不是晚绑定，就一定不是多态。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222955977.png" class="" title="image-20221010222955977">

<p>要使用多态，你必须扩展视角包括不仅仅是单独的类成员和方法，而且应该考虑不同类之间的关系。</p>
<p>因为多态能够实现更快的开发，代码的更好的组织，以及维护性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Flower</span> <span class="variable">rose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rose</span>(); <span class="comment">//多态</span></span><br><span class="line">		rose.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flower</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;flower is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rose</span> <span class="keyword">extends</span> <span class="title class_">Flower</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">flower is singing</span><br></pre></td></tr></table></figure>

<p>【说明】：Flower rose &#x3D; new Rose(); &#x2F;&#x2F;多态    Flower类型的引用指向Rose的对象。</p>
<hr>
<h3 id="多态详解1"><a href="#多态详解1" class="headerlink" title="多态详解1"></a>多态详解1</h3><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010223545556.png" class="" title="image-20221010223545556">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010223551498.png" class="" title="image-20221010223551498">

<p>Java源文件中可以定义多个类，这些类可以都不是public的，如果有public，那么最多只能有一个，并且文件的名字必须要public的类的名字相同。并且main方法必须在public类里面来进行定义（这个不是强制的，main方法也可以在非public的类当中，因为编译之后，每个类会产生一个class文件的，可以java去运行含有main方法的类的。而没有main方法的类，即使是public的，也没法运行的。另外，如果使用myeclipse的话，那么在一个文件中定义多个类，只能有一个类是public的，并且文件名就是这个类名，如果main方法定义在了其它的非public类中的话，那么在这个源文件中就不能右键-运行，因为在当前这个文件上点右键-运行，必须得是在这个public类中写main方法了。）。如果源文件中定义的多个类都不是public，那么源文件的名字可以随意。</p>
<p>方法的返回值类型，不能作为重载的条件。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224520330.png" class="" title="image-20221010224520330">

<p><strong>构造方法重载只看参数就行，因为，多个构造方法的名字肯定都是一样的，都是类名。</strong></p>
<p><strong>构造方法没有返回值类型的。也就是没有返回值。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224548054.png" class="" title="image-20221010224548054">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224554837.png" class="" title="image-20221010224554837">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224611299.png" class="" title="image-20221010224611299">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224634118.png" class="" title="image-20221010224634118">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224641469.png" class="" title="image-20221010224641469">

<p><strong>注意，super()和this()在构造函数中，不能同时出现，否则是矛盾的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225223376.png" class="" title="image-20221010225223376">

<p>13，覆盖说法不是很严格，后续学完其它内容会严格说明。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225251756.png" class="" title="image-20221010225251756">









<p><strong>多态：父类型的引用指向子类型的对象</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225430173.png" class="" title="image-20221010225430173">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225438880.png" class="" title="image-20221010225438880">

<p><strong>注意，引用变量指向谁，就会调用谁的方法。P虽然声明的是父类型的引用，但是程序运行起来之后，指向的是子类型的对象，因此，就会调用子类型对象的方法。只是在编译的时候，是根据赋值&#x3D;等号左边的类型去编译，看对应类型中是否有要调用的方法的，有，则编译通过，否则编译失败。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225627564.png" class="" title="image-20221010225627564">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225639907.png" class="" title="image-20221010225639907">

<p>现在将子类的方法注释掉。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225703268.png" class="" title="image-20221010225703268">

<p><strong>现在子类中没有显示定义这个方法了，那么由于从父类继承过来了sing这个方法了，因此，就会调用继承过来的方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225732085.png" class="" title="image-20221010225732085">

<p><strong>注意，编译的时候同理，仍然是看等号左边的类型来进行编译的。由于p的类型是Parent，而Parent中有sing方法，因此，能够编译通过。而如果父类中没有sing方法，而只是子类中新定义了一个sing方法，那么上面编译就会失败，因此，编译时候看等号左边，发现Parent中没有sing方法，那么就编译失败。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225907900.png" class="" title="image-20221010225907900">

<p>现在将父类的注释。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225925621.png" class="" title="image-20221010225925621">

<p><strong>现在父类没有sing方法，子类有sing方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225957428.png" class="" title="image-20221010225957428">

<p>可以看到，在Parent中找sing方法。找不到，报错。</p>
<p><strong>因为，编译的时候，jvm是看引用变量的类型当中是否有对应的方法来进行编译的，也就是静态的，因为还没运行，没有对象呢，自然不知道引用变量到底指向哪个对象的。</strong></p>
<p><strong>也就是说p虽然是指向子类对象的引用，但是p这个变量的类型是Parent，而Parent中现在没有sing方法，也就是说，对于多态，父类型的引用变量，指向子类型的对象，然后调用了子类对象的某个方法，那么就要求，这个方法必须在父类中也要存在，因为这个p本身是父类型的。那么什么类型的才能使用什么类型的方法，虽然实际指向的是子类的对象。不能说父类中没有这个方法，子类中有，然后进行调用，这样调用不了的，编译的时候，看到的p的类型就是Parent类型的，因此首先就是检查父类中是否有这个方法的。如果有这个方法，然后在执行的时候，创建了对象了，父类型引用指向了子类型对象了（动态绑定），再去子类对象中调用不管是继承过来的还是重写的那个sing方法。</strong></p>
<p>因此，要分清两个时机：编译时（类型中是否有成员方法或者成员变量检查）和运行时（动态绑定）</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010232134731.png" class="" title="image-20221010232134731">

<p><strong>编译的时候，肯定是看什么类型的引用变量，那么就调用什么类型里面的方法，是这种规则去编译检查的。因为编译的时候，还不能确定p到底指向的是什么对象，也就是说，编译的时候，都是字面上看到的，都是静态的，而new的对象是在运行的时候才会创建的。只有运行的时候，才知道p指向的具体的对象是谁，动态绑定。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line">		parent.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;parent is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;child is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">parent is singing</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	Parent parent = new Parent();</span></span><br><span class="line"><span class="comment">//	parent.sing();</span></span><br><span class="line">	<span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">	child.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">child is singing</span><br></pre></td></tr></table></figure>

<p>上面这两种情况都不是多态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	Parent parent = new Parent();</span></span><br><span class="line"><span class="comment">//	parent.sing();</span></span><br><span class="line"><span class="comment">//	Child child = new Child();</span></span><br><span class="line"><span class="comment">//	child.sing();</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">Parent</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">	p.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">child is singing</span><br></pre></td></tr></table></figure>

<p>多态。</p>
<p>【说明】：Parent p &#x3D; new Child(); p类型是父类型，<strong>看类型是要左边的那个Parent</strong>。指向了子类生成的属性，接下来调用sing();方法，指向child(),就调用子类的方法，所以输出子类的方法，指向谁就调用谁的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	Parent parent = new Parent();</span></span><br><span class="line">	<span class="comment">//	parent.sing();</span></span><br><span class="line">	<span class="comment">//	Child child = new Child();</span></span><br><span class="line">	<span class="comment">//	child.sing();</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Parent</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">		p.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;parent is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	public void sing()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;child is singing&quot;);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">parent is singing</span><br></pre></td></tr></table></figure>

<p>【说明】：此时子类继承了父类的sing()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	Parent parent = new Parent();</span></span><br><span class="line">	<span class="comment">//	parent.sing();</span></span><br><span class="line">	<span class="comment">//	Child child = new Child();</span></span><br><span class="line">	<span class="comment">//	child.sing();</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Parent</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">		p.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">	public void sing()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;parent is singing&quot;);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;child is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest.java</span><br><span class="line">PolyTest.java:<span class="number">11</span>: 错误: 找不到符号</span><br><span class="line">                p.sing();</span><br><span class="line">                 ^</span><br><span class="line">  符号:   方法 sing()</span><br><span class="line">  位置: 类型为Parent的变量 p</span><br><span class="line"><span class="number">1</span> 个错误</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【说明】：p是指向子类对象的引用，但是p还是Parent类型的，而Parent中没有这个方法,对于多态可以这样理解，即便p是指向子类，但是必须在p所在类型Parent中必须存在这个方法，才可以调用。p在调用子类的方法的时候，会去检查p所在类型是否有这个方法，如果有的话，就调用子类的方法，否则报错。</p>
<p><strong>Parent p &#x3D; new Child();当使用多态方式调法时，首先检查父类中是否有sing()方法,如果没有则编译出错；如果有再去调用子类的sing()方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010232355466.png" class="" title="image-20221010232355466">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010232407838.png" class="" title="image-20221010232407838">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233148296.png" class="" title="image-20221010233148296">

<p><strong>父类型的引用转换为子类型的引用，向下类型转换。转换的原则是，这个引用变量实际指向的是什么类型的，那么就向下转换为什么类型的。</strong><br><strong>转换之后，那么就能调用子类型中的特有的方法了（子类中新增的，不是从父类继承而来的），父类型中方法仍然能够调用（因为子类中如果没有覆盖的，那么就会去父类中找）。因为，在编译阶段，引用变量到底能够调用什么方法，主要是看它的类型的，看它类型中有什么方法的。是在编译阶段的。</strong><br><strong>向下类型转换的另外一个目的，就是可以调用子类中特有的方法，在父类中没有的方法了。否则不转换的话，直接调用子类中特有的方法，编译会报错，因为编译的时候是看等号左边引用变量的类型的，而此时a的类型是Animal，它里面肯定没有子类中新增的特有的方法的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233717761.png" class="" title="image-20221010233717761">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233748051.png" class="" title="image-20221010233748051">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233807474.png" class="" title="image-20221010233807474">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233814291.png" class="" title="image-20221010233814291">

<p>这样是错误的。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233833440.png" class="" title="image-20221010233833440">

<p><strong>编译是能够通过的，因为，编译的时候，不知道b到底是指向谁呢，只有运行的时候，才会知道。编译的时候只是知道b的类型是Animal类型。</strong></p>
<p><strong>也就是编译的时候，只要看类型转换的时候，等号两边变量的类型是否在同一颗继承树上，是同一颗继承树，就允许你转换。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233935947.png" class="" title="image-20221010233935947">

<p>运行时错误。</p>
<p><strong>因此，向下类型转换，就是这个引用变量指向哪个子类对象，那么就能够转换为那个子类的引用。指向谁，就转成谁。</strong></p>
<p><strong>通过上面可以看到，编译时候没错，运行时报错，因此，多态是一个运行期的行为，而不是编译期的行为。也就是java程序，只有到真正运行的时候，才知道这个b到底是指向的什么对象。编译的时候，只是知道b是Animal类型的，但是具体指向谁是不知道的，因为右边的new对象，还没有开辟内存创建对象呢。</strong></p>
<p><strong>编译的时候，只是知道b是Animal类型的，而d是Dog类型的，在同一个继承树上的上下继承关系，因此，能够向下类型转换。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">		dog.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;cat is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">dog is singing</span><br></pre></td></tr></table></figure>

<p>【说明】：Animal a &#x3D; new Dog(); Dog dog &#x3D; (Dog)a;这两条语句是一个强制类型转换，将一个父类型的引用强制转为子类型的引用,这在多态中叫做向下类型转换，注意的是它实际指向的是谁，才能转换成谁。比如a实际指向的是Dog对象，所以才能强制类型转换为Dog类型的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">dog.sing();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)b;</span><br><span class="line">cat.sing();</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest2</span><br><span class="line">dog is singing</span><br><span class="line">cat is singing</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">dog.sing();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)b;</span><br><span class="line">d.sing();</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest2.java</span><br><span class="line">D:\src&gt;java PolyTest2</span><br><span class="line">dog is singing</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: Cat cannot be cast to Dog</span><br><span class="line">        at PolyTest2.main(PolyTest2.java:<span class="number">9</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【说明】:这个程序在编译的时候没有提示错误，在执行字节码文件时候出现错误，提示类转换异常：猫不能转换成狗。因为b指向的是Cat类型的对象，而在转换后变成b指向了Dog类型的引用，所以出错。向下类型转换的引用指向那个对象，才能强制类型转换为这个类型的引用。</p>
<hr>
<h3 id="多态详解2"><a href="#多态详解2" class="headerlink" title="多态详解2"></a>多态详解2</h3><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011000538482.png" class="" title="image-20221011000538482">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011000543778.png" class="" title="image-20221011000543778">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"> </span><br><span class="line">		animal2 = animal;</span><br><span class="line">		animal2.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;cat is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093251866.png" class="" title="image-20221011093251866">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093258188.png" class="" title="image-20221011093258188">

<p><strong>指向谁，就调用谁的方法。类型转换的时候，就转换成谁。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Animal animal = new Cat();</span></span><br><span class="line"><span class="comment">Animal animal2 = new Animal();</span></span><br><span class="line"><span class="comment">animal2 = animal;</span></span><br><span class="line"><span class="comment">animal2.sing();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"> </span><br><span class="line">animal = animal2;</span><br><span class="line">animal.sing();</span><br></pre></td></tr></table></figure>



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093320821.png" class="" title="image-20221011093320821">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093340701.png" class="" title="image-20221011093340701">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093349478.png" class="" title="image-20221011093349478">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093355815.png" class="" title="image-20221011093355815">

<p><strong>可以看到，编译通过（向下类型转换），运行时错误。因为编译的时候，只要看左右两边变量类型是在同一颗继承树上，那么就没问题。</strong></p>
<p><strong>因为Cat是Animal的一个子类，因此，在编译的时候，编译器只是知道这些信息，但是animal这个变量到底指向的是谁，只有在执行的时候才能够确定下来，而在执行的时候，jvm发现，animal指向的是一个Animal类型的对象而不是指向的Cat类型的对象，那么强制转为Cat类型，就肯定错误的了，就例如，将动物强制转换为猫，就肯定不对了。指向谁才能转换成谁，例如，指向Cat才能转换为Cat。现在指向的是Animal，就不能转为Cat。</strong></p>
<p><strong>注意，所谓的奔驰轿车是汽车，这种说法，是从继承多态的角度来说的，也就是说的都是等号左边的类型，而不是具体的实例对象，也就是说的奔驰轿车是指子类型，汽车是父类型。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Animal animal = new Cat();</span></span><br><span class="line"><span class="comment">Animal animal2 = new Animal();</span></span><br><span class="line"><span class="comment">animal2 = animal;</span></span><br><span class="line"><span class="comment">animal2.sing();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Animal animal = new Cat();</span></span><br><span class="line"><span class="comment">Animal animal2 = new Animal();</span></span><br><span class="line"><span class="comment">animal = animal2;</span></span><br><span class="line"><span class="comment">animal.sing();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Cat cat = new Cat();</span></span><br><span class="line"><span class="comment">Animal animal = cat;</span></span><br><span class="line"><span class="comment">animal.sing();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)animal;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest2.java</span><br><span class="line">D:\src&gt;java PolyTest2</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: Animal cannot be cast to Cat</span><br><span class="line">        at PolyTest2.main(PolyTest2.java:<span class="number">25</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【说明】：在编译的时候系统只知道Cat是Animal的子类，具体Animal指向谁只有在执行的时候才能够发现，当执行的时候发现animal的引用指向的是animal类型的对象，此时把它强制转换为cat，系统就会提示错误，就好比如将一个人强制的转换成一个男人，这样是不对的。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093916309.png" class="" title="image-20221011093916309">

<p>一共有两种类型的强制转换：</p>
<p>a) 向上类型转换(upcast):比如说将Cat类型转换为Animal类型,即将子转换为父类型。</p>
<p>b) 向下类型转换(downcast):比如将Animal类型转换为Cat类型。即将父转换为子类型。对于向下，必须要显式指定(必须要使用强制类型转换)。</p>
<p><strong>注意，向下类型转换的时候，转换的都是等号左边的引用变量的类型，而不是堆中的对象，堆中的对象就是对应的实际的类型的对象，不能进行类型转换的。</strong></p>
<p>Animal animal &#x3D; new Cat()，这就是向上类型转换。</p>
<p>Cat cat &#x3D; new Cat()</p>
<p>Animal animal &#x3D; cat</p>
<p>animal.sing()</p>
<p>这种也是向上类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向上类型转换</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="comment">//Animal animal = (Animal)cat;这种写法也可以，但是通常不需要显示的制定，因为向上类型转换通常认为子类就是父类了，不需要强制类型转换。</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> cat;</span><br><span class="line">animal.sing();</span><br></pre></td></tr></table></figure>



<p><strong>多态中，子类就是父类，这种说法是对的。但是父类就是子类，这种说法就不对，因为父类引用必须是指向子类对象，才能说父类就是子类。</strong></p>
<p><strong>向下类型转换的时候，要看父类型的引用到底指向的是谁，如果父类型的引用就是指向的父类型的对象，那么就不能向下类型转换了。编译通过，运行的时候就错误。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011094946893.png" class="" title="image-20221011094946893">

<p><strong>这里调用a.sing()和调用cat.sing()效果一样的，因为都指向的Cat类型的对象。但是为何还要使用向下类型转换呢？原因是，父类没有的，子类可以添加，也就是子类中可能具有父类没有的方法，因此，这个时候，就只能向下转换为子类引用，然后才能调用子类特有的方法。如果不向下类型转换的话，那么这个引用变量的类型就是父类型的，而调用方法的时候，编译器是看等号左边变量类型确定调用哪个类方法的，是根据变量的类型中有什么方法来进行调用的，这样就只能调用父类型中有的方法了。因此，就需要进行向下类型转换才行。</strong></p>
<p>【说明】:在向下类型转换中，比如这个程序调用c.sing();方法和调用a.sing();方法执行效果是一样的，为什么还要做这种先下类型转换呢?比如说父类中3个方法，子类继承了或者重写了父类的三个方法，此时使用向下类型转换意义不大，因为调用使用与不使用都是调用子类这三个方法一个。但是有一种情况是，假如这个子类自己添加了5个方法，此时父类有3个方法，子类有8个方法，此时如果调用a.sing();这种方法时只能调用在子类当中存在于父类当中的那三个方法，其他五个方法是没法调用到的，因为a是父类型，所以只能调用父类型中有的方法，此时如果使用向下转型之后,调用c.sing();此时c是属于子类型的所以可以调用子类当中的所有方法，这就是使用向下类型转换的原因。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011095445186.png" class="" title="image-20221011095445186">

<p><strong>因为编译的时候是看等号左侧的引用变量的类型，来确定调用的成员方法是否合法，如果不向下类型转换，那么引用变量的类型是父类型，那么就只能看到父类型中的那些成员方法的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100454704.png" class="" title="image-20221011100454704">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100505293.png" class="" title="image-20221011100505293">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100518872.png" class="" title="image-20221011100518872">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100527742.png" class="" title="image-20221011100527742">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100542693.png" class="" title="image-20221011100542693">

<p>上面这个程序，是否使用强制类型转换，其实无所谓。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100602190.png" class="" title="image-20221011100602190">

<p>grow方法是子类中新增的成员方法。</p>
<p>子类添加特有的方法。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100629886.png" class="" title="image-20221011100629886">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100640042.png" class="" title="image-20221011100640042">

<p><strong>编译的时候，只能看到f是Fruit类型的，因此，去到这个类型中看是否有这个grow方法，有才能编译通过。而父类中是没有这个方法的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="comment">//不使用强制类型转换</span></span><br><span class="line">		<span class="type">Fruit</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">		f.grow();</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//使用强制类型转换</span></span><br><span class="line">	<span class="comment">//	Fruit f = new Pear();</span></span><br><span class="line">	<span class="comment">//	Pear p = (Pear)f;</span></span><br><span class="line">	<span class="comment">//	p.grow();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;fruit is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pear</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;pear is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;pear is growing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest3.java</span><br><span class="line">PolyTest3.java:<span class="number">7</span>: 错误: 找不到符号</span><br><span class="line">                f.grow();</span><br><span class="line">                 ^</span><br><span class="line">  符号:   方法 grow()</span><br><span class="line">  位置: 类型为Fruit的变量 f</span><br><span class="line"><span class="number">1</span> 个错误</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101327594.png" class="" title="image-20221011101327594">

<p><strong>现在强制类型转换，然后p的类型就是Pear，那么编译的时候，看到的Pear里面有grow方法，所以，编译通过。</strong></p>
<p>向下类型转换。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101411833.png" class="" title="image-20221011101411833">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="comment">//不使用强制类型转换</span></span><br><span class="line">	<span class="comment">//	Fruit f = new Pear();</span></span><br><span class="line">	<span class="comment">//	f.grow();</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//使用强制类型转换</span></span><br><span class="line">		<span class="type">Fruit</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">		<span class="type">Pear</span> <span class="variable">p</span> <span class="operator">=</span> (Pear)f;</span><br><span class="line">		p.grow();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;fruit is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pear</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;pear is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;pear is growing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest3</span><br><span class="line">pear is growing</span><br></pre></td></tr></table></figure>



<p><strong>因此，强制类型转换，是在子类中具有子类特有的方法，父类中没有这个方法的时候，才有使用的必要。</strong></p>
<p><strong>多态是运行期的行为，不是编译期的行为，此前的例子，都是在编译的时候，眼睛直接能够看到引用变量指向的是谁，下面的例子是在编译的时候，我们眼睛看不出指向的是谁，只有运行的时候才知道。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101546262.png" class="" title="image-20221011101546262">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101552998.png" class="" title="image-20221011101552998">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101603512.png" class="" title="image-20221011101603512">

<p>这就说明了多态是运行期的行为，只有运行的时候，才知道调用哪个类的method方法。</p>
<p>编译之后，java执行环境不知道，a到底现在是指向的哪个对象，只有运行的时候才会知道。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101642242.png" class="" title="image-20221011101642242">

<p>【说明】：编译的时候不知道a指向的是哪个方法，只有在执行的时候输入一个参数来确定具体执行哪个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">&quot;1&quot;</span>)) <span class="comment">//命令行输入1时执行if里面的语句。</span></span><br><span class="line">		&#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="title class_">B</span>();	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">&quot;2&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">&quot;3&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		a.method();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest4.java</span><br><span class="line">D:\src&gt;java PolyTest4 <span class="number">1</span></span><br><span class="line">B</span><br><span class="line">D:\src&gt;java PolyTest4 <span class="number">2</span></span><br><span class="line">C</span><br><span class="line">D:\src&gt;java PolyTest4 <span class="number">3</span></span><br><span class="line">D</span><br></pre></td></tr></table></figure>



<p><strong>这就是晚绑定，也就是编译的时候，不知道，只有执行的时候，才能确定跟哪个对象绑定。编译的时候，不知道a到底指向哪个对象。</strong></p>
<p><strong>上面的程序，目前来说，无法实现向下类型转换，因为要向下类型转换，必须明确知道a指向的是谁，但是现在a到底指向谁只有运行的时候才知道。这个需要反射学完才能解决。这个向下类型转换只有运行期的时候才能知道，而反射正好是一个运行期的东西。</strong></p>
<p><strong>所谓晚绑定，就是只有在运行的时候，才能够确定等号左边的引用变量，具体是和哪个对象（父类对象还是子类对象）绑定的，也就是具体是指向哪个对象的。</strong></p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest5</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(BMW bmw)</span></span><br><span class="line">	&#123;</span><br><span class="line">		bmw.run();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(QQ qq)</span></span><br><span class="line">	&#123;</span><br><span class="line">		qq.run();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">PolyTest5</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PolyTest5</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="type">BMW</span> <span class="variable">bmw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BMW</span>();</span><br><span class="line">		test.run(bmw);</span><br><span class="line"> </span><br><span class="line">		<span class="type">QQ</span> <span class="variable">qq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QQ</span>();</span><br><span class="line">		test.run(qq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;car is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;bmw is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QQ</span> <span class="keyword">extends</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;qq is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest5</span><br><span class="line">bmw is running</span><br><span class="line">qq is running</span><br></pre></td></tr></table></figure>

<p>那么现在又增加了很多车型，都继承了Car这个类，然后在PloyTest5中相应的就要增加对应处理这个车的run方法。这样，显然麻烦，那么为何不使用一个方法，然后能够处理所有的车型。这样比较好。</p>
<p>【说明】：这个程序的缺点是如果再添加子类，在子类中又添加方法，此时相应的也需要在PolyTest5类中继续定义run()方法，此种效果比较差，如果用只用一个方法来实现这种机制是最好，所以引申出下面这个程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest5</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Car car)</span></span><br><span class="line">	&#123;</span><br><span class="line">		car.run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">PolyTest5</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PolyTest5</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//有以下两种方式。</span></span><br><span class="line">		<span class="comment">//用父类型的引用生成子类型的对象</span></span><br><span class="line">		<span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BMW</span>();</span><br><span class="line">		test.run(car);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//向上类型转换</span></span><br><span class="line">		<span class="type">QQ</span> <span class="variable">qq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QQ</span>();</span><br><span class="line">		test.run(qq);</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;car is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;bmw is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QQ</span> <span class="keyword">extends</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;qq is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest5</span><br><span class="line">bmw is running</span><br><span class="line">qq is running</span><br></pre></td></tr></table></figure>

<p>【说明】：这种程序比较容易维护，如果子类继续添加，只要知道父类，子类就都可以作为参数传上去，因为Car是父类型，子类型的引用都可以传上去，实现先上转型，一个方法就可以应付所有的此类需求，这就是多态度给我们带来的好处，它屏蔽掉了子类的差异性，用一个公共的父类去标示着接口，不管增加了多少子类，都可以通过将父类型的引用作为一个参数，具体的子类引用传过去就可以了。</p>
<p><strong>这就是多态的作用，使用一个公共的方法，屏蔽了，各个子类之间的不同，只需要一个run方法即可了。</strong></p>
<hr>
<h3 id="多态详解3"><a href="#多态详解3" class="headerlink" title="多态详解3"></a>多态详解3</h3><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011103811265.png" class="" title="image-20221011103811265">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011114258348.png" class="" title="image-20221011114258348">



<p>抽象类(abstract class)：使用了abstract关键字所修饰的类叫做抽象类。抽象类无法实例化，也就是说，不能new出来一个抽象类的对象(实例)。</p>
<p><strong>含有抽象方法的类，必须定义为抽象类。但是抽象类中不一定就必须有抽象方法。抽象类中可以什么都没有。也可以全都是具体方法</strong></p>
<p><strong>抽象方法是有声明，无实现。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011114404739.png" class="" title="image-20221011114404739">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac Test.java</span><br><span class="line">Test.java:<span class="number">5</span>: 错误: T是抽象的; 无法实例化</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">                      ^</span><br><span class="line"><span class="number">1</span> 个错误</span><br></pre></td></tr></table></figure>

<p><strong>【说明】：以上程序错误的原因是抽象类不能被实例化</strong></p>
<p><strong>抽象方法(abstract method)：使用abstract关键字所修饰的方法叫做抽象方法(有声明，无实现)。抽象方法需要定义在抽象类中。相对于抽象方法，之前所定义的方法叫做具体方法(有声明，有实现)。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例程序中定义一个抽象方法：public abstract void method();注意直接用分号结束，没有花括号，没有花括号表示没有实现这个方法，注意的是如果有花括号即便是花括号里面没有内容，这也算是有实现的，只不过这个方法体为空，空实现。</p>
<p>如果一个类包含了抽象方法，那么这个类一定是抽象类。</p>
<p>如果某个类是抽象类，那么该类可以包含具体方法(有声明，有实现)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成功。</p>
<p>如果一个类中包含了抽象方法，那么这个类一定要声明成abstract class，也就是说，该类一定是抽象类；反之，如果某个类是抽象类，那么该类既可以包含抽象方法，也可以包含具体方法，甚至什么都不包含也是可以的。</p>
<p>无论何种情况，只要一个类是抽象类，那么这个类就无法实例化。</p>
<p>在子类继承父类（父类是个抽象类）的情况下，那么该子类必须要实现父类中所定义的所有抽象方法；如果子类不实现父类的所有方法，否则，该子类需要声明成一个abstract class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac Test.java</span><br><span class="line">Test.java:<span class="number">18</span>: 错误: R不是抽象的, 并且未覆盖T中的抽象方法method()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">^</span><br><span class="line"><span class="number">1</span> 个错误</span><br></pre></td></tr></table></figure>



<p><strong>两种解决办法：</strong></p>
<p><strong>第一种实现父类的抽象方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>第二种，将子类转为抽象类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	R r = new R();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【说明】：此时子类还是不能被实例化，如果想使用这个子类，还必须定义一个R的一个子类，把method的方法实现出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	R r = new R();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【说明】：R继承了T，则R类里面有两个方法，一个方法是实现T的抽象方法，另外一个是从T当中继承下来的具体方法test()；此时把R声明为抽象类正常，应该抽象类本身可以包含具体方法，也可以包含抽象方法。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011114418322.png" class="" title="image-20221011114418322">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011114423408.png" class="" title="image-20221011114423408">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115547897.png" class="" title="image-20221011115547897">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115554010.png" class="" title="image-20221011115554010">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115608256.png" class="" title="image-20221011115608256">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115620734.png" class="" title="image-20221011115620734">

<p><strong>这里就是R这个类没有实现父类的method抽象方法，那么这个R就要定义为抽象类。否则就应该实现method方法才行。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115710007.png" class="" title="image-20221011115710007">

<p>此时编译就能够通过了。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115750204.png" class="" title="image-20221011115750204">

<p>或者这样，但是此时就不能实例化R这个类了。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115821775.png" class="" title="image-20221011115821775">

<p>也可以这样。但是R不能实例化。现在的情况就是R实现了T的method方法，然后R又定义为抽象类。</p>
<p><strong>抽象类和抽象方法的作用，就是在抽象类中定义抽象方法，然后作为一种声明，告诉这个方法是干什么用的，但是具体的实现是由子类的实现者来去完成的。不同的子类，可能有自己不同的实现方式，但是最终的目的都是这个方法声明要实现的目的，只是实现的方式不同。</strong></p>
<p>例如，定义一个排序方法，父类中定义一个抽象方法排序，但是具体的如何排的，那么我不管，不同子类自己去实现这个功能即可。</p>
<p>构造方法的作用是完成初始化的作用，就是对成员变量进行一些赋初值的操作。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011140913527.png" class="" title="image-20221011140913527">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011140941008.png" class="" title="image-20221011140941008">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011140956204.png" class="" title="image-20221011140956204">

<p><strong>因此，抽象类目的就是定义规则，而具体的规则如何实现是子类来进行的。</strong></p>
<p>抽象方法，抽象类有什么作用，有声明没实现？<br>这个实现是推迟到子类当中去实现的，父类实现不了，父类可以声明一个抽象方法，写一个注释，告诉这个类的实现者，告诉它我这个方法有什么用，可以让子类去实现，对于一个父类来说，可以有多个子类，而不同的子类可以实现不同的方法。比如说在父类中定义一个排序的抽象方法，而在这个父类的各个子类当中可以分别实现这个抽象方法，具体子类实现方法有可能是用冒泡排序，有可能是用哈希排序，每种实现规则的不一样，从这一点可以看出，抽象类和抽象方法主要起到一个规范，约束的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>(<span class="number">10</span>,<span class="number">6</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> shape.computerArea();</span><br><span class="line">		System.out.println(<span class="string">&quot;triangle:&quot;</span> + area);</span><br><span class="line">		</span><br><span class="line">		shape = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//前面area用完，shape指向完已经关闭，下面可以不用定义直接使用。     </span></span><br><span class="line">		area = shape.computerArea();</span><br><span class="line">	        System.out.println(<span class="string">&quot;rectangle&quot;</span> + area);	</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">computerArea</span><span class="params">()</span>; <span class="comment">//计算形状面积</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> width;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Triangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span>  <span class="comment">//用构造方法来完成一些初始化工作</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//注意此处用this是因为声明完构造方法之后，把方法外面的int width;和int height;给屏蔽掉了，所以这个地方要访问到外面的width和height成员变量就用this，this表示对自己的引用。这样就把方法参数传给成员变量。</span></span><br><span class="line">		<span class="built_in">this</span>.width = width;     </span><br><span class="line">		<span class="built_in">this</span>.height = height;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computerArea</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> width * height / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> width;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> width,<span class="type">int</span> height)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.width = width;</span><br><span class="line">		<span class="built_in">this</span>.height = height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computerArea</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> width * height;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java Test2</span><br><span class="line">triangle:<span class="number">30</span></span><br><span class="line">rectangle100</span><br></pre></td></tr></table></figure>

<p>【说明】：从这个例子说可以看到抽象方法起到规范，规则子类行为的作用，具体怎么实现满足这个规则由子类去实现。约束规则，比如说定义什么类型，传递什么参数等。</p>
<p><strong>抽象类不能实例化，但是可以有构造方法。</strong></p>
<p><strong>因为对于继承的子类而言，子类将抽象基类中的抽象方法都实现了，那么子类就可以实例化了，那么实例化的子类对象中的对象属性部分，就有来自抽象父类的成员变量部分，那么这个部分就需要子类构造方法中去super来调用抽象父类中的构造方法来对来自父类中的属性进行初始化。因为在子类中是没有办法直接对继承来的父类中的属性进行初始化的，因为这些属性是在父类中的，因此，需要使用父类的构造方法去初始化这些父类中的属性。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo15</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo15</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;demo15&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16</span> <span class="keyword">extends</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo16</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;demo16&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Demo16</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo16</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo15</span><br><span class="line">Demo16</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16</span> <span class="keyword">extends</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo16</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;demo16&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Demo16</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo16</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Demo16</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>windows配置为openssh服务端可远程登录</title>
    <url>/2022/10/04/Windows/Service/windows%E9%85%8D%E7%BD%AE%E4%B8%BAopenssh%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>windows的openssh服务端</p>
<p><a href="https://github.com/PowerShell/Win32-OpenSSH/releases">https://github.com/PowerShell/Win32-OpenSSH/releases</a></p>
<p>配置方式如下：</p>
<p>下载安装包，32位或64位，解压，放置在任意目录。</p>
<img src="/2022/10/04/Windows/Service/windows%E9%85%8D%E7%BD%AE%E4%B8%BAopenssh%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/970770-20200922123950524-1846829508.png" class="" title="img">

<p>右键-使用powershell运行</p>
<img src="/2022/10/04/Windows/Service/windows%E9%85%8D%E7%BD%AE%E4%B8%BAopenssh%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/970770-20200922124036665-1851354777.png" class="" title="img">

<p>将openssh ssh server设置为自动启动即可。</p>
<img src="/2022/10/04/Windows/Service/windows%E9%85%8D%E7%BD%AE%E4%B8%BAopenssh%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/970770-20200922124117194-664861249.png" class="" title="img">

<p>如想卸载，右键-powershell运行uninstall-sshd.ps1即可。</p>
<p>ps：如右键-powershell运行报错，“无法加载文件….，因为在系统中进制执行脚本”。则执行如下操作即可。</p>
<p>使用管理员身份打开powershell</p>
<p>执行set-ExecutionPolicy RemoteSigned</p>
<p>之后，脚本即可正常运行。</p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>Service</category>
      </categories>
      <tags>
        <tag>openssh</tag>
      </tags>
  </entry>
  <entry>
    <title>HCIA-Cloud-01</title>
    <url>/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/</url>
    <content><![CDATA[<h1 id="HCIA-Cloud"><a href="#HCIA-Cloud" class="headerlink" title="HCIA-Cloud"></a>HCIA-Cloud</h1><h2 id="01-上午"><a href="#01-上午" class="headerlink" title="01-上午"></a>01-上午</h2><h3 id="云计算简介"><a href="#云计算简介" class="headerlink" title="云计算简介"></a>云计算简介</h3><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101171813050.png" class="" title="image-20221101171813050">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101171831934.png" class="" title="image-20221101171831934">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101171838958.png" class="" title="image-20221101171838958">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101171844802.png" class="" title="image-20221101171844802">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101171856429.png" class="" title="image-20221101171856429">

<p>华为的官网，这些是公有云能够提供的服务。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172008493.png" class="" title="image-20221101172008493">

<p>基于华为自主研发的芯片的。华为自主研发的AI智能芯片。</p>
<p>如图这里有面向各种业务类型提供的智能服务。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172055084.png" class="" title="image-20221101172055084">

<p>这里都是偏向云存储的内容。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172145965.png" class="" title="image-20221101172145965">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172152878.png" class="" title="image-20221101172152878">

<p>相比传统IT行业而言的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172204089.png" class="" title="image-20221101172204089">

<p>计算资源池。</p>
<p>存储资源池。</p>
<p>网络资源池。</p>
<p>我们使用vm和存储和网络，那么就从相应池中来拿对应的大小。</p>
<p>除此之外，还可以提供数据库资源池，就是按需，可以创建自己对应的数据库。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172234739.png" class="" title="image-20221101172234739">

<p>可计量服务，就是可以按照你的使用量去收费。例如，你使用了8核心64g的机器，那么收费多少。</p>
<p>可计量服务，正常来讲是按使用时间或者使用量来收费，但是并没有到达这么细粒度的层面的。而只是按照你使用的单位去收费的，例如，购买了8核64g的机器，那么一年收费多少。也就是计算的是资源的使用单位，并不是说按照你使用时间之类的进行计费的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172314285.png" class="" title="image-20221101172314285">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172322226.png" class="" title="image-20221101172322226">

<p>云计算不是一门单一的技术，它是一种架构模型，内部使用了非常多的技术的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172340982.png" class="" title="image-20221101172340982">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172349646.png" class="" title="image-20221101172349646">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172414843.png" class="" title="image-20221101172414843">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172432991.png" class="" title="image-20221101172432991">

<p>最早出现的是串行计算，效率很低，淘汰了。</p>
<p>并行计算，就是指一台服务器上，多个处理器并行处理任务。如图就是将一个problem拆分成多个part，然后交给不同的处理器去并行的处理。就是将一个复杂任务拆分成多个部分，交个不同的cpu处理器进行并行处理。</p>
<p>并行计算是只能在一台服务器上运行的，分配到多个处理器上去并行处理的。不能够将其分配到两个或者多个服务器上的cpu去处理的。</p>
<p>分布式计算，也是将一个大任务拆分成多个小任务，然后是将其放到多个不同的主机的cpu上去进行处理了。相对于并行计算而言，就是可以跨主机了，多个主机上的多个cpu来进行并行处理了。多个服务器处理各个任务之后，将结果交给一个中心系统，由中心系统去将结果整合。大数据计算就是这类。</p>
<p>网格计算，就是将多种计算设备，整合成一个非常强大的计算能力的服务器了，然后直接将一个非常复杂的任务交由这个非常强大的计算能力的服务器去处理了。网格计算的典型例子，就是超级计算机。例如，可以计算行星的运行轨迹，原子弹爆炸的效果。都是去处理非常复杂的任务的。</p>
<p>云计算，用户将任务提交到云端，那么不管这个云端用的是并行计算，还是分布式计算，还是网格计算，都行，只要在云端将任务处理完毕，然后将结果返回给我就行了。也就是云计算，不管这个任务是在哪处理的，如何处理的，我只是关注处理之后得到的结果的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172504990.png" class="" title="image-20221101172504990">

<p>现在大部分的企业都处于在云计算2.0时代。</p>
<p>云计算1.0，主要就是虚拟化技术。</p>
<p>最开始各个硬件厂商，都是关注提高单台设备的处理性能，例如，提升cpu的处理性能。那么企业买到服务器之后，可能仅仅用到了cpu的5%的性能，剩下的都浪费了。因此，虚拟化技术出现，将一台物理设备，分割成多个虚拟机，然后在每个虚拟机上就可以分别去处理不同的任务，这样任务之间不会产生冲突。</p>
<p>Xen，kvm，开源的。</p>
<p>Hyper-v，esxi，闭源的。</p>
<p>云计算2.0，就是将各种底层的基础设置资源，如何进行整合，然后进行调度使用。也就是统一进行管理。这就是云管理平台了。</p>
<p>Openstack是开源的。华为基于其进行了二次研发，叫做fusionsul openstack。</p>
<p>现在大部分企业都处于云计算2.0时代。</p>
<p>云计算2.0，主要就是进行资源的整合。</p>
<p>云计算3.0，主要是面向应用开发人员使用的。更关注应用层面的东西，如何让应用开发的周期更短，最短的时间内完成应用的开发，以及应用的管理，发布，部署，上线，测试。</p>
<p>应用云化，应用上到云端。</p>
<p>Docker容器技术，早期的lxc，rocket也都是容器技术。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172540481.png" class="" title="image-20221101172540481">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172552142.png" class="" title="image-20221101172552142">

<p>还有一种叫做行业云，它是一种比较特殊的私有云，也就是针对某一个行业的私有云。</p>
<p>云服务提供商。</p>
<p>云服务使用者。</p>
<p>如果云服务器提供商和云服务使用者，是同一个人，那么就是私有云。自己建，自己用。</p>
<p>如果云服务器提供商和云服务使用者，不是同一个人，那么就是公有云。例如，华为云，提供的东西，都是面向大众，只要花钱购买，就可以进行使用的。这种就是公有云。</p>
<p>混合云，例如，一个公司，既有自建的私有云，又有一部分是从公有云租用的服务器。这混合云。</p>
<p>行业云，例如，浙江省，所有医疗行业，建立的一个私有云，所有医疗行业来使用，而公安或者政府的就用不了这里的云提供的资源。这就是行业云，也是私有云。</p>
<p>因此，针对某一个行业来部署的云，有地域限制的，例如，浙江省的医疗行业，或者杭州市的医疗行业构建的私有云，那么其它的省市，就用不了。当然也可以全国的医疗行业构建行业云。</p>
<p>如果使用的是私有云+行业云，那么它也是混合云的。</p>
<p>公有云，私有云，行业云，任意两个混合使用，那么就是混合云。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172622437.png" class="" title="image-20221101172622437">



<p>行业云的好处，例如，一个人一家医院看病，然后可能需要转院，那么到达另外一家医院的时候，那么就可以通过行业云调取到我这这家医院看病的病例情况，开的药之类的。</p>
<p>又或者医院内部，拍片可能需要计算之类的，那么就可以到行业云中申请服务器来使用。</p>
<p>对外公众提供服务的，只有公有云。</p>
<p>私有云，行业云，都是对内提供服务的。</p>
<p>现在发展趋势，就是向混合云来发展的。例如，企业，将自己的核心数据，业务，放置在自己的私有云上的。将非核心的内容，例如，测试，展销类的东西，那么就可以部署到公有云上去。</p>
<p>然后将两者整合一起管理，那么就是混合云了。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172647065.png" class="" title="image-20221101172647065">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172705938.png" class="" title="image-20221101172705938">

<p>这4个就是基础设施资源。那么就是iaas。</p>
<p>Paas，例如，做java开发，等，都需要部署开发平台的，也就是运行java程序的jvm环境，以及tomcat容器的，或者写c的话，需要安装vs这个IDE，java的话，需要ecplise这样的IDE，还有代码运行可能需要各种库。</p>
<p>那么如果平台将这些都给你提供了，也就是直接给你提供好了一个开发环境了，你开箱即用，直接就可以写代码了，那么这就是paas环境。也就是直接开通一个账号，然后登录上去，直接各种开发工具，环境都有了，无需自己再去部署各种开发工具以及环境了，这就是paas环境。</p>
<p>Saas，就是软件级服务，就是直接将你使用的各种软件都准备好，例如，办公软件之类的应用程序，都给你安装好了，提供好了，那么账号登录进去之后，直接就可以写文字了，这就是saas服务。</p>
<p>因此，saas就是在云端放了这样一个应用程序了，可以在线写文档，Excel之类的，还可以多人同时在线协同编辑一个文档，这就是saas服务。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172749239.png" class="" title="image-20221101172749239">

<p>计算的是资源单位的使用量或者使用时间，例如，8c&#x2F;12g，使用一年多少钱。</p>
<p>收费使用的是第三方系统的，并不是在云计算系统中的了。</p>
<p>行业云也有叫做社区云。</p>
<h3 id="计算虚拟化简介"><a href="#计算虚拟化简介" class="headerlink" title="计算虚拟化简介"></a>计算虚拟化简介</h3><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172859467.png" class="" title="image-20221101172859467">

<p>云计算不等于虚拟化。实际上没有虚拟化，云计算也可以进行，只是没那么方便了而已。</p>
<p>华为的fc或者openstack底层虚拟化，都是使用的kvm技术。</p>
<p>这里面说的就是服务器虚拟化解决方案。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101172950138.png" class="" title="image-20221101172950138">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101173432047.png" class="" title="image-20221101173432047">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101173441790.png" class="" title="image-20221101173441790">

<p>公有云老大aws</p>
<p>私有云老大vmware</p>
<p>国内私有云老大华为私有云。华为的公有云业务出现的比较晚。</p>
<p>国内公有云老大阿里巴巴。09年就开始做公有云了。</p>
<p>Xen最早是剑桥大学搞出来的。后来被思杰Citrix收购了。</p>
<p>Kvm是犹太人一家公司开发出来的。</p>
<p>红帽6.0之前使用的是xen的虚拟化。但是xen后来被Citrix收购了。因此，红帽后来收购了kvm了，因此，6.0之后，虚拟化使用kvm了。</p>
<p>Docker是容器平台。而rocket也是容器的一种，但是它针对的是应用中的那些库组件的容器，不能算是一种容器平台。</p>
<hr>
<h2 id="01-下午"><a href="#01-下午" class="headerlink" title="01-下午"></a>01-下午</h2><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101173851762.png" class="" title="image-20221101173851762">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101173906811.png" class="" title="image-20221101173906811">

<p>左边是传统模式。</p>
<p>右边是虚拟化模式。</p>
<p>VMM，例如，kvm，xen这些都是VMM。</p>
<p>注意，hypervisor和vmm是一个意思。</p>
<p>hypervisor叫做虚拟化软件层，原因就是将底层硬件部分的cpu，内存，存储，网络等进行了资源池化，分别形成计算资源池，网络资源池，存储资源池，然后对于上层的vm就通过hypervisor来到底层资源池中来拿资源。</p>
<p>因此，虚拟化软件层，就是将底层的物理资源逻辑化形成各种资源池，供上层的vm来使用。</p>
<p>vmm叫做虚拟机监控器，原因是，它是用来监控上面跑的这些vm的资源使用信息的。</p>
<p>因此，对于中间这个层面有两个名称叫做虚拟化软件层（对下）和虚拟机监控器（对上）。而两者是同一个层面提供的功能，例如，kvm或者xen。</p>
<p>目前来看，hypervisor&#x2F;vmm，例如，kvm或者xen。是基于Linux操作系统的，不能跑在Windows上的。</p>
<p>另外，要注意，一台物理机上，只能运行一种或者一个hypervisor的。例如，一台物理机上已经跑了xen了，那么就不能再跑kvm了。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101175058120.png" class="" title="image-20221101175058120">

<p>I型虚拟化，就是直接在硬件上面跑hypervisor&#x2F;vmm，然后再通过hypervisor去部署相应的vm。例如，xen，esxi，都是I型虚拟化。就是将hypervisor&#x2F;vmm整合到精简的Linux中去了，因此，直接跑在硬件上的hypervisor&#x2F;vmm，实际上也是Linux，然后Linux中跑的hypervisor&#x2F;vmm的。</p>
<p>II型虚拟化，例如，VMware workstation，kvm。</p>
<p>III型虚拟化，也就是容器，叫做操作系统级虚拟化。容器是共享同一个操作系统资源的。属于轻量级虚拟化。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101175828446.png" class="" title="image-20221101175828446">

<p>分区，就是将一台物理机的资源逻辑上分成独立的区域，然后，每个区域运行一个vm。例如，cpu，内存，磁盘，都逻辑上分成多份，然后运行的vm可以独占一部分的cpu，内存，磁盘。各个vm彼此隔离。</p>
<p>隔离，就是各个vm彼此独立，互不干扰，例如，一个vm中毒（蠕虫），不会影响到其他的vm。另外就是资源使用隔离，例如，给一个vm分配了指定的资源，那么它就能使用这些资源，不能够占用其他vm的资源。</p>
<p>封装，意思就是说vm在宿主机来看就是一个单独的文件夹。例如，vm的配置信息放在宿主机的一个文件夹中，然后vm使用的磁盘放在另外的宿主机的一个文件夹中。因此，vm实际上在宿主机来看，是封装在一个文件中的。</p>
<p>独立，意思是说相对于硬件独立，例如，传统的应用部署方式，是应用直接部署在宿主机物理操作系统上的，那么该应用和os的版本有对应绑定关系，那么该应用如果迁移到另外一个宿主机上，那么该宿主机需要os系统版本和之前的一样才行。而如果应用部署在vm中，那么vm从一个宿主机上迁移到另外一个宿主机上，那么对于宿主机的os就没有要求了，因为它和应用没有关系，同时和宿主机的硬件也没有关系，不管是Dell的还是hp的机器，都没有关系，只要运行的虚拟化环境是一致即可，例如都是kvm。应用只和vm中的os版本有对应绑定关系。这也叫做软硬件解耦。</p>
<p>vm迁移，例如，两台机器，os版本可能不一致，但是只要都部署了kvm虚拟化环境，那么就可以将一台物理机上vm的配置信息文件夹以及磁盘文件夹等，拷贝到另外一个机器上去即可。</p>
<h4 id="cpu虚拟化"><a href="#cpu虚拟化" class="headerlink" title="cpu虚拟化"></a>cpu虚拟化</h4><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101181746466.png" class="" title="image-20221101181746466">

<p>ring，就是对物理硬件的调用权限。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101182018261.png" class="" title="image-20221101182018261">

<p>传统模式，hostOS跑在硬件上的，应用跑在hostOS上，hostOS是有ring0权限的，也就是具有最高权限的，能够操作底层硬件的。而应用程序在用户空间，是ring3级别的，ring3权限最低的，不能够直接操纵硬件的，需要借助os来完成的。中间的ring1，ring2就是各种驱动程序所处的级别了。那么应用想要播放是一个视频，那么不能直接去操纵硬件的，需要通过中间的驱动程序去操纵硬件的显卡的。</p>
<p>这种分层的好处就是，各个层之间不影响，例如，应用程序出问题了，可以直接kill掉，而不会影响到os。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101210720822.png" class="" title="image-20221101210720822">

<p>对于全虚拟化来说，guestOS中的应用想要操纵硬件，那么需要将指令发送到guestOS，然后guestOS将其发送给hypervisor，hypervisor处于ring0级别，再去操纵硬件的。</p>
<p>对于全虚拟化来说，vm它自己不知道自己是vm，它会认为自己就是一台真实的物理机，因此，全虚拟化下vm中的应用程序发送的操纵硬件的指令，就是发送到它的内核级，也就是guestOS，然后会发送给hypervisor，因为guestOS中的内核指令集和操纵硬件的指令集有所不同，需要hypervisor进行翻译的操作。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101211159843.png" class="" title="image-20221101211159843">

<p>对于半虚拟化来说，半虚拟化中的vm它是知道自己是一台vm的，因此，应用操纵硬件的时候，调用systemCall，而此时的系统调用中的指令集已经是可以直接操纵硬件的指令集了，因此，不需要hypervisor再去翻译了。此时的hypervisor只是负责一个指令的转发，转发去操纵硬件了。</p>
<p>因此，半虚拟化效率更高，因为hypervisor不需要再进行指令的编译转换的操作了。</p>
<p>从这也能够看出半虚拟化的guestOS应该是内核经过改装的了。而全虚拟化的guestOS的内核是不需要做任何改动的。</p>
<p>常规来说，半虚拟化性能高于全虚拟化。但是现在更多使用的是硬件辅助虚拟化了，如下。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101212746848.png" class="" title="image-20221101212746848">

<p>全虚拟化是需要hypervisor去做指令的编译转换工作。而硬件辅助虚拟化，hypervisor不需要再去做指令的编译转换工作了，而是由底层硬件cpu内部指令集直接去转换了，也就是说开启了虚拟化功能之后的硬件cpu，能够直接认识到虚拟化指令了。</p>
<p>因此，现在使用的虚拟化基本都是全虚拟化+硬件辅助虚拟化，这样来使用的。提升性能。</p>
<p>cpu虚拟化和内存虚拟化，都会用到硬件辅助虚拟化，也就是硬件层级就具备解析虚拟化指令的功能了。</p>
<p>图中的应用将指令发送到guestOS，然后guestOS将指令发送到hypervisor，然后hypervisor不做编译转换，直接发送给硬件cpu，通过硬件去解析。</p>
<p>因此，目前现实中使用的就是全虚拟化配合硬件辅助虚拟化来使用。性能和半虚拟化性能一致。同时全虚拟化还支持虚拟化的更高级的功能，因此，相比半虚拟化更广泛的使用。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101213806782.png" class="" title="image-20221101213806782">

<p>这里是没有虚拟化的情况，应该是hostOS，不是guestOS。</p>
<h4 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h4><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101213841709.png" class="" title="image-20221101213841709">

<p>物理内存，需要满足两个条件，1、连续的地址空间，2、知道内存的起始点，例如从地址0000开始读。这就是物理内存能够使用的条件。</p>
<p>如图，虚拟机层面来看，vm的内存都是满足这两个条件的，但是在物理内存上来看，分出去的内存不一定连续的。因此，中间是有vm内存到物理内存的地址映射关系。</p>
<p>因此，vm角度来看，内存都是连续的并且有起始地址的，但是映射到物理内存上来看，内存不一定连续，同时起始地址也不一定是从0000开始的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101214658313.png" class="" title="image-20221101214658313">

<p>因此，内存虚拟化，就是通过逻辑映射，将物理上地址不连续的空间，映射到虚拟机上地址连续的空间。</p>
<h4 id="io虚拟化"><a href="#io虚拟化" class="headerlink" title="io虚拟化"></a>io虚拟化</h4><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101214917125.png" class="" title="image-20221101214917125">

<p>io虚拟化分为如上3种。</p>
<p>模拟，就是io设备完全由程序去模拟了。例如，有3个vm，那么不可能有3套键盘鼠标的，因此，通过软件模拟，然后点击到了哪个vm，哪个vm内部的这个软件程序就捕捉到了这个信号，然后信号传入到vm，通过程序去模拟这个键盘鼠标的功能。完全通过软件程序去模拟硬件，性能很差。</p>
<p>半虚拟化，就是vm中有前端驱动程序，然后要操作某个硬件，就将信号发送给宿主机上的hypervisor中的后端驱动程序，然后通过后端驱动去直接调用底层硬件。通常只适用于硬盘和网卡。</p>
<p>IO透传，性能最好，直接将物理设备分配给vm了。需要硬件具备IO透传功能才行。例如，直接将网卡分配给vm，那么这个vm的流量就直接透传给物理网卡了，而不会再发送给vm中的虚拟网卡了。又例如GPU，将物理的GPU直接分配给vm，这样vm进行图形渲染功能操作就流畅了。</p>
<p>透传也叫做直通技术。例如，有cpu直通，网卡直通，硬盘直通等。</p>
<p>硬件需要具备IO透传功能，能够直接被vm去调度的。</p>
<p>模拟性能最差。</p>
<p>半虚拟化性能居中。</p>
<p>IO透传性能最好。</p>
<p>以上就是计算虚拟化的3部分，cpu虚拟化，内存虚拟化，IO虚拟化。</p>
<h3 id="云计算和虚拟化"><a href="#云计算和虚拟化" class="headerlink" title="云计算和虚拟化"></a>云计算和虚拟化</h3><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101220550735.png" class="" title="image-20221101220550735">

<p>虚拟化提升了单台计算机的资源使用率。</p>
<p>云计算，虚拟化只是云计算中的一个核心技术。云计算还涉及到分布式计算，分布式存储等。</p>
<p>注意，云计算是一种架构，而不是一种技术。</p>
<p>云计算，是整合了资源（计算，存储，网络），对所有资源进行统一管理和调度，并向外提供各种服务，例如，可以提供平台级服务，资源级服务，应用级服务，等。</p>
<p>Daas，桌面云服务。</p>
<p>SaaS</p>
<p>PaaS</p>
<p>Iaas</p>
<h3 id="主流计算虚拟化技术"><a href="#主流计算虚拟化技术" class="headerlink" title="主流计算虚拟化技术"></a>主流计算虚拟化技术</h3><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101221108692.png" class="" title="image-20221101221108692">

<p>kvm，xen，都认为是I型虚拟化。</p>
<p>VMware workstation，是II型虚拟化。</p>
<p>注意，华为的fusionsphere是基于kvm的，做了二次开发的，然后闭源的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101221500062.png" class="" title="image-20221101221500062">

<p>xen是直接跑在硬件上面的，它是将Linux内核进行了修改精简，整合了xen这个hypervisor软件了。即xen是xen公司自行开发的系统。</p>
<p>xen属于半虚拟化。</p>
<p>PV（Paravirtualization）就是驱动程序。</p>
<p>domU是普通虚拟机vm，普通vm中存在着前端驱动。</p>
<p>dom0是特权虚拟机vm。</p>
<p>domU如果对物理硬件有访问需求，那么就将指令发送到前端驱动，然后将其发送到特权虚拟机中的后端驱动，然后再将其发送到特权虚拟机dom0中的硬件驱动，通过硬件驱动去调度底层硬件，进行操作。</p>
<p>dom0特权vm，1、可以调用底层硬件，直接去操作硬件。2、可以对普通vm，即domU的生命周期管理，即普通vm的创建到删除，都是dom0来管的。</p>
<p>因此，在xen架构上，一定是dom0先启动，之后domU才能启动，因为domU的启动是需要通过dom0来控制的。</p>
<p>华为之前底层用的就是左边的xen架构，2018年之后，就使用kvm架构了。</p>
<p>kvm就是在标准Linux系统中注入一个kvm内核模块，这个kvm内核模块会替换Linux内核中本身的一些内容，然后该Linux系统就可以提供相应的hypervisor功能。</p>
<p>kvm调度底层硬件是通过全虚拟化+硬件辅助虚拟化实现的。注意，它不是半虚拟化的。对于关键资源，例如，cpu，内存，如果使用全虚拟化，性能太差，因此，都是使用硬件辅助虚拟化的。cpu硬件辅助虚拟化，Intel叫做vt-x，amd叫做amd-v。对于键盘鼠标，这些，可以使用全虚拟化去模拟，即通过程序软件qemu去模拟的，例如，模拟网卡，模拟键盘，模拟鼠标，等设备。</p>
<p>另外kvm中对于硬件的操作就是在Linux内核中的硬件驱动了。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101225306488.png" class="" title="image-20221101225306488">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101225319387.png" class="" title="image-20221101225319387">



<p>Paravirtualization (PV) is an efficient and lightweight virtualization technique introduced by the Xen Project team, later adopted by other virtualization solutions. PV does not require virtualization extensions from the host CPU and thus enables virtualization on hardware architectures that do not support Hardware-assisted virtualization. However, PV guests and control domains require kernel support and drivers that in the past required special kernel builds, but are now part of the Linux kernel as well as other operating systems.</p>
<p>半虚拟化(PV)是由 Xen 项目团队引入的一种高效且轻量级的虚拟化技术，后来被其他虚拟化解决方案所采用。PV 不需要来自主机 CPU 的虚拟化扩展，因此可以在不支持硬件辅助虚拟化的硬件架构上进行虚拟化。然而，PV 来宾和控制域需要内核支持和驱动程序，过去这些需要特殊的内核构建，但现在已经成为 Linux 内核和其他操作系统的一部分。</p>
<p>Paravirtualization implements the following functionality</p>
<p>半虚拟化实现以下功能</p>
<p>Disk and Network drivers 磁盘和网络驱动程序<br>Interrupts and timers 中断和计时器<br>Emulated Motherboard and Legacy Boot 仿真主板和遗留引导<br>Privileged Instructions and 特权指示及Page Tables 页表</p>
<p><strong>Xen虚拟化技术中PV和HVM的区别</strong></p>
<p>Xen是一个开源的type-1或者裸机管理程序，它使得一个物理主机能够同时并行运行多个相同的或者不同的操作系统实例。Xen是目前唯一的开源可得的type-1管理程序。Xen被应用于许多商业和开源的应用程序中，比如：服务器虚拟化(server virtualization)、基础设施即服务(Infrastructure as a Service)、桌面虚拟化(desktop virtualization)、安全应用程序(security applications)、嵌入式和硬件设备(embedded and hardware appliances)。毫无疑问，Xen驱动着当今大部分的云计算市场。</p>
<p><strong>Xen支持运行两种不同类型的虚拟机:半虚拟化(PV)和全虚拟化(HVM)。</strong>在一个单一的Xen系统中可以同时运行这两种不同类型的虚拟机。另外，在全虚拟化(HVM)虚拟机中也能够使用半虚拟化(PV)技术：实质上是创建一个半虚拟化(PV)和全虚拟化(HVM)的连续体。这种方式被称为PV on HVM。想要获取更多关于虚拟化的知识可以看这里</p>
<p>那么Xen虚拟化技术中的半虚拟化(PV)和全虚拟化(HVM)有什么区别呢?</p>
<p>Xen Paravirtualization (PV)</p>
<p>半虚拟化是由Xen引入的高效和轻量的虚拟化技术，随后被其他虚拟化平台采用。半虚拟化技术不需要物理机CPU含有虚拟化扩展。但是，要使虚拟机能够高效的运行在没有仿真或者虚拟仿真的硬件上，半虚拟化技术需要一个Xen-PV-enabled内核和PV驱动。可喜的是，Linux、NetBSD、FreeBSD和OpenSolaris都提供了Xen-PV-enabled内核。Linux内核从2.6.24版本起就使用了Linux pvops框架来支持Xen。这意味着半虚拟化技术可以在绝大多数的Liunx发行版上工作(除了那么内核很古老的发行版)。关于半虚拟化技术的更多信息可以看这里)</p>
<p>Xen Full Virtualization (HVM)</p>
<p>全虚拟化或者叫硬件协助的虚拟化技术使用物理机CPU的虚拟化扩展来虚拟出虚拟机。全虚拟化技术需要Intel VT或者AMD-V硬件扩展。Xen使用Qemu来仿真PC硬件，包括BIOS、IDE硬盘控制器、VGA图形适配器(显卡)、USB控制器、网络适配器(网卡)等。虚拟机硬件扩展被用来提高仿真的性能。全虚拟化虚拟机不需要任何的内核支持。这意味着，Windows操作系统可以作为Xen的全虚拟化虚拟机使用(众所周知，除了微软没有谁可以修改Windows内核)。由于使用了仿真技术，通常来说全虚拟化虚拟机运行效果要逊于半虚拟化虚拟机。</p>
<p>PV on HVM</p>
<p>为了提高性能，全虚拟化虚拟机也可以使用一些特殊的半虚拟化设备驱动(PVHVM 或者 PV-on-HVM驱动)。这些半虚拟化驱动针对全虚拟化环境进行了优化并对磁盘和网络IO仿真进行分流，从而得到一个类似于或优于半虚拟化虚拟机性能的全虚拟化虚拟机。这意味着，你可以对只支持全虚拟化技术的操作系统进行优化，比如Windows。</p>
<p>Xen半虚拟化虚拟机自动使用PV驱动-因此不需要提供这些驱动，你已经在使用这些优化过的驱动了。另外，只有Xen全虚拟化虚拟机才需要PVHVM驱动。关于PV on HVM的更多信息可以看这里</p>
<p>PV in an HVM Container (PVH) - New in Xen 4.4</p>
<p>Xen 4.4会带来一个被称作PVH的新的虚拟化模式。实质上，它是一个使用了针对启动和I&#x2F;O的半虚拟化驱动的半虚拟化模式。与全虚拟化不同的是，它使用了硬件虚拟化扩展，但是不需要进行仿真。在Xen 4.3发布后，xen-unstable会加入对此模式的补丁，Xen 4.4中将可以预览到这个功能。PVH拥有结合和权衡所以虚拟化模式优点的潜力，与此同时简化Xen的架构。</p>
<p><a href="https://www.cnblogs.com/jiayy/p/3765591.html">Xen虚拟化技术中PV和HVM的区别 - cgj - 博客园 (cnblogs.com)</a></p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101235528824.png" class="" title="image-20221101235528824">



<h3 id="kvm简介"><a href="#kvm简介" class="headerlink" title="kvm简介"></a>kvm简介</h3><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221101235608531.png" class="" title="image-20221101235608531">

<p>kvm就是在Linux内核中添加了一个kvm内核模块。这个kvm内核模块功能就是将普通的Linux操作系统内核给你替换成或者说更改成可以支持虚拟化功能，具备hypervisor能力的Linux内核系统。</p>
<p>内核模式，内核模式下对底层硬件有绝对的控制权，有操作硬件的所有指令集。</p>
<p>用户模式，要操作底层硬件，需要通过内核模式进行。</p>
<p>guest模式，即vm中。</p>
<p>kvm（kernel virtualization mode）</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102003622459.png" class="" title="image-20221102003622459">

<p>qemu，io，键盘，鼠标，这些通过它来模拟。而cpu和内存不会通过它模拟，性能差。</p>
<p>cpu和内存，通过硬件辅助虚拟化来实现。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102010421325.png" class="" title="image-20221102010421325">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102010847059.png" class="" title="image-20221102010847059">





<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102011612681.png" class="" title="image-20221102011612681">

<p>可以看到libvirt链接了hostOS，hypervisor，management tools。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102011804701.png" class="" title="image-20221102011804701">

<p>1下面的设备驱动是vm中模拟出来的虚拟设备驱动。</p>
<p>trap是陷阱，捕获的意思。</p>
<p>因此，1的虚拟设备驱动将信息发送给kvm模块，kvm模块中的IO trap code代码就能够捕获到这个信息。</p>
<p>qemu IO emulation code会从IO共享页拿到信息，qemu IO emulation code主要用来模拟各种硬件的。然后将信息发送给OS内核中的真实物理硬件驱动上来操作各种硬件，即5。</p>
<p>注意，例如，3，IO trap code将信息放到IO共享页之后，就会notification通知qemu IO emulation code，告诉它让它去IO共享页上来拿信息。消息通知模型。</p>
<p>同理qemu IO emulation code根据guestOS访问的内容，例如是鼠标，那么它就会根据OS物理设备驱动，然后去模拟出鼠标硬件，然后将信息放回到IO共享页，然后它也会通知notification kvm内核模块，告诉IO trap code过来IO共享页上来取。</p>
<p>因此，如图，qemu IO emulation code就是用来模拟各种物理硬件的。而真实去操作各种物理硬件还是需要去调用底层OS上的硬件设备驱动来完成的。</p>
<p>1，guestOS要访问硬件，因此，将信息发送给自己的虚拟设备驱动上。</p>
<p>2，虚拟设备驱动将这个访问消息发送给kvm中，kvm中的IO trap code捕获这个消息。</p>
<p>3，IO trap code将这个访问消息发送到IO共享页上。然后notification通知qemu IO emulation code到IO共享页上来取。</p>
<p>4，qemu IO emulation code已经模拟了各种硬件，然后它会到IO共享页上取到要访问哪个硬件的消息。然后根据自己模拟的硬件，将这个消息发送给底层OS的真实硬件设备驱动。</p>
<p>5，真实物理设备硬件驱动接收到这个消息，调用操作底层物理硬件。</p>
<p>然后信息依次返回。</p>
<p>上述是默认流程，性能比较差。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102084753876.png" class="" title="image-20221102084753876">

<p>这种就是优化之后的性能比较高的流程。即通过半虚拟化驱动来完成。</p>
<p>可以看到virtIO，不需要通过kvm模块中的IO trap code来传递信息了，而是通过自己的前端驱动和后端驱动进行沟通了。</p>
<p>这里virtIO前端驱动将信息发送到vring，但是此时qemu上的virtIO后端驱动还不知道，因此，需要通过kvm模块来传递通知notification，告诉virtIO后端驱动，信息已经放到Vring上了，过来到vring上取。</p>
<p>反之也是同理，virtIO后端驱动将返回的信息放到vring队列上之后，virtIO前端启动也不知道，因此，需要通过kvm模块来传递通知notification。</p>
<p>vring，队列。</p>
<p>这种模式，可以看到，此时guestOS发送的指令是通过virtIO的前端驱动和virtIO的后端驱动进行交流了，而kvm模块仅做消息通知功能，不进行传递指令信息功能。因此，性能显著提升，很强了。</p>
<p>virtIO方式可以看到步骤较之前默认方式少了2步，性能提升。</p>
<p>前面使用默认模式去模拟网卡，那么网卡只能达到百兆的性能。</p>
<p>而这里使用virtIO模式，那么网卡可以模拟出万兆的性能。</p>
<h3 id="FusionCompute简介"><a href="#FusionCompute简介" class="headerlink" title="FusionCompute简介"></a>FusionCompute简介</h3><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102085637117.png" class="" title="image-20221102085637117">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102085656974.png" class="" title="image-20221102085656974">

<p>FusionCompute是华为下的服务器虚拟化架构。</p>
<p>图中集群中的是一台台的物理服务器，然后下面接交换机，交换机下面接的就是存储了。</p>
<p>然后每个物理服务器上安装OS和kvm，让单台物理机服务器具备虚拟化功能。</p>
<p>然后所有物理服务器上的所有资源，会形成一个虚拟资源池，里面有计算资源池，存储资源池，网络资源池。</p>
<p>此时创建vm就是从虚拟资源池中来拿，例如，创建4c&#x2F;8g&#x2F;500g的vm，那么就从计算资源池中拿4c，8g，然后从存储资源池中拿500g。</p>
<p>然后这些vm如何去管理呢？通过华为专用的管理工具VRM。它可以统一管理所有物理服务器，同时也可以管理各个服务器上运行的各个vm。可以通过VRM进行创建，删除，迁移虚拟机。</p>
<p>因此，本质就是在物理服务器上安装kvm虚拟化操作系统，让它变成一个CNA（计算节点代理）。</p>
<p>VRM（virtualization resource manager），虚拟资源管理。</p>
<p>CNA（compute node agent），计算节点代理。</p>
<p>因此，部署FusionCompute，实际上就是部署CNA和VRM。一台物理服务器就是一个CNA。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102090816973.png" class="" title="image-20221102090816973">



<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102090838930.png" class="" title="image-20221102090838930">

<p>可以看到，FusionCompute的优势，通过VRM可以管理所有的物理资源和虚拟资源，统一管理。</p>
<p>例如，VRM可以管理物理服务器的开关机，通过VRM去对接服务器的BMC口，去管理物理服务器的硬件内容，远程控制物理服务器的开关机。</p>
<p>VRM还可以管理物理交换机路由器，物理的存储设备，等。</p>
<p>VRM直观感受就是一个web页面，在这个页面上有不同入口，可以管理物理资源，虚拟资源。</p>
<p>上述是第一个优势。</p>
<p>第二个优势，就是可以快速发放虚拟机，可以批量部署虚拟机，例如可以一次性部署10台虚拟机。FusionCompute最多可以一次性部署50台vm。例如，通过模板一次性部署50台vm。也可以通过虚拟机克隆，一次性克隆出50台，但是使用克隆方式，需要vm关机状态，否则只能克隆一台。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102092019085.png" class="" title="image-20221102092019085">

<p>CNA是部署在每个node物理服务器节点上的。</p>
<p>VRM是对所有node以及其它硬件资源进行统一管理的。</p>
<p>CNA做虚拟机，VRM去管理CNA。</p>
<p>实际上VRM只是下发一些操作指令，而具体去管理执行动作，仍然是CNA来做的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102092514205.png" class="" title="image-20221102092514205">

<p>hypervisor，虚拟化软件层，用来管理下面的物理资源。</p>
<p>vmm，虚拟机监控器，用来管理上面的vm的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102092741905.png" class="" title="image-20221102092741905">

<p>FusionCompute也是基于kvm的。</p>
<p>esxi也是I型的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102092848088.png" class="" title="image-20221102092848088">



<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102093107350.png" class="" title="image-20221102093107350">



<h3 id="FusionCompute搭建过程"><a href="#FusionCompute搭建过程" class="headerlink" title="FusionCompute搭建过程"></a>FusionCompute搭建过程</h3><img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102093624636.png" class="" title="image-20221102093624636">

<p>集群下可以有多个CNA。目前只有一个CNA。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102093702648.png" class="" title="image-20221102093702648">

<p>然后可以在指定的CNA上来创建vm。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102093748656.png" class="" title="image-20221102093748656">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102093856945.png" class="" title="image-20221102093856945">

<p>这里的目的就是创建两个vm，然后两个vm上去安装CNA和VRM来实验。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094005775.png" class="" title="image-20221102094005775">

<p>操作系统这里使用的是suse。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094047581.png" class="" title="image-20221102094047581">



<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094142820.png" class="" title="image-20221102094142820">

<p>这台vm作为CNA，内存大一些。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094216109.png" class="" title="image-20221102094216109">

<p>硬盘80g。由于这里是在vm中部署CNA，因此，总线类型选择IDE即可。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094316245.png" class="" title="image-20221102094316245">

<p>网卡，CNA和VRM在一个网络里即可。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094348858.png" class="" title="image-20221102094348858">

<p>还可以添加其他的设备。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094420028.png" class="" title="image-20221102094420028">

<p>由于这里是在vm中做实验，因此，使用IDE磁盘。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094453991.png" class="" title="image-20221102094453991">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094535099.png" class="" title="image-20221102094535099">



<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094626281.png" class="" title="image-20221102094626281">

<p>注意，之前只是选择要安装什么类型的OS，但是OS还没有呢。因此，需要安装。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094745960.png" class="" title="image-20221102094745960">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094810835.png" class="" title="image-20221102094810835">

<p>找到CNA的操作系统镜像。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094851921.png" class="" title="image-20221102094851921">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102094945349.png" class="" title="image-20221102094945349">

<p>此时确定。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095015871.png" class="" title="image-20221102095015871">

<p>此时挂载了光驱，不要×掉，否则光驱会卸载掉。直接最小化即可。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095059590.png" class="" title="image-20221102095059590">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095158988.png" class="" title="image-20221102095158988">

<p>这里可以强制重启，普通重启可能不好使。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095249131.png" class="" title="image-20221102095249131">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095336404.png" class="" title="image-20221102095336404">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095420943.png" class="" title="image-20221102095420943">

<p>安装配置页面。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095501258.png" class="" title="image-20221102095501258">

<p>将硬盘格式化一下。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095608073.png" class="" title="image-20221102095608073">

<p>CNA和VRM处于同一个网段即可。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095641180.png" class="" title="image-20221102095641180">

<p>第二块网卡是之前额外添加的，没用。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095811859.png" class="" title="image-20221102095811859">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095911571.png" class="" title="image-20221102095911571">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102095928997.png" class="" title="image-20221102095928997">



<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102102108957.png" class="" title="image-20221102102108957">



<p>上述是创建并安装了一台CNA。</p>
<p>下述是创建并安装一台VRM。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102100033550.png" class="" title="image-20221102100033550">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102100053195.png" class="" title="image-20221102100053195">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102100133315.png" class="" title="image-20221102100133315">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102100204139.png" class="" title="image-20221102100204139">

<p>网卡这里，CNA和VRM的端口组要保持一致。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102100236545.png" class="" title="image-20221102100236545">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102100423374.png" class="" title="image-20221102100423374">

<p>此时这里创建的仍然是一个空的没有OS的vm，因此，vm中的OS仍然需要自己去安装的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102100511695.png" class="" title="image-20221102100511695">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102100533358.png" class="" title="image-20221102100533358">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102100556339.png" class="" title="image-20221102100556339">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102102513643.png" class="" title="image-20221102102513643">

<p>配置界面操作同CNA。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102102548035.png" class="" title="image-20221102102548035">

<p>VRM安装好之后，可以浏览器输入VRM地址，即可访问到web界面。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102151556100.png" class="" title="image-20221102151556100">

<p>VRM和CNA是通的。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102151637831.png" class="" title="image-20221102151637831">

<p>然后可以挂载安装tools，目的是提升性能，注意，这个在Windows和Linux上挂载安装方式不同。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102151730648.png" class="" title="image-20221102151730648">

<p>注意，挂载tools也是挂载到光驱上的，因此，需要将之前安装时挂载的光驱卸载。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102151824089.png" class="" title="image-20221102151824089">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102151845628.png" class="" title="image-20221102151845628">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102151920840.png" class="" title="image-20221102151920840">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152030871.png" class="" title="image-20221102152030871">

<p>光驱sr0设备。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152156736.png" class="" title="image-20221102152156736">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152300561.png" class="" title="image-20221102152300561">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152350059.png" class="" title="image-20221102152350059">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152432989.png" class="" title="image-20221102152432989">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152537651.png" class="" title="image-20221102152537651">

<p>安装好之后，reboot重启系统即可。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152626018.png" class="" title="image-20221102152626018">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152657618.png" class="" title="image-20221102152657618">



<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152732072.png" class="" title="image-20221102152732072">

<p>默认的admin密码。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152840209.png" class="" title="image-20221102152840209">

<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152915763.png" class="" title="image-20221102152915763">

<p>首次登录修改口令。</p>
<img src="/2022/11/02/HuaWei/cloud/HCIA/01/HCIA-Cloud/image-20221102152959442.png" class="" title="image-20221102152959442">

<p>这就是自己搭建的fusionCompute了。</p>
<p>这就是fc的搭建过程。</p>
<hr>
<h3 id="网络参考"><a href="#网络参考" class="headerlink" title="网络参考"></a>网络参考</h3><p><strong>Virtualization Spectrum</strong><br>虚拟化光谱<br>Icon Info.png	A new article, 一篇新文章,Understanding the Virtualization Spectrum 理解虚拟化领域, summarizes this article and incorporates a great ，总结了本文，并结合了一个伟大的article 文章 by Brendan Gregg which cleans up the terminology. The article on this page has more detail, but the new one is more focused on explaining the general concepts behind the different modes. 作者 Brendan Gregg 清理了术语。本页上的文章有更多细节，但是新的文章更侧重于解释不同模式背后的一般概念</p>
<p>Contents内容<br>1	Full virtualization 完全虚拟化<br>2	Xen and paravirtualization Xen 和半虚拟化<br>3	Xen and full virtualization Xen 和完全虚拟化<br>4	From Poles to a Spectrum 从极点到光谱<br>5	Problems with paravirtualization: AMD and x86-64 半虚拟化的问题: AMD 和 x86-64<br>6	Paravirtualizing little by little: PVHVM mode 一点一点半虚拟化: PVHVM 模式<br>7	Problems with paravirtualization: Linux and the PV MMU 半虚拟化的问题: Linux 和 PV MMU<br>8	Almost fully PV: PVH mode 几乎完全 PV: PVH 模式<br>9	What about KVM? KVM 呢？<br>10	The paravirtualization spectrum 半虚拟化光谱<br>At XenSummit 2012 in San Diego, Mukesh Rathor from Oracle presented his work on a new virtualization mode, called “PVH”. Adding this mode, there are now a rather dizzying array of different terms thrown about — “HVM”, “PV”, “PVHVM”, “PVH” — what do they all mean? And why do we have so many?</p>
<p>在圣地亚哥举行的 XenSummit 2012上，甲骨文公司的 Mukesh Rathor 展示了他在一种名为“ PVH”的新型虚拟化模式上的工作。加上这个模式，现在有一大堆令人眼花缭乱的不同术语ーー“ HVM”、“ PV”、“ PVHVM”、“ PVH”ーー它们都是什么意思？为什么我们有这么多？</p>
<p>The reason we have all these terms is that virtualization is no longer binary; there is a spectrum of virtualization, and the different terms are different points along the spectrum. Part of the reason the terminology is a little unclear is the history; any language and terminology evolves over time in response to the changing situation. However, changing the terminology after-the-fact, once certain usages become common, is difficult.</p>
<p>我们之所以有这些术语，是因为虚拟化不再是二进制的; 存在一个虚拟化的范围，不同的术语在范围内是不同的点。术语有点不清楚的部分原因是历史; 任何语言和术语都随着时间的推移而演变，以应对不断变化的情况。然而，一旦某些用法变得普遍，在事后更改术语是困难的。</p>
<p>So in this article I will introduce just enough history to understand how the current situation came about, and (hopefully) introduce a consistent set of terminology which may help clear things up, while balancing this against the fact that people will still continue to use existing terminology.</p>
<p>因此，在本文中，我将介绍足够多的历史，以了解当前情况是如何发生的，并(希望)介绍一套一致的术语，这可能有助于澄清事实，同时平衡这一点，人们仍将继续使用现有的术语。</p>
<p>This article will give a general introduction to virtualization, and to paravirtualization, Xen’s unique contribution to the field, as well as the advent of hardware virtualization extensions (HVM). It will also introduce the idea of adding paravirtualized drivers for disk and network, and cover the motivation and technical descriptions of two more modes which further mix elements of full virtualization and paravirtualization.</p>
<p>这篇文章将对虚拟化和半虚拟化做一个简单的介绍，Xen 对这个领域的独特贡献，以及硬件虚拟化扩展(hVM)的出现。它还将介绍为磁盘和网络添加半虚拟化驱动程序的想法，并涵盖另外两种模式的动机和技术说明，这两种模式进一步混合了完全虚拟化和半虚拟化的元素。</p>
<p><strong>Full virtualization 完全虚拟化</strong><br>In the early days of virtualization (at least in the x86 world), the assumption was that you needed your hypervisor to provide a virtual machine that was functionally nearly identical to a real machine. This included the following aspects:</p>
<p>在虚拟化的早期阶段(至少在 x86领域) ，假设您需要虚拟机监控程序来提供与真实机器功能几乎相同的虚拟机。这包括以下方面:</p>
<p>Disk and network devices 磁盘和网络设备<br>Interrupts and timers 中断和计时器<br>Emulated platform: motherboard, device buses, BIOS 仿真平台: 主板，设备总线，BIOS<br>“Legacy” boot: i.e., starting in 16-bit mode and bootstrapping up to 64-bit mode “ Legacy”启动: 也就是说，从16位模式启动，到64位模式启动<br>Privileged instructions 特权指示<br>Pagetables (memory access) 分页表(内存访问)<br>In the early days of x86 virtualization, all of this needed to be virtualized: disk and network devices needed to be emulated, as did interrupts and timers, the motherboard and PCI buses, and so on. Guests needed to start in 16-bit mode and run a BIOS which loaded the guest kernel, which (again) ran in 16-bit mode, then bootstrapped its way up to 32-bit mode, and possibly then to 64-bit mode. All privileged instructions executed by the guest kernel needed to be emulated somehow; and the pagetables needed to be emulated in software.</p>
<p>在 X86虚拟化的早期，所有这些都需要虚拟化: 磁盘和网络设备需要仿真，中断和定时器、主板和 PCI 总线等等也需要仿真。客户机需要在16位模式下启动并运行一个 BIOS，该 BIOS 加载了客户机内核，该内核(同样)在16位模式下运行，然后启动到32位模式，然后可能进入64位模式。所有由客户内核执行的特权指令都需要以某种方式进行仿真; 分页表需要在软件中进行仿真。</p>
<p>This mode - where all of the aspects the virtual machine must be functionally identical to real hardware - is what I will call fully virtualized mode.</p>
<p>这种模式——虚拟机的所有方面在功能上必须与实际硬件完全相同——就是我所说的完全虚拟化模式。</p>
<p><strong>Xen and paravirtualization Xen 和半虚拟化</strong><br>Unfortunately, particularly for x86, virtualizing privileged instructions is very complicated. Many instructions for x86 behave differently in kernel and user mode without generating a trap, meaning that your options for running kernel code were to do full software emulation (incredibly slow) or binary translation (incredibly complicated, and still very slow).</p>
<p>不幸的是，特别是对于 x86，虚拟化特权指令是非常复杂的。X86的许多指令在内核和用户模式下表现不同，没有产生陷阱，这意味着运行内核代码的选项是完全的软件仿真(非常慢)或二进制翻译(非常复杂，仍然非常慢)。</p>
<p>The key question of the original Xen research project at Cambridge University was, “What if instead of trying to fool the guest kernel into thinking it’s running on real hardware, you just let the guest know that it was running in a virtual machine, and changed the interface you provide to make it easier to implement?” To answer that question, they started from the ground up designing a new interface designed for virtualization. Working together with researchers at both the Intel and Microsoft labs, they took both Linux and Windows XP, and ripped out anything that was slow or difficult to virtualize, replacing it with calls into the hypervisor (hypercalls) or other virtualization-friendly techniques. (The Windows XP port to Xen 1.0, as you might imagine, never left Microsoft Research; but it was benchmarked in the original paper.)</p>
<p>剑桥大学最初的 Xen 研究项目的关键问题是，“如果不是试图让客户内核认为它运行在真正的硬件上，而是让客户知道它运行在虚拟机中，并改变你提供的接口，使其更容易实现，会怎么样?”为了回答这个问题，他们从头开始为虚拟化设计一个新的界面。他们与英特尔和微软实验室的研究人员一起工作，同时使用 Linux 和 Windows XP，删除任何缓慢或难以虚拟化的东西，代之以对 hypervisor (超级调用)或其他虚拟化友好技术的调用。(你可能会想，Windows XP 到 Xen 1.0的移植从未离开过微软研究院，但它在原始论文中有过基准测试。)</p>
<p>The result was impressive — by getting rid of all the difficult legacy interfaces, they were able to make a fast, very lightweight hypervisor in under 70,000 lines of code.</p>
<p>结果令人印象深刻ーー通过摆脱所有困难的遗留接口，他们能够在不到7万行代码的情况下构建一个快速、非常轻量级的虚拟机监控程序。</p>
<p>This technique of changing the interface to make it easy to virtualize they called paravirtualization. In a paravirtualized VM, guests run with fully paravirtualized disk and network interfaces; interrupts and timers are paravirtualized; there is no emulated motherboard or device bus; guests boot directly into the kernel in the mode the kernel wishes to run in (32-bit or 64-bit), without needing to start in 16-bit mode or go through a BIOS; all privileged instructions are replaced with paravirtualized equivalents (hypercalls), and access to the page tables was paravirtualized as well.</p>
<p>这种改变界面的技术使得虚拟化变得更加容易，他们称之为半虚拟化。在半虚拟化虚拟机中，客户机使用完全半虚拟化的磁盘和网络接口运行; 中断和计时器是半虚拟化的; 没有模拟的主板或设备总线; 客户机以内核希望运行的模式(32位或64位)直接引导到内核，而不需要以16位模式启动或通过 BIOS; 所有特权指令被半虚拟化的等价物(超级调用)取代，对页表的访问也是半虚拟化的。</p>
<p><strong>Xen and full virtualization Xen 和完全虚拟化</strong><br>In early versions of Xen, paravirtualization was the only mode available. Although Windows XP had been ported to the Xen platform, it was pretty clear that such a port was never going to see the light of day outside Microsoft Research. This meant, essentially, that only open-source operating systems were going to be able to run on Xen.</p>
<p>在 Xen 的早期版本中，半虚拟化是唯一可用的模式。尽管 Windows XP 已经被移植到 Xen 平台上，但是很明显这样的移植在微软研究院之外永远不会出现。从本质上说，这意味着只有开源操作系统才能在 Xen 上运行。</p>
<p>At the same time the Xen team was coming up with paravirtualization, the engineers at Intel and AMD were working to try to make full virtualization easier. The result was something we now call HVM — which stands for “hardware virtual machine”. Rather than needing to do software emulation or binary translation, the HVM extensions do what might be called “hardware emulation”.</p>
<p>在 Xen 团队提出半虚拟化的同时，英特尔和 AMD 的工程师们正在努力使完全虚拟化变得更加容易。其结果就是我们现在称之为 HVM 的东西ーー它代表着“硬件虚拟机”。HVM 扩展不需要进行软件仿真或二进制翻译，而是进行所谓的“硬件模拟”。</p>
<p>Technically speaking, HVM refers to a set of extensions that make it much simpler to virtualize one component: the processor. To run a fully virtualized guest, many other components still need to be virtualized. To accomplish this, the Xen project integrated qemu to emulate disk, network, motherboard, and PCI devices; wrote the shadow code, to virtualize the pagetables; wrote emulated interrupt controllers in Xen; and integrated ROMBIOS to provide a virtual BIOS to the guest.</p>
<p>从技术上讲，HVM 指的是一组扩展，它们使虚拟化一个组件变得更加简单: 处理器。要运行一个完全虚拟化的客户端，许多其他组件仍然需要虚拟化。为了实现这一点，Xen 项目集成了 qemu 来模拟磁盘、网络、主板和 PCI 设备; 编写了影子代码来虚拟化页面; 在 Xen 中编写了模拟中断控制器; 集成了 ROMBIOS 来为客户端提供虚拟 BIOS。</p>
<p>Even though the HVM extensions are only one component of making a fully virtualized VM, the “fully virtualized” mode in the hypervisor was called HVM mode, distinguishing it from PV mode. This usage spread throughout the toolstack and into the user interface; to this day, users generally speak of running a VM in “PV mode” or in “HVM mode”.</p>
<p>尽管 HVM 扩展只是构建完全虚拟化 VM 的一个组件，但管理程序中的“完全虚拟化”模式被称为 HVM 模式，与 PV 模式不同。这种使用遍及整个工具堆栈和用户界面; 直到今天，用户通常还在谈论以“ PV 模式”或“ HVM 模式”运行 VM。</p>
<p>Once you have a fully-virtualized system, the first thing you notice is that the interface you provide for network and disks — that is, emulating a full PCI card with MMIO registers and so on — is really unnecessarily complicated. Because nearly all modern kernels have ways to load third-party device drivers, it’s a fairly obvious step to create disk and network drivers that can use the paravirtualized interfaces. Running in this mode can be called fully virtualized with PV drivers.</p>
<p>一旦您拥有了一个完全虚拟化的系统，您首先会注意到，您为网络和磁盘提供的接口ーー即，使用 MMIO 寄存器等仿真完整的 PCI 卡ーー实际上是不必要的复杂。因为几乎所有的现代内核都有加载第三方设备驱动程序的方法，所以创建可以使用半虚拟化接口的磁盘和网络驱动程序是一个相当明显的步骤。在这种模式下运行可以用 PV 驱动程序调用完全虚拟化。</p>
<p><strong>From Poles to a Spectrum 从极点到光谱</strong><br>I have introduced the concepts of full virtualization and paravirtualization (PV), as well as the hardware virtualization (HVM) feature used by Xen (among other things) to implement full virtualization. I have also introduced the concept of installing paravirtualized drivers on a fully virtualized system.</p>
<p>我已经介绍了完全虚拟化和半虚拟化(PV)的概念，以及 Xen 用来实现完全虚拟化的硬件虚拟化(HVM)特性。我还介绍了在完全虚拟化的系统上安装半虚拟化驱动程序的概念。</p>
<p>This small step, from full virtualization towards paravirtualization, begins to hint at the idea of a spectrum of paravirtualization. I will continue with the historical reasons for the development of PVHVM, and finally of the newest mode, PVH.</p>
<p>这一小步，从完全虚拟化到半虚拟化，开始暗示了一系列半虚拟化的想法。我将继续探讨 PVHVM 发展的历史原因，最后探讨最新的模式 PVH。</p>
<p>Problems with paravirtualization: AMD and x86-64 半虚拟化的问题: AMD 和 x86-64<br>It comes as a surprise to many people that while 32-bit paravirtualized guests in Xen are faster than 32-bit fully virtualized guests, when running in 64-bit mode, paravirtualized guests can sometimes be slower than fully virtualized guests. This is due to some changes AMD made when designing the architecture which simplified things for them, but made things more difficult for Xen.</p>
<p>在 Xen，32位的半虚拟客户比32位的全虚拟客户运行速度更快，这让很多人感到惊讶，但在64位模式下，半虚拟客户有时会比全虚拟客户运行速度更慢。这是由于 AMD 在设计体系结构时做了一些改变，这些改变简化了他们的工作，但使 Xen 的工作更加困难。</p>
<p>Most modern operating systems need just two levels of protection: user mode and kernel mode. Kernel mode memory is protected from user mode memory via the pagetable “supervisor mode” bit.</p>
<p>大多数现代操作系统只需要两个级别的保护: 用户模式和内核模式。内核模式存储器通过分页“管理模式”位保护不受用户模式存储器的影响。</p>
<p>When running a virtual machine, you need at least three levels of protection: user mode, guest kernel, and hypervisor. The hypervisor memory needs to be protected from the guest kernel, and the guest kernel memory needs to be protected from the user. The pagetable protections only provide two levels of protection, so Xen uses another processor feature, called a segmentation limit, to provide the third level of protection. Segmentation limits are a processor feature that was in common use before paging was available. But since paging has been available, segmentation limits have basically not been used; so Xen was able to commandeer them to provide the extra level of necessary protection. The pagetable protections protect both the guest kernel and Xen from userspace; the segmentation limits protect Xen from the guest kernel.</p>
<p>在运行虚拟机时，您至少需要三个级别的保护: 用户模式、客户内核和系统管理程序。系统管理程序内存需要受到来宾内核的保护，而来宾内核内存需要受到用户的保护。分页保护只提供两级保护，因此 Xen 使用另一个处理器特性，称为分段限制，来提供第三级保护。分段限制是在分页可用之前通常使用的处理器特性。但是由于分页已经可用，所以基本上没有使用分段限制; 因此 Xen 能够强制使用它们来提供额外的必要保护级别。分页表保护同时保护来宾内核和 Xen 不受用户空间的影响; 分段限制保护 Xen 不受来宾内核的影响。</p>
<p>Unfortunately, at the time that Xen team was developing clever new uses for this little-used feature, AMD was designing their 64-bit extensions to the x86 architecture. Any unused processor feature makes hardware much more complicated to design, reason about, and verify. Since basically no operating systems use segmentation limits, AMD decided to get rid of them.</p>
<p>不幸的是，当 Xen 团队正在为这个很少使用的特性开发聪明的新用途时，AMD 正在设计他们对 x86架构的64位扩展。任何未使用的处理器特性都会使硬件的设计、推理和验证变得更加复杂。由于基本上没有操作系统使用细分限制，AMD 决定去掉它们。</p>
<p>This may have greatly simplified the architecture for AMD, but it made it impossible for Xen to squeeze in 3 levels of protection into the same address space. Instead, for 64-bit PV guests, both guest kernel and guest user-space need to run in ring 3, each with their own address space. Every time a guest process needs to make a system call, it has to bounce up into Xen, which will context-switch to the guest kernel. This not only takes more time for each system call, but requires flushing one of the key CPU caches, called a TLB. Frequent flushing of the TLB causes all execution to run more slowly for some time afterwards, as the TLB is filled up again.</p>
<p>这可能极大地简化了 AMD 的体系结构，但是它使得 Xen 不可能在同一个地址空间中加入3个级别的保护。相反，对于64位 PV 客户机，客户内核和客户用户空间都需要在环3中运行，每个用户都有自己的地址空间。每次客户进程需要进行系统调用时，它都必须弹出到 Xen，Xen 将上下文切换到客户内核。这不仅需要为每个系统调用花费更多的时间，而且还需要刷新一个称为 TLB 的关键 CPU 缓存。TLB 的频繁刷新会导致所有执行在随后的一段时间内运行得更慢，因为 TLB 被再次填满。</p>
<p>In 64-bit HVM mode, the problem doesn’t occur. The HVM extensions make it easy to have three different protection levels without needing to play clever tricks with little-used processor features. So making system calls in 64-bit HVM mode is just as fast as on real hardware. For this reason, a lot of people began running 64-bit Linux in fully virtualized mode.</p>
<p>在64位 HVM 模式下，这个问题不会发生。HVM 扩展可以很容易地拥有三种不同的保护级别，而不需要使用很少使用的处理器特性。因此，在64位 HVM 模式下进行系统调用的速度与在实际硬件上一样快。出于这个原因，很多人开始在完全虚拟化模式下运行64位 Linux。</p>
<p>Paravirtualizing little by little: PVHVM mode 一点一点半虚拟化: PVHVM 模式<br>But fully virtualized mode, even with PV drivers, has a number of things that are unnecessarily inefficient. One example is the interrupt controllers: fully virtualized mode provides the guest kernel with emulated interrupt controllers (APICs and IOAPICs). Each instruction that interacts with the APIC requires a trip up into Xen and a software instruction decode; and each interrupt delivered requires several of these emulations.</p>
<p>但是，即使使用 PV 驱动程序，完全虚拟化模式也存在许多不必要的低效问题。一个例子是中断控制器: 完全虚拟化模式为客户内核提供了模拟中断控制器(APIC 和 IOAPIC)。与 APIC 交互的每条指令都需要进入 Xen 和一个软件指令解码; 并且每个中断都需要进行几次这样的模拟。</p>
<p>As it turns out, many of the the paravirtualized interfaces for interrupts, timers, and so on are actually available for guests running in HVM mode; they just need to be turned on and used. The paravirtualized interfaces use memory pages shared with Xen, and are streamlined to minimize traps into the hypervisor.</p>
<p>事实证明，许多用于中断、计时器等的半虚拟化接口实际上可用于在 HVM 模式下运行的客户机; 它们只需要打开并使用。半虚拟化接口使用与 Xen 共享的内存页面，并进行了流线型处理，以尽量减少管理程序中的陷阱。</p>
<p>So Stefano Stabellini wrote some patches for the Linux kernel that allowed Linux, when it detects that it’s running in HVM mode under Xen, to switch from using the emulated interrupt controllers and timers to the paravirtualized interrupts and timers. This mode he called PVHVM mode, because although it runs in HVM mode, it uses the PV interfaces extensively.</p>
<p>所以 Stefano Stabellini 为 Linux 内核编写了一些补丁，当 Linux 检测到它在 Xen 下以 HVM 模式运行时，它可以从使用模拟的中断控制器和定时器切换到半虚拟化的中断和定时器。这种模式他称之为 PVHVM 模式，因为尽管它在 HVM 模式下运行，但它广泛地使用了 PV 接口。</p>
<p>(“PVHVM” mode should not be confused with “PV-on-HVM” mode, which is a term sometimes used in the past for “fully virtualized with PV drivers”.)</p>
<p>(“ PVHVM”模式不应与“ PV-on-HVM”模式混淆，后者过去有时用于表示“使用 PV 驱动程序进行完全虚拟化”。)</p>
<p>With the introduction of PVHVM mode, we can start to see paravirtualization not as binary on or off, but as a spectrum. In PVHVM mode, the disk and network are paravirtualized, as are interrupts and timers. But the guest still boots with an emulated motherboard, PCI bus, and so on. It also goes through a legacy boot, starting with a BIOS and then booting into 16-bit mode. Privileged instructions are virtualized using the HVM extensions, and pagetables are fully virtualized, using either shadow pagetables, or the hardware assisted paging (HAP) available on more recent AMD and Intel processors.</p>
<p>随着 PVhVM 模式的引入，我们可以开始看到半虚拟化不再是二进制的开关，而是一个频谱。在 PVHVM 模式下，磁盘和网络是半虚拟化的，中断和计时器也是如此。但是客户端仍然使用模拟主板、 PCI 总线等进行引导。它还要经历一次遗留引导，从 BIOS 开始，然后进入16位模式。特权指令使用 HVM 扩展进行虚拟化，分页表则完全虚拟化，可以使用影子分页表，也可以使用最新的 AMD 和 Intel 处理器上提供的硬件辅助分页(HAP)。</p>
<p>Problems with paravirtualization: Linux and the PV MMU 半虚拟化的问题: Linux 和 PV MMU<br>PVHVM mode allows 64-bit guests to run at near native speed, taking advantage of both the hardware virtualization extensions and the paravirtualized interfaces of Xen. But it still leaves something to be desired. For one, it still requires the overhead of an emulated BIOS and legacy boot. Secondly, it requires the extra memory overhead of a qemu instance to emulate the motherboard and PCI devices. For this reason, memory-conscious or security-conscious users may opt to use 64-bit PV anyway, even if it is somewhat slower.</p>
<p>PVHVM 模式允许64位客户机以接近本地速度运行，同时利用了 Xen 的硬件虚拟化扩展和半虚拟化接口。但它仍然留下了一些需要改进的地方。首先，它仍然需要仿真 BIOS 和遗留引导的开销。其次，它需要 qemu 实例的额外内存开销来模拟主板和 PCI 设备。出于这个原因，有内存意识或安全意识的用户可能会选择使用64位 PV，即使它有点慢。</p>
<p>But there is one PV guest that can never be run in PVHVM mode, and that is domain 0. Because having a domain 0 with the current Linux drivers will always be necessary, it will always be necessary to have a PV mode in the Linux kernel.</p>
<p>但是有一个 PV 客户端永远不能在 PVHVM 模式下运行，那就是域0。因为使用当前 Linux 驱动程序的域0总是必要的，所以在 Linux 内核中使用 PV 模式总是必要的。</p>
<p>But what’s the problem, you ask? Weren’t all of the features necessary to run Linux as a dom0 upstreamed in Linux 3.0?</p>
<p>你会问，有什么问题吗？在 Linux 3.0中，将 Linux 作为 dom0上游运行不是所有的特性都是必需的吗？</p>
<p>Yes, they were; but they are still occasionally the source of some irritation. The core changes required to paravirtualize the page tables (also known as the “PV MMU”) are straightforward and work well once the system is up and running. However, while the kernel is booting, before the normal MMU is up and running, the story is a bit different. The changes required for the early MMU are fragile, and are often inadvertently broken when making seemingly innocent changes. This makes both the x86 maintainers and the pvops maintainers unhappy, consuming time and emotional energy that could be used for other purposes.</p>
<p>是的，他们是; 但是他们仍然偶尔是一些烦恼的来源。将页面表(也称为“ PV MMU”)半虚拟化所需的核心更改非常简单，并且在系统启动和运行后能够很好地工作。但是，当内核启动时，在正常的 MMU 启动并运行之前，情况有所不同。早期 MMU 所需的更改是脆弱的，并且在进行看似无关紧要的更改时经常在不经意间被破坏。这使得 x86维护人员和 pvops 维护人员都不高兴，消耗了可以用于其他目的的时间和情感能量。</p>
<p>Almost fully PV: PVH mode 几乎完全 PV: PVH 模式<br>A lot of the choices Xen made when designing a PV interface were made before HVM extensions were available. Nearly all hardware now has HVM extensions available, and nearly all also include hardware-assisted pagetable virtualization. What if we could run a fully PV guest — one that had no emulated motherboard, BIOS, or anything like that — but used the HVM extensions to make the PV MMU unnecessary, as well as to speed up system calls in 64-bit mode?</p>
<p>Xen 在设计 PV 接口时做出的许多选择都是在 HVM 扩展可用之前做出的。现在几乎所有的硬件都有可用的 HVM 扩展，而且几乎所有的硬件都包含了硬件辅助的分页虚拟化。如果我们可以运行一个完整的 PV 客户端(没有模拟主板、 BIOS 或者类似的东西) ，但是使用 HVM 扩展来使 PV MMU 变得不必要，并且在64位模式下加速系统调用，那会怎么样？</p>
<p>This is exactly what Mukesh’s PVH mode is. It’s a fully PV kernel mode, running with paravirtualized disk and network, paravirtualized interrupts and timers, no emulated devices of any kind (and thus no qemu), no BIOS or legacy boot — but instead of requiring PV MMU, it uses the HVM hardware extensions to virtualize the pagetables, as well as system calls and other privileged operations.</p>
<p>这就是 Mukesh 的 PVH 模式。它是一个完全 PV 内核模式，运行半虚拟化的磁盘和网络，半虚拟化的中断和定时器，没有任何类型的仿真设备(因此没有 qemu) ，没有 BIOS 或遗留启动ーー但它不需要 PV MMU，而是使用 HVM 硬件扩展来虚拟化分页表，以及系统调用和其他特权操作。</p>
<p>We fully expect PVH to have the best characteristics of all the modes — a simple, fast, secure interface, low memory overhead, while taking full advantage of the hardware. If HVM had been available at the time the Xen hypervisor was designed, PVH is probably the mode we would have chosen to use. In fact, in the new ARM Xen port, it is the primary mode that guests will operate in.</p>
<p>我们完全期望 PVH 具有所有模式中最好的特性ーー一个简单、快速、安全的接口，低内存开销，同时充分利用硬件的优势。如果在设计 Xen hypervisor 时 HVM 已经可用，那么 PVH 可能是我们选择使用的模式。事实上，在新的 ARM Xen 端口中，它是客户操作的主要模式。</p>
<p>Once PVH is well-established (perhaps five years or so after it’s introduced), we will probably consider removing non-PVH support from the Linux kernel, making maintenance of Xen support for Linux much simpler. The Xen kernel will probably support older kernels for some time after that. However, rest assured that none of this will be done without consideration of the community.</p>
<p>一旦 PVH 得到了很好的建立(可能是在它引入之后的五年左右) ，我们可能会考虑从 Linux 内核中删除非 PVH 支持，从而使得对 Linux 的 Xen 支持的维护更加简单。在此之后的一段时间内，Xen 内核可能会支持较老的内核。然而，请放心，如果没有社会的考虑，这些工作都不会完成。</p>
<p>Given the number of other things in the fully virtualized – paravirtualized spectrum, finding a descriptive name has been difficult. The developers have more or less settled on “PVH” (mainly PV, but with a little bit of HVM), but it has in the past been called other things, including “PV in an HVM container” (or just “HVM containers”), and “Hybrid mode”.</p>
<p>考虑到完全虚拟化-半虚拟化范围内的其他事物的数量，要找到一个描述性的名称是很困难的。开发人员或多或少已经确定了“ PVH”(主要是 PV，但也有一点 HVM) ，但在过去它被称为其他东西，包括“ HVM 容器中的 PV”(或仅仅是“ HVM 容器”)和“混合模式”。</p>
<p>What about KVM? KVM 呢？<br>At this point, some people may be wondering, how would KVM’s virtualization fit into this spectrum?</p>
<p>在这一点上，有些人可能想知道，KVM 的虚拟化如何适应这个范围？</p>
<p>Strictly speaking, KVM is just a set of kernel extensions designed to help processes implement virtualization. When most people speak of using KVM, they mean “qemu-kvm”, which means qemu running configured to use the KVM extensions. (There are other projects, such as the Native Linux KVM tool, which also use the KVM extensions.) When I say “KVM” here, I mean qemu-kvm.</p>
<p>严格地说，KVM 只是一组旨在帮助进程实现虚拟化的内核扩展。当大多数人谈到使用 KVM 时，他们指的是“ qemu-KVM”，即配置为使用 KVM 扩展的 qemu 运行。(还有其他项目，比如 NativeLinuxKVM 工具，也使用 KVM 扩展。)我说的“ KVM”是指 qemu-KVM。</p>
<p>KVM supports both “legacy boot”, starting in 16-bit mode with a BIOS (or EFI) to load the kernel bootloader, and booting directly into a kernel passed on the qemu command-line. It also provides an emulated motherboard, PCI bus, and so on. It can provide both emulated disk and network cards; and thus it is capable of supporting guests running in fully virtualized mode.</p>
<p>KVM 既支持“遗留引导”，以16位模式启动，使用 BIOS (或 EFI)加载内核引导加载程序，也直接引导到通过 qemu 命令行传递的内核。它还提供了一个仿真主板、 PCI 总线等。它可以提供模拟磁盘和网卡，因此它能够支持在完全虚拟化模式下运行的客户机。</p>
<p>KVM also provides virtio devices, which can be considered paravirtualized, as well as a PV clock, for operating systems that can be modified to support them. KVM’s typical method of paravirtualization is somewhat different than Xen’s. Virtio devices expose a normal device interface, with MMIO control paths and so on, and could in theory be implemented by real hardware. Xen’s PV interfaces are based on shared memory and lockless synchronization. The kinds of actions that need an MMIO context switch for virtio devices probably correspond pretty closely to actions that need hypercalls for Xen PV devices; but in Xen no instruction emulation needs to be done.</p>
<p>KVM 还为可以修改以支持它们的操作系统提供半虚拟化的 virtio 设备和 PV 时钟。KVM 的典型半虚拟化方法与 Xen 的有些不同。Virtio 设备公开了一个常规的设备接口，包括 MMIO 控制路径等，理论上可以由实际的硬件实现。Xen 的 PV 接口基于共享内存和无锁同步。对于 virtio 设备而言，需要 MMIO 上下文切换的操作可能与需要对 Xen PV 设备进行超级呼叫的操作非常相似，但在 Xen，不需要进行指令模拟。</p>
<p>KVM does not have a paravirtualized interface for timers or interrupts; instead (if I understand correctly) it uses an emulated local APIC. Handling a full interrupt cycle for an emulated local APIC typically requires several MMIO accesses, each of which requires a context switch and an instruction emulation. The Xen PV interrupt interface is based on memory shared with the hypervisor, supplemented by hypercalls when necessary; so most operations can be done without context switches, and those that do require only a single context switch (and no instruction emulation). This was one of the major reasons for introducing PVHVM mode for Xen guests.</p>
<p>KVM 没有用于计时器或中断的半虚拟化接口; 相反(如果我理解正确的话) ，它使用一个模拟的本地 APIC。处理模拟本地 APIC 的完整中断周期通常需要多个 MMIO 访问，每个访问都需要上下文切换和指令模拟。Xen PV 中断接口基于与虚拟机监控程序共享的内存，并在必要时辅以超级调用; 因此大多数操作可以在没有上下文切换的情况下完成，而那些确实只需要一个上下文切换的操作(并且不需要指令模拟)。这是为 Xen 客户机引入 PVHVM 模式的主要原因之一。</p>
<p>So KVM has paravirtualized devices and a paravirtualized clock, but not paravirtualized interrupts; placing KVM on the spectrum, it would be one step more paravirtualized than “FV with PV drivers”, but not as paravirtualized as PVHVM.</p>
<p>所以 KVM 有半虚拟化的设备和半虚拟化的时钟，但是没有半虚拟化的中断; 把 KVM 放到频谱上，它会比“带 PV 驱动的 FV”更加半虚拟化一步，但是不会像 PVHVM 那样半虚拟化。</p>
<p>The paravirtualization spectrum 半虚拟化光谱<br>So to summarize: There are a number of things that can be either virtualized or paravirtualized when creating a VM; these include:</p>
<p>因此，总结一下: 在创建 VM 时，有许多东西可以虚拟化或半虚拟化; 这些东西包括:</p>
<p>   Disk and network devices<br>   Interrupts and timers<br>   Emulated platform: motherboard, device buses, BIOS, legacy boot<br>   Privileged instructions and pagetables (memory access)<br>Each of these can be fully virtualized or paravirtualized independently. This leads to a spectrum of virtualization modes, summarized in the table below:</p>
<p>其中的每一个都可以完全虚拟化或半虚拟化。这就产生了一系列虚拟化模式，概述如下:</p>
<p>The first three of these will all be classified as “HVM mode”, and the last two as “PV mode” for historical reasons. PVH is the new mode, which we expect to be a sweet spot between full virtualization and paravirtualization: it combines the best advantages of Xen’s PV mode with full utilization of hardware support.</p>
<p>由于历史原因，前三种模式都将被归类为“ HVM 模式”，后两种模式将被归类为“ PV 模式”。PVH 是一种新模式，我们希望它能成为完全虚拟化和半虚拟化之间的一个甜蜜点，它结合了 Xen 的 PV 模式的最佳优势和对硬件支持的充分利用。</p>
<p>Hopefully this has given you an insight into what the various modes are, how they came about, and what are the advantages and disadvantages of each.</p>
<p>希望本文能够让您了解各种模式是什么，它们是如何产生的，以及每种模式的优缺点。</p>
<p><a href="https://wiki.xenproject.org/wiki/Virtualization_Spectrum">Virtualization Spectrum - Xen (xenproject.org)</a></p>
<hr>
<h3 id="FusionSphere和FusionCompute到底是什么关系"><a href="#FusionSphere和FusionCompute到底是什么关系" class="headerlink" title="FusionSphere和FusionCompute到底是什么关系"></a>FusionSphere和FusionCompute到底是什么关系</h3><p>FusionSphere是解决方案了，FusionCompute是解决方案里面的，FusionSphere里面包涵虚拟化、云计算中心场景</p>
<p>首先理解openstack：openstack不是云，也不是虚拟化，而是构建云的关键组件，而且只是系统的控制面（不包括系统的数据面组件【如hypervisor、存储和网络设备等】）。可以把openstack理解为一种分布式操作系统，只是这种系统部署在多台主机上，以服务的方式对外提供；<br>那么FusionSphere是什么呢？？这是华为基于openstack架构开发，整个系统专门为云设计和优化的云操作系统产品；<br>FusionSphere是产品的合集，其中包含但不限于：FusionSphere Openstack、FusionComputer、FusionStorage等，根据应用场景不同搭配不同的套件</p>
<p>FusionSphere的概念：<br>FusionSphere是业界领先的服务器虚拟化解决方案，FusionSphere解决方案通过在服务器上部署虚拟化软件，使一台物理服务器可以承担多台服务器的工作。通过整合现有的工作负载并利用剩余的服务器以部署新的应用程序和解决方案，实现较高的整合率。<br>FusionCompute的概念：<br>FusionCompute是云操作系统软件，主要负责硬件资源的虚拟化，以及对虚拟资源、业务资源、用户资源的集中管理。</p>
<p>FusionSphere是解决方案，只是一个概念，看不见摸不着，FusionCompute是操作系统，是一个软件，像windows操作系统镜像一样</p>
<p>FusionShpere是解决方案的名称，那么这个方案中需要用到产品组合。这些产品就包括了：FusionComputer（服务器虚拟化）、FusionStorage（存储虚拟化）、FusionNetwork（网络虚拟化）、FusionAccess（桌面虚拟化）、FusionInsight（大数据）。</p>
<p>fusionsphere我理解可以是office（类似vmware的vsphere），而fusioncompter可以理解成是Office其中的一个word（类似vmware的esxi），vrm是管理fusioncomputer的，类似vmware的vcenter</p>
<p>FusionSphere只是一个方案，不是具体的系统，也不是具体的软件，它只是一种云解决方案，你可以理解为一套云解决方案的名称，而在这个解决方案里面，包括了具体的用来实现方案的各种软件系统，比如，用来进行云平台管理的FusionManager管理软件，用来进行资源虚拟化的FusionCompute软件，还有用于分布式块存储的FusionStorage软件，还有进行容灾的UltraVR软件，云数据备份的软件eBackup等。</p>
<p>FusionSphere 云操作系统产品，集虚拟化平台和云管理等软件于一身，提供强大的虚拟化，资源池管理，云基础服务等功能。<br>fusioncompute是华为公司虚拟化软件，用于将物理资源虚拟化为云资源池，以达到更合理的分配和利用IT资源的目的。</p>
<p>FusionCompute<br>VRM+主机<br>VRM对云资源池进行管理和协调，使云资源池中的资源能够被合理的使用。<br>主机：安装了虚拟化操作系统的服务器，将主机的CPU和内存进行虚拟化;同时关联存储设备和交换机，将存储资源和网络资源进行虚拟化。</p>
<p>FusionSphere是华为公司面向多行业客户的云操作系统产品，整个系统专为云设计和优化提供强大的虚拟化功能、资源池管理、丰富的云基础服务组件和工具、开发的API接口等。极大帮助客户水平整合数据中心物理和虚拟资源，垂直优化业务平台，让企业的云计算建设和使用更加简捷。</p>
<p>它包含两种场景应用：场景一是服务器虚拟化，其虚拟化层是FusionSphere的虚拟化套件FusionCompute和云数据中心管理平台FusionManager；场景二是云数据中心和NFV，其虚拟化层是FusionSphere OpenStack和FusionSphere OpenStack OM。</p>
<p>FusionSphere OpenStack是开源社区OpenStack的一个华为商用加强产品，包含Controller节点（包含Nova、Neutron、Clider、Swift、Glance、Keystone等计算、网络、存储、鉴权的服务，还有一些非必选的或不那么通用的服务，比如裸金属、大数据等）和计算节点（可以直接是KVM，也可以是FusionCompute集群等）等。一般配合ManageOne（提供SC、OC服务界面和运维界面）来使用。FusionCompute是VRM+Hypervisor的服务器虚拟化产品，架构组网比OpenStack要简单很多。对于最终使用者，二者相同点是都能创建虚拟机等资源，区别在于OpenStack更偏向于服务化，不像服务器虚拟化那样，管理员清楚地知道哪台计算节点跑了哪些虚拟机，比较偏Operation层面。</p>
<p>注意，服务虚拟化和服务器虚拟化有区别。</p>
<hr>
]]></content>
      <categories>
        <category>HuaWei</category>
        <category>cloud</category>
        <category>HCIA</category>
      </categories>
      <tags>
        <tag>HCIA-Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟化技术与KVM</title>
    <url>/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/</url>
    <content><![CDATA[<h1 id="虚拟化与KVM"><a href="#虚拟化与KVM" class="headerlink" title="虚拟化与KVM"></a>虚拟化与KVM</h1><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><h3 id="虚拟-amp-amp-模拟"><a href="#虚拟-amp-amp-模拟" class="headerlink" title="虚拟&amp;&amp;模拟"></a>虚拟&amp;&amp;模拟</h3><p>模拟，完全软件去实现，通过模拟开发相应的系统调用的接口来实现，性能差，但通用性强。不过很少使用。典型技术，qemu。如果guest的架构与底层的架构不一致，通常叫做模拟，例如，guest中可以模拟ppc的cpu，而底层物理架构使用x86的cpu。模拟过程由于上下指令集不同，因此，中间需要一个通过模拟软件转换的过程，因此，消耗性能。</p>
<p>虚拟，辅助硬件相关技术实现，性能好。较多使用。Guest的架构与底层物理架构保持一致的，通常叫做虚拟。例如，guest中使用x86的cpu，底层物理架构使用的也是x86的cpu。辅助硬件技术，中间不需要指令集的翻译转换过程，因此，性能好。</p>
<p>虚拟化技术应满足的3个条件：</p>
<p><strong>1、等价执行。</strong>程序在真实环境中和在虚拟环境中的运行结果和运行机制应该是一模一样的</p>
<p><strong>2、性能。</strong>在性能上，虚拟机上不应该有过大的损失，虚拟机中指令集的大部分指令应该能够直接运行在物理cpu上</p>
<p><strong>3、安全隔离。</strong>在同一个hypervisor上运行的各个虚拟机应该进行隔离，任何一个虚拟机的操作不应该影响到其它的虚拟机</p>
<p>早期虚拟化技术运行在大型机，小型机上，与x86架构完全不同。后期x86架构发展，因此，目前虚拟化技术都是指x86平台架构下的。</p>
<p>早期x86平台虚拟化很困难，主要涉及到：特权集压缩，特权集别名，地址空间压缩，非特权敏感指令，静默特权失败，中断虚拟化导致性能降低。</p>
<h2 id="计算虚拟化"><a href="#计算虚拟化" class="headerlink" title="计算虚拟化"></a>计算虚拟化</h2><h3 id="CPU虚拟化"><a href="#CPU虚拟化" class="headerlink" title="CPU虚拟化"></a>CPU虚拟化</h3><h4 id="BT二进制翻译技术（完全虚拟化）"><a href="#BT二进制翻译技术（完全虚拟化）" class="headerlink" title="BT二进制翻译技术（完全虚拟化）"></a>BT二进制翻译技术（完全虚拟化）</h4><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102191120418.png" class="" title="image-20221102191120418">

<p>通过BT技术（二进制翻译技术）加速虚拟化性能。硬件——&gt;vmm（ring0上运行）——&gt;guestos内核（ring1）ring2是空闲的（注意，只是这么解释而已）可以理解guestos内核是运行在ring3上的。——&gt;app（用户空间ring3）</p>
<p>如果app运行非特权指令，那么直接调度到物理cpu上去执行。如果app发生特权指令调用，那么就要发起系统调用交给guestos内核，然后二进制翻译BT给vmm（vmm通过软件虚拟了一个软cpu给了guest的，因此，使得guest以为自己是运行在ring0上的，guestos内核不知道自己运行在虚拟化的平台上，因此，vmm是通过软件封装起来，然后给guestos内核的一个接口而已），然后vmm将指令翻译成自己能够执行的指令，然后vmm去调用底层系统调用，操作底层硬件。</p>
<p>这种属于<strong>完全虚拟化</strong>，此种方式，是cpu不支持硬件虚拟化的情况。在vmware workstation中配置cpu处，如果不选择，那么就是采用这种二进制翻译技术（BT）。Guest中的cpu是vmm虚拟出的cpu指令集，需要通过BT转换，性能相对交差。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102224355233.png" class="" title="image-20221102224355233">



<h4 id="HVM（硬件辅助虚拟化）（完全虚拟化）"><a href="#HVM（硬件辅助虚拟化）（完全虚拟化）" class="headerlink" title="HVM（硬件辅助虚拟化）（完全虚拟化）"></a>HVM（硬件辅助虚拟化）（完全虚拟化）</h4><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102224431541.png" class="" title="image-20221102224431541">

<p>正常cpu使用的是0，1，2，3四个环。0表示特权指令环，3表示用户空间指令环。涉及到特权指令调用，例如，操作硬盘，网卡等操作，用户空间程序需要发起对内核空间特权指令的系统调用。因此，此种情况虚拟化都是在用户空间进行，因此，需要BT这种技术。</p>
<p>硬件辅助虚拟化，就是在cpu设计的时候，增加了一个环，ring-1环，用来真正执行特权指令。</p>
<p>当某个guestos视图去在物理cpu上执行某个特权指令的时候，实际上在物理cpu的ring0上没有特权指令了，它只是做一些捕获类的操作，因此，它能够自动捕获要执行的特权指令，然后通知给ring-1上的vmm或者hypervisor执行特权指令。<strong>因此，guestos不用做任何的修改就能够实现完全虚拟化了。</strong>Guestos上的用户空间的非特权指令，就可以直接放在物理cpu上去执行了。Guestos执行特权指令，放在ring0，实际被ring-1捕获并执行。</p>
<p><strong>因此，这种cpu硬件支持的完全虚拟化，比最开始的那个硬件不支持的完全虚拟化（采用BT技术）性能就有很大的提升了。</strong></p>
<p>但是虽然是cpu硬件级别的捕获，但是将这个特权指令捕获下来，然后转换成ring-1上vmm能够执行的特权指令的过程仍然要进行的。因此，无论是哪种完全虚拟化，比较半虚拟化来说，性能都有损耗。</p>
<h4 id="半虚拟化"><a href="#半虚拟化" class="headerlink" title="半虚拟化"></a>半虚拟化</h4><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102224759049.png" class="" title="image-20221102224759049">

<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102224829485.png" class="" title="image-20221102224829485">

<p>Dom0上的内核是经过修改的内核。直接安装在底层硬件上。</p>
<p>Hypervisor层提供硬件级别的转换。</p>
<p><strong>当app运行非特权指令和特权指令的时候，直接通过hypervisor运行在底层硬件，发起hypervisor call的调用（注意，不是系统调用）。当需要io操作的时候，需要通过dom0上的guestos来进行底层的操作。</strong></p>
<p>半虚拟化中，guestos内核就必须明确知道自己是运行在虚拟化环境中的，而且知道自己不会去直接操作特权指令了，而是通过调用hypercall来实现操作硬件。而大多数os开发的时候，都是以直接运行在硬件平台上而研发的，不会研发让os运行在这种模式下。因此，如果os要想运行在半虚拟化环境中，那么就要允许对os内核做修改，然后使得os内核能够知道自己运行在这种半虚拟化的环境中。对于非开源的内核很难实现这种半虚拟化模型。</p>
<p><strong>半虚拟化与完全虚拟化主要区别就是，不用vmm为每个guestos软件模拟一个具有ring0特权指令的软cpu了（因为每个guestOS的内核是经过修改的，知道自己是运行在虚拟化环境中，对于特权指令和非特权指令的执行，都是直接去调用hypercall了）。因此，性能提升。</strong></p>
<p><strong>注意，半虚拟化中，对于cpu和内存是进行hypercall的调用，而对于io是通过前后端驱动来通过dom0来实现操作硬件的。</strong></p>
<h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h3><p><strong>在没有使用虚拟化的时候，内存是线性地址到物理地址的转换，通过cpu的mmu（内存控制单元）来进行的。</strong></p>
<p><strong>非虚拟化场景：</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102225603011.png" class="" title="image-20221102225603011">

<p><strong>非虚拟化时，va——&gt;pa转换。</strong></p>
<p><strong>虚拟化场景下：</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102225709258.png" class="" title="image-20221102225709258">

<p>GVA——&gt;GPA——&gt;HPA这样，地址要转换两次。</p>
<p>VMM将GPA转换一次为HPA，然后告诉物理cpu应该找HPA的某段物理内存。<strong>这个过程早期是通过VMM软件来实现的，非常复杂低效</strong>。</p>
<p>Intel，amd引入了影子mmu，shadow mmu。<strong>Intel的叫做ept技术，amd叫做npt技术。</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102225911872.png" class="" title="image-20221102225911872">

<p><strong>当一个虚拟机中的进程给了一个线性地址之后，这个进程的地址交给物理cpu的mmu一份，再交给shadow mmu一份，物理cpu的mmu转换为GVA——&gt;GPA，而交给shadow mmu的那个，直接从GVA——&gt;HPA。</strong></p>
<p><strong>mmu：将GVA转成GPA了而已。供各个虚拟机自己使用，不是真的转为物理地址。</strong></p>
<p><strong>shadow mmu：GVA——&gt;HPA。一次性转换完成。供VMM完成实际转换工作的。</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102230104596.png" class="" title="image-20221102230104596">

<p>非虚拟化情况下，页表缓存TLB中存放的是VA——&gt;PA转换的结果。</p>
<p>在虚拟化环境下，对于不同的虚拟机来说，TLB中保存的VA到PA是不同的，可能会发生混淆，也就是对于不同的guest来说VA可能是相同的，因为VA是guestos中的（假设都是512MB内存，那么guest中的地址空间都是0-512MB，因此不同虚拟机的VA重复）。<strong>因此，为了避免不同的guest的VA到PA的混淆，当虚拟机在物理cpu上进行切换的时候，就必须要清空TLB。因此，为了避免每次都清空TLB，引入了taged TLB打了标签的TLB。</strong></p>
<p><strong>shadow mmu，taged TLB，解决了内存虚拟化问题。</strong></p>
<h3 id="IO虚拟化"><a href="#IO虚拟化" class="headerlink" title="IO虚拟化"></a>IO虚拟化</h3><p>针对完全虚拟化情况，IO虚拟化采用软件模拟的方式，模拟IO系统调用的接口来实现。</p>
<p><strong>针对半虚拟化情况：</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102230338961.png" class="" title="image-20221102230338961">

<p><strong>cpu，内存：dom0，domU，由hypervisor来处理。目前一般系统都支持。</strong></p>
<p><strong>IO：dom0，直接去操作IO硬件。domU，交给dom0，由dom0去操作IO硬件。采用前后端驱动的方式。DomU系统中是前端驱动。Dom0中是后端驱动。</strong></p>
<p><strong>硬件辅助虚拟化（IO透传技术）：直接使用底层硬件IO设备给某一个虚拟机专门使用。</strong></p>
<p><strong>Vt-d技术</strong></p>
<p><strong>虚拟技术一览表：</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102230516850.png" class="" title="image-20221102230516850">

<p><strong>完全虚拟化产品：</strong></p>
<p>​       Vmware workstation，kvm，virtualbox，xen（HVM），RHEV</p>
<p><strong>半虚拟化产品：</strong></p>
<p>​       Xen，vmware ESX&#x2F;ESXi（通常VMware vSphere又称为ESX，VMware vSphere Hypervisor又称为ESXi，只是ESXi功能上比ESX少一点。）</p>
<p>注意，VMware vsphere是VMware的一套解决方案，并不是专指某一个技术。</p>
<p>注意，目前实际使用的都是完全虚拟化+硬件辅助虚拟化方式。即cpu，内存通过硬件辅助虚拟化来实现，而IO通过半虚拟化，即前后端驱动来实现，即在vm中安装前端驱动，而hypervisor&#x2F;vmm中集成有后端驱动的。</p>
<hr>
<h2 id="KVM（kernel-base-virual-machine）"><a href="#KVM（kernel-base-virual-machine）" class="headerlink" title="KVM（kernel-base virual machine）"></a>KVM（kernel-base virual machine）</h2><h3 id="Kvm基础介绍"><a href="#Kvm基础介绍" class="headerlink" title="Kvm基础介绍"></a>Kvm基础介绍</h3><p>基于linux内核的虚拟化。将kvm以linux内核模块的形式存在。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102231003594.png" class="" title="image-20221102231003594">

<p>Qemu技术（纯模拟技术）。</p>
<p>硬件——&gt;linux——&gt;安装qemu（它类似vmware workstation一样）——&gt;创建虚拟机。qemu对于cpu，内存，IO都能够模拟出来。</p>
<p>性能差。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102231042628.png" class="" title="image-20221102231042628">

<p><strong>kqemu就类似这个BT，是qemu的二进制翻译技术。对qemu提供加速功能。但性能仍然比较低效，并且kqemu存在很多bug。</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102231133916.png" class="" title="image-20221102231133916">

<p><strong>kvm寄宿在内核上，这个时候，原来的这个os（host）就不是host，而是变成了hypervisor了，而这个时候的qemu也不再是vmm了，而仅仅是一个为kvm提供管理界面并模拟IO的一个工具而已。</strong></p>
<p><strong>而对于CPU和内存，则通过嵌入了kvm的OS（hypervisor）来提供硬件辅助虚拟化实现。</strong></p>
<p>当使用虚拟化功能的时候，os称之为hypervisor。当不使用虚拟化功能时，os正常使用。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102231325644.png" class="" title="image-20221102231325644">

<p><strong>qemu只是一个管理工具和额外实现模拟IO功能的工具。</strong></p>
<p>虚机直接运行在底层的linux（kvm）之上。</p>
<p><strong>kvm提供cpu，内存的虚拟化。以及捕获虚机对IO操作的信息，然后发送给qemu进行处理。</strong></p>
<p><strong>qemu提供io的虚拟化。</strong></p>
<p><strong>qemu-kvm，提供管理工具和实际对io的虚拟化操作。</strong></p>
<p>注意：</p>
<p><strong>kvm，需要cpu支持硬件虚拟化，才能够使用。否则不能使用kvm，只能使用qemu。通过查询&#x2F;proc&#x2F;cpuinfo的flags标记中是否有vms和svm，来确定是否支持，有则支持，没有则不支持。</strong></p>
<p><strong>使用vmware workstation的时候，要确保cpu位置的两个钩勾选上了。否则就不能使用kvm，就只能使用qemu自己的模拟功能了。并且真实硬件（例如笔记本）上要将硬件辅助虚拟化功能打开才可。</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102231542137.png" class="" title="image-20221102231542137">

<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102231600359.png" class="" title="image-20221102231600359">

<p><strong>kvm_intel这个模块是intel的cpu专用的kvm模块。</strong></p>
<p><strong>Kvm_amd模块是amd的cpu专用的kvm模块。</strong></p>
<p><strong>kvm这个模块是通用的，intel，amd都可以使用的。</strong></p>
<p><strong>装载kvm_intel模块时，kvm模块会被自动装载，反之不是。</strong></p>
<p>kvm模块装载之后，在&#x2F;dev&#x2F;目录下就有kvm的设备。</p>
<p><strong>装载了kvm的linux内核来创建，删除，管理虚拟机，就是通过这个&#x2F;dev&#x2F;kvm接口来实现，但是这个是一个编程接口，不能直接使用。</strong></p>
<p>而kvm本身没有提供管理工具，因此，需要借助外部工具。</p>
<p><strong>kvm就借助qemu实现了一个专用的管理模块，叫做qemu-kvm。专用于结合kvm使用的qemu工具。专用于kvm管理的qemu工具。</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102231751341.png" class="" title="image-20221102231751341">

<p>这个是kvm架构图。</p>
<p>kvm是将每个虚拟机中的vcpu通过一个线程来虚拟的，因此，如果给guest分了两个vcpu，那么就表现为两个线程，这两个线程最终要被linux内核调度到两个物理cpu上去运行的。在用户空间中来看，每个线程对于linux内核来说都是同等意义的，那么如果只有一颗物理cpu，然后却做了两个vcpu，那么这俩个vcpu只能一前一后的调度到这个物理cpu上去运行。因此，<strong>虚拟cpu比物理cpu多的时候，没有意义的。</strong></p>
<p><strong>注意，vm在宿主机上来看，就是一个qemu-kvm的进程。</strong></p>
<p>针对kvm，使用qemu模拟IO性能差，因此，出现了virtIO（半虚拟化技术）。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102234714877.png" class="" title="image-20221102234714877">

<p><strong>virtio这种驱动从linux2.6.25内核版本开始就直接被整合到内核中了（这里说的是指前后端驱动，即整合到Linux内核中，这样添加了kvm内核模块的Linux（hypervisor）中就具有了virtIO的前后端驱动）</strong></p>
<p><strong>而windows内核不支持virtio驱动，因此，kvm中安装windows，使用io设备，需要单独安装virtio驱动。而对于kvm的虚拟机中安装Linux来说，使用io设备就不需要单独安装virtIO驱动。</strong></p>
<p><strong>kvm组成部分：kvm（借助linux内核提供cpu和内存虚拟化，硬件辅助虚拟化）+qemu（模拟IO设备，完成IO的虚拟化），这里的模拟io设备，实际上就是io的完全虚拟化方式了。</strong></p>
<p><strong>kvm组成部分：kvm（借助linux内核提供cpu和内存虚拟化，硬件辅助虚拟化）+qemu（virtio半虚拟化各种io设备）</strong></p>
<p><strong>virtio两段：后半段在hypervisor（kvm）中。前半段在vm实例中。</strong></p>
<h3 id="kvm管理工具"><a href="#kvm管理工具" class="headerlink" title="kvm管理工具"></a>kvm管理工具</h3><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221102235200448.png" class="" title="image-20221102235200448">

<p><strong>Kvm虚机启动之后，在宿主机上表现为一个qemu-kvm进程。</strong></p>
<p>Libvirt是调用接口。</p>
<p>Libvirtd是基于调用接口实现的一个后台服务。</p>
<p><strong>Qemu-kvm一个使用示例：</strong></p>
<p># qemu-kvm -name “rhel5.8” \</p>
<p>-m 512 \</p>
<p>-smp 2 -boot d \</p>
<p>-drive file&#x3D;&#x2F;VM&#x2F;images&#x2F;rhel5.8&#x2F;hda,if&#x3D;virtio,index&#x3D;0,media&#x3D;disk,format&#x3D;qcow2 \</p>
<p>-drive file&#x3D;&#x2F;isos&#x2F;rhel-5.8.iso,index&#x3D;1,media&#x3D;cdrom \</p>
<p>这个和上面这个都是属于硬件接口，默认不指定的话都是IDE接口，这里上面指定virtio和这个不是同一种接口，但是属于同一类设备。因此，index为1。</p>
<p>-net nic,model&#x3D;virtio,macaddr&#x3D;52:54:00:A5:41:1E \</p>
<p>-vga cirrus -balloon virtio</p>
<p>vga这个指定显卡芯片类型。这些类型还有网卡的那个model&#x3D;type指定的这些类型，都是假的，性能差的软件实现的接口。</p>
<p>在这个guest上装的os必须能够驱动这些接口才行，好在这些接口大多数os都能够支持，都是更加通用的接口。</p>
<p>qemu-img create -f qcow2 -o size&#x3D;100G &#x2F;images&#x2F;vm1&#x2F;ubuntu.qcow2</p>
<p>qemu-kvm -name “ubuntu” -m 768 -smp 2 -hda &#x2F;images&#x2F;vm1&#x2F;ubuntu.qcow2 -cdrom ubuntu-12.04.1-desktop-i386.iso -boot order&#x3D;dc</p>
<p><strong>libvirt系列管理工具：</strong></p>
<p>​    装系统：virt-manager, virt-install, virsh</p>
<p>virtualation主要提供qemu-kvm工具的，安装qemu-kvm，就可以不用安装这个包了。</p>
<p>virtualization platform提供libvirt的，<strong>libvirt的使用要启动libvirtd这个服务的。</strong></p>
<p>python-virtins包，就是提供virtinstall工具的。</p>
<p><strong>使用virt-install创建虚拟机并安装GuestOS</strong></p>
<p>virt-install是一个命令行工具，它能够为KVM、Xen或其它支持libvrit API的hypervisor创建虚拟机并完成GuestOS安装；此外，它能够基于串行控制台、VNC或SDL支持文本或图形安装界面。安装过程可以使用本地的安装介质如CDROM，也可以通过网络方式如NFS、HTTP或FTP服务实现。对于通过网络安装的方式，virt-install可以自动加载必要的文件以启动安装过程而无须额外提供引导工具。当然，如果virt-install背后的这个hypervisor支持使用完全虚拟化的话，virt-install也可以使用PXE方式的来安装，也能够直接使用现有的磁盘映像直接启动安装过程。</p>
<p>使用virt-install指定vnc的话，会自动打开virtviewer的。</p>
<p>virt-install命令有许多选项，这些选项大体可分为下面几大类，同时对每类中的常用选项也做出简单说明。<br><strong>◇     一般选项：指定虚拟机的名称、内存大小、VCPU个数及特性等；</strong><br>     -n NAME, –name&#x3D;NAME：虚拟机名称，需全局惟一；virt-install安装完虚拟机之后，在&#x2F;etc&#x2F;libvirt&#x2F;目录下会生成一个这个虚拟机的配置文件，名称保存在这个配置文件中，而且这个名称永远被这个虚拟机使用。除非删除，这个与qemu-kvm不同，qemu-kvm启动虚拟机之后，下次启动给虚拟机改名都可以。<br>     -r MEMORY, –ram&#x3D;MEMORY：虚拟机内存大小，单位为MB；<br>     –vcpus&#x3D;VCPUS[,maxvcpus&#x3D;MAX][,sockets&#x3D;#][,cores&#x3D;#][,threads&#x3D;#]：VCPU个数及相关配置；<br>     –cpu&#x3D;CPU：指定cpu类型的，CPU模式及特性，如coreduo等；可以使用qemu-kvm -cpu ?来获取支持的CPU模式；<br>          实际上virt-install就是对qemu-kvm再次封装更易于使用的命令。<br><strong>◇     安装方法：指定安装方法、GuestOS类型等；</strong><br>     -c CDROM, –cdrom&#x3D;CDROM：光盘安装介质；<br>     -l LOCATION, –location&#x3D;LOCATION：安装源URL，支持FTP、HTTP及NFS等，如<a href="ftp://172.16.0.1/pub%EF%BC%9B">ftp://172.16.0.1/pub；</a><br>     –pxe：基于PXE完成安装；<br>     –livecd: 把光盘当作LiveCD；<br>     –os-type&#x3D;DISTRO_TYPE：操作系统类型，如linux、unix或windows等；<br>     –os-variant&#x3D;DISTRO_VARIANT：某类型操作系统的变体，如rhel5、fedora8等；<br>     -x EXTRA, –extra-args&#x3D;EXTRA：根据–location指定的方式安装GuestOS时，用于传递给内核的额外选项，例如指定kickstart文件的位置，–extra-args “ks&#x3D;<a href="http://172.16.0.1/class.cfg&quot;%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%8A%E9%9D%A2%E7%9A%84-l%E6%8C%87%E5%AE%9A%E4%BA%86%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E6%A0%B9%E6%8D%AE%E8%BF%99%E9%87%8C%E7%9A%84kickstart%E9%85%8D%E7%BD%AE%E6%9D%A5%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%EF%BC%88%E5%9F%BA%E4%BA%8E%E6%8F%90%E4%BE%9B%E7%9A%84%E8%BF%99%E4%B8%AA%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F%EF%BC%89%E3%80%82">http://172.16.0.1/class.cfg&quot;，就是上面的-l指定了安装镜像，加载安装镜像完毕之后，会根据这里的kickstart配置来自动进行安装过程（基于提供的这个安装镜像）。</a><br>     –boot&#x3D;BOOTOPTS：指定安装过程完成后的配置选项，如指定引导设备次序、使用指定的而非安装的kernel&#x2F;initrd来引导系统启动等 ；例如：<br>     –boot  cdrom,hd,network：指定引导次序，光驱，硬盘，网络。<br>     –boot kernel&#x3D;KERNEL,initrd&#x3D;INITRD,kernel_args&#x3D;”console&#x3D;&#x2F;dev&#x2F;ttyS0”：指定启动系统的内核及initrd文件；这里就是可以使用基于外部的内核和initrd来引导启动徐虚拟机，这两个文件不在虚拟机磁盘上。在本地物理机上。kernel_args向内核传递的参数。<br><strong>◇     存储配置：指定存储类型、位置及属性等；</strong><br>     –disk&#x3D;DISKOPTS：指定存储设备及其属性；格式为–disk &#x2F;some&#x2F;storage&#x2F;path,opt1&#x3D;val1，opt2&#x3D;val2等，注意，文件如果下面给的这些选项详细，那么这个文件会自动创建的；常用的选项有：<br>     device：设备类型，如cdrom、disk或floppy等，默认为disk；<br>     bus：磁盘总线类型，其值可以为ide、scsi、usb、virtio或xen；相当于qemu-kvm的if。<br>     perms：访问权限，如rw、ro或sh（共享的可读写），默认为rw；<br>     size：新建磁盘映像的大小，单位为GB；<br>     cache：缓存模型，其值有none、writethrouth（缓存读）及writeback（缓存读写）；<br>     format：磁盘映像格式，如raw、qcow2、vmdk等；<br>     sparse：磁盘映像使用稀疏格式，即不立即分配指定大小的空间；随用随分配。<br>     –nodisks：不使用本地磁盘，在LiveCD模式中常用；<br><strong>◇     网络配置：指定网络接口的网络类型及接口属性如MAC地址、驱动模式等；</strong><br>     -w NETWORK,或者 –network&#x3D;NETWORK,opt1&#x3D;val1,opt2&#x3D;val2：将虚拟机连入宿主机的网络中，其中NETWORK可以为：<br>     bridge&#x3D;BRIDGE：连接至名为“BRIDEG”的桥设备；<br>     network&#x3D;NAME：连接至名为“NAME”的网络；<br><strong>其它常用的选项还有：</strong><br>     model：GuestOS中看到的网络设备型号，如e1000、rtl8139或virtio等；<br>     mac：固定的MAC地址；省略此选项时将使用随机地址，但无论何种方式，对于KVM来说，其前三段必须为52:54:00；<br>     –nonetworks：虚拟机不使用网络功能；<br><strong>◇     图形配置：定义虚拟机显示功能相关的配置，如VNC相关配置；</strong><br>     –graphics TYPE,opt1&#x3D;val1,opt2&#x3D;val2：指定图形显示相关的配置，此选项不会配置任何显示硬件（如显卡），而是仅指定虚拟机启动后对其进行访问的接口；<br>     TYPE：指定显示类型，可以为vnc、sdl、spice或none等，默认为vnc；当type为vnc或者spice的时候后面指定参数opt1，opt2这些。<br>     port：TYPE为vnc或spice时其监听的端口；<br>     listen：TYPE为vnc或spice时所监听的IP地址，默认为127.0.0.1，可以通过修改&#x2F;etc&#x2F;libvirt&#x2F;qemu.conf定义新的默认值；<br>     password：TYPE为vnc或spice时，为远程访问监听的服务进指定认证密码；<br>     –noautoconsole：禁止自动连接至虚拟机的控制台；<br><strong>◇     设备选项：指定文本控制台、声音设备、串行接口、并行接口、显示接口等；</strong><br>     –serial&#x3D;CHAROPTS：附加一个串行设备至当前虚拟机，根据设备类型的不同，可以使用不同的选项，格式为“–serial type,opt1&#x3D;val1,opt2&#x3D;val2,…”，例如：<br>     –serial pty：创建伪终端；<br>     –serial dev,path&#x3D;HOSTPATH：附加主机设备至此虚拟机；<br>     –video&#x3D;VIDEO：指定显卡设备模型，可用取值为cirrus、vga、qxl或vmvga；</p>
<p><strong>◇     虚拟化平台：虚拟化模型（hvm或paravirt）、模拟的CPU平台类型、模拟的主机类型、hypervisor类型（如kvm、xen或qemu等）以及当前虚拟机的UUID等；</strong><br>     -v, –hvm：当物理机同时支持完全虚拟化和半虚拟化时，指定使用完全虚拟化；<br>     -p, –paravirt：指定使用半虚拟化；<br>     –virt-type：使用的hypervisor，如kvm、qemu、xen等；所有可用值可以使用’virsh capabilities’命令获取；<br><strong>◇     其它：</strong><br>     –autostart：指定虚拟机是否在物理启动后自动启动；<br>     –print-xml：如果虚拟机不需要安装过程(–import、–boot)，则显示生成的XML而不是创建此虚拟机；默认情况下，此选项仍会创建磁盘映像；<br>     –force：禁止命令进入交互式模式，如果有需要回答yes或no选项，则自动回答为yes；<br>     –dry-run：执行创建虚拟机的整个过程，但不真正创建虚拟机、改变主机上的设备配置信息及将其创建的需求通知给libvirt；<br>     -d, –debug：显示debug信息；</p>
<p>尽管virt-install命令有着类似上述的众多选项，但实际使用中，其必须提供的选项仅包括–name、–ram、–disk（也可是–nodisks）及安装过程相关的选项。此外，有时还需要使用括–connect&#x3D;CONNCT选项来指定连接至一个非默认的hypervisor。</p>
<p>下面这个示例创建一个名为rhel5的虚拟机，其hypervisor为KVM，内存大小为512MB，磁盘为8G的映像文件&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;rhel5.8.img，通过boot.iso光盘镜像来引导启动安装过程。</p>
<p># virt-install \</p>
<p>  –connect qemu:&#x2F;&#x2F;&#x2F;system \  qemu:&#x2F;&#x2F;&#x2F;system这个是hypervisor的url。也就是说virt-install可以远程创建虚拟机的。这里就是连接到哪个hypervisor上去创建虚拟机。想知道当前主机上的hypervisor的url怎么定义的，使用virsh命令。</p>
<p>  –virt-type kvm \</p>
<p>  –name rhel5 \</p>
<p>  –ram 512 \</p>
<p>  –disk path&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;rhel5.img,size&#x3D;8 \</p>
<p>  –graphics vnc \</p>
<p>  –cdrom &#x2F;tmp&#x2F;boot.iso \</p>
<p>  –os-variant rhel5</p>
<p>下面的示例将创建一个名为rhel6的虚拟机，其有两个虚拟CPU，安装方法为FTP，并指定了ks文件的位置，磁盘映像文件为稀疏格式，连接至物理主机上的名为brnet0的桥接网络：</p>
<p># virt-install \</p>
<p>  –connect qemu:&#x2F;&#x2F;&#x2F;system \</p>
<p>  –virt-type kvm \</p>
<p>  –name rhel6 \</p>
<p>  –ram 1024 \</p>
<p>  –vcpus 2 \</p>
<p>  –network bridge&#x3D;brnet0 \</p>
<p>  –disk path&#x3D;&#x2F;VMs&#x2F;images&#x2F;rhel6.img,size&#x3D;120,sparse \</p>
<p>  –location <a href="ftp://172.16.0.1/rhel6/dvd">ftp://172.16.0.1/rhel6/dvd</a> \</p>
<p>  –extra_args “ks&#x3D;<a href="http://172.16.0.1/rhel6.cfg%E2%80%9D">http://172.16.0.1/rhel6.cfg”</a> \</p>
<p>  –os-variant rhel6 \</p>
<p>  –force</p>
<p>下面的示例将创建一个名为rhel5.8的虚拟机，磁盘映像文件为稀疏模式的格式为qcow2且总线类型为virtio，安装过程不启动图形界面（–nographics），但会启动一个串行终端将安装过程以字符形式显示在当前文本模式下，虚拟机显卡类型为cirrus：</p>
<p> # virt-install \</p>
<p>–connect qemu:&#x2F;&#x2F;&#x2F;system \</p>
<p>–virt-type kvm \</p>
<p>–name rhel5.8 \</p>
<p>–vcpus 2,maxvcpus&#x3D;4 \</p>
<p>–ram 512 \</p>
<p>–disk path&#x3D;&#x2F;VMs&#x2F;images&#x2F;rhel5.8.img,size&#x3D;120,format&#x3D;qcow2,bus&#x3D;virtio,sparse \</p>
<p>–network bridge&#x3D;brnet0,model&#x3D;virtio</p>
<p>–nographics \ 不指定图形，那么就是通过console连接上去了，不指定这项，可能会打开virtviewer。</p>
<p>–location <a href="ftp://172.16.0.1/pub">ftp://172.16.0.1/pub</a> \</p>
<p>–extra-args “ks&#x3D;<a href="http://172.16.0.1/class.cfg">http://172.16.0.1/class.cfg</a> console&#x3D;ttyS0 serial” \</p>
<p>–os-variant rhel5 \</p>
<p>–force \ 强制回答所有问题为yes。自动化安装了。</p>
<p>–video&#x3D;cirrus  如果指定了图形界面，那么就虚拟的显卡的类型是cirrus的。默认就是cirrus的，可以不用指定。</p>
<p>下面的示例则利用已经存在的磁盘映像文件（已经有安装好的系统）创建一个名为rhel5.8的虚拟机：</p>
<p># virt-install \</p>
<p>  –name rhel5.8</p>
<p>  –ram 512</p>
<p>  –disk &#x2F;VMs&#x2F;rhel5.8.img</p>
<p>  –import 表示导入的方式。</p>
<p><strong>每个虚拟机创建后，其配置信息保存在&#x2F;etc&#x2F;libvirt&#x2F;qemu目录中，文件名与虚拟机相同，格式为XML。</strong></p>
<p>virsh uri: 查看当前主机上hypervisor的连接路径；</p>
<p>virsh connect:</p>
<p>virsh define: 创建一个虚拟机，根据事先定义的xml格式的配置文件；创建以后不会自动启动；</p>
<p>virsh create: 创建，创建完成后会自动启动；</p>
<p>virsh undefine: 删除</p>
<p>–boot kernel&#x3D;KERNEL,initrd&#x3D;INITRD,kernel_args&#x3D;”console&#x3D;&#x2F;dev&#x2F;ttyS0”</p>
<p>virt-install –connect qemu:&#x2F;&#x2F;&#x2F;system –ram 128 –name rhel6 –os-type&#x3D;linux –os-variant&#x3D;rhel5 –disk path&#x3D;&#x2F;kvm&#x2F;vm1&#x2F;rhel6.img,device&#x3D;disk,format&#x3D;raw –vcpus&#x3D;2 –vnc –noautoconsole –import</p>
<p>virt-install \</p>
<p>​       –name mykernel</p>
<p>​       –ram 512</p>
<p>​       –disk &#x2F;home&#x2F;user&#x2F;VMs&#x2F;mydisk.img</p>
<p>​       –boot kernel&#x3D;&#x2F;tmp&#x2F;mykernel,initrd&#x3D;&#x2F;tmp&#x2F;myinitrd,kernel_args&#x3D;”console&#x3D;ttyS0”</p>
<p>​       –serial pty</p>
<p># virt-install \</p>
<p>  –connect qemu:&#x2F;&#x2F;&#x2F;system \</p>
<p>  –virt-type kvm \</p>
<p>  –name rhel6 \</p>
<p>  –ram 512 \</p>
<p>  –vcpus 2 \</p>
<p>  –network bridge&#x3D;br0 \</p>
<p>  –disk path&#x3D;&#x2F;VMs&#x2F;images&#x2F;centos6.img,size&#x3D;120,sparse \</p>
<p>  –location <a href="http://172.16.0.1/cobbler/ks_mirror/centos-6.4-x86_64/">http://172.16.0.1/cobbler/ks_mirror/centos-6.4-x86_64/</a> \</p>
<p>  –extra-args “ks&#x3D;<a href="http://172.16.0.1/centos6.x86_64.cfg%E2%80%9D">http://172.16.0.1/centos6.x86_64.cfg”</a> \</p>
<p>  –os-variant rhel6 \</p>
<p>  –force</p>
<p>virsh的几个常用命令：</p>
<p>创建虚拟机：事先准备好xml格式的配置文件，可以dump其它已运行的虚拟机的；</p>
<p>create: 创建并启动；</p>
<p>defince: 仅创建</p>
<p>删除虚拟机：destroy –&gt; undefine –&gt; delete 相关的各文件;</p>
<p>动态改变CPU和memory：</p>
<p>vcpucount, vcpuinfo</p>
<p>setmem, setvcpu</p>
<p>事先定义好硬盘：qemu-img</p>
<p>attach-disk, detach-disk</p>
<p>显示虚拟相关信息：</p>
<p>cpustats: 需要事先开启cgroup中CPUACCT功能;</p>
<p>list:</p>
<p>desc</p>
<p>domdisplay：显示虚拟机的URI；</p>
<p>vncdisplay: 显示虚拟机的vnc连接地址；</p>
<p>virt-install \</p>
<p>–connect qemu:&#x2F;&#x2F;&#x2F;system \</p>
<p>–virt-type kvm \</p>
<p>–name rhel5.8 \</p>
<p>–vcpus 1,maxvcpus&#x3D;2 \</p>
<p>–ram 512 \</p>
<p>–disk “path&#x3D;&#x2F;VMs&#x2F;images&#x2F;rhel5.8.img,size&#x3D;120,format&#x3D;qcow2” –network “bridge&#x3D;br0,model&#x3D;virtio” \</p>
<p>–nographics \</p>
<p>–location <a href="http://172.16.0.1/cobbler/ks_mirror/rhel-5.8-i386/">http://172.16.0.1/cobbler/ks_mirror/rhel-5.8-i386/</a> \</p>
<p>–extra-args “ks&#x3D;<a href="http://172.16.0.1/workstation.cfg">http://172.16.0.1/workstation.cfg</a> console&#x3D;ttyS0 serial” \</p>
<p>–os-variant rhel5 \</p>
<p>–force \</p>
<p>–video&#x3D;cirrus</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103000804507.png" class="" title="image-20221103000804507">

<p>左边xen中的domU中，guestOS可以是底层硬件是硬件辅助虚拟化情况下，guestOS可以正常的Windows或者Linux系统，内核不需要改变的。而如果底层硬件没有硬件辅助虚拟化功能的情况下，那么domU就只能是采用半虚拟化方式，那么此时只能安装Linux系统，即修改过了内核的Linux，即这个vm（Linux）是知道自己跑在虚拟化环境中的，对于cpu（软件模拟）和内存（软件模拟）的使用是发起的hypercall的调用，对于io是vm中的前端驱动发送到dom0上的后端驱动，从而通过dom0来访问硬件io的。此时半虚拟化情况下，就domU中就没有办法安装Windows系统了，因为Windows系统内核是闭源的，不能够修改的。</p>
<p>而对于dom0的系统，实际上就是我们正常安装xen之后，直接就是dom0了，那么这个xen的系统是Linux内核经过修改精简之后的私有的Linux系统了。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103001631133.png" class="" title="image-20221103001631133">

<p>安装了kvm模块之后的Linux，就是hypervisor&#x2F;vmm了。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103001833148.png" class="" title="image-20221103001833148">



<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103001930679.png" class="" title="image-20221103001930679">



<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103002024852.png" class="" title="image-20221103002024852">



<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103002052340.png" class="" title="image-20221103002052340">





<h3 id="kvm网络"><a href="#kvm网络" class="headerlink" title="kvm网络"></a>kvm网络</h3><h4 id="NAT模型"><a href="#NAT模型" class="headerlink" title="NAT模型"></a>NAT模型</h4><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103002159886.png" class="" title="image-20221103002159886">

<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103002240761.png" class="" title="image-20221103002240761">

<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103002323288.png" class="" title="image-20221103002323288">



<p>[root@localhost networks]# ip a</p>
<p>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</p>
<p>  inet 127.0.0.1&#x2F;8 scope host lo</p>
<p>  inet6 ::1&#x2F;128 scope host </p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</p>
<p>  link&#x2F;ether 00:0c:29:c5:23:c3 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet6 fe80::20c:29ff:fec5:23c3&#x2F;64 scope link </p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>4: pan0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN </p>
<p>  link&#x2F;ether 0a:6b:28:2e:1a:dc brd ff:ff:ff:ff:ff:ff</p>
<p>18: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;ether 00:0c:29:c5:23:c3 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 192.168.75.4&#x2F;24 brd 192.168.75.255 scope global br0</p>
<p>  inet6 fe80::20c:29ff:fec5:23c3&#x2F;64 scope link </p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>26: virbr1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;ether 52:54:00:ef:96:1b brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 192.168.1.1&#x2F;24 brd 192.168.1.255 scope global virbr1</p>
<p>27: virbr1-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</p>
<p>  link&#x2F;ether 52:54:00:ef:96:1b brd ff:ff:ff:ff:ff:ff</p>
<p>29: virbr2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;ether 52:54:00:91:4c:4c brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 192.168.2.1&#x2F;24 brd 192.168.2.255 scope global virbr2</p>
<p>30: virbr2-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</p>
<p>  link&#x2F;ether 52:54:00:91:4c:4c brd ff:ff:ff:ff:ff:ff</p>
<p><strong>32: virbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN</strong> </p>
<p>  <strong>link&#x2F;ether 52:54:00:bd:55:8b brd ff:ff:ff:ff:ff:ff</strong></p>
<p>  <strong>inet 192.168.3.1&#x2F;24 brd 192.168.3.255 scope global virbr0</strong></p>
<p><strong>33: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</strong></p>
<p>  <strong>link&#x2F;ether 52:54:00:bd:55:8b brd ff:ff:ff:ff:ff:ff</strong></p>
<p><strong>34: vnet0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 500</strong></p>
<p>  <strong>link&#x2F;ether fe:54:00:a1:f5:4a brd ff:ff:ff:ff:ff:ff</strong></p>
<p>  <strong>inet6 fe80::fc54:ff:fea1:f54a&#x2F;64 scope link</strong> </p>
<p>​    <strong>valid_lft forever preferred_lft forever</strong></p>
<p>[root@localhost networks]#</p>
<p><strong>virbr0-nic这是一个tap设备。</strong></p>
<p><strong>Virbr0是宿主机用来跟虚机进行通信的宿主机上的网卡。作为网关</strong></p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103005852786.png" class="" title="image-20221103005852786">



<p>[root@localhost data]# ip a<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1&#x2F;8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1&#x2F;128 scope host<br>       valid_lft forever preferred_lft forever<br>2: ens20f0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master br0 state UP group default qlen 1000<br>    link&#x2F;ether 00:25:90:fd:d8:dc brd ff:ff:ff:ff:ff:ff<br>    inet6 fe80::225:90ff:fefd:d8dc&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br>3: ens20f1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000<br>    link&#x2F;ether 00:25:90:fd:d8:dd brd ff:ff:ff:ff:ff:ff<br>4: enp129s0f0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000<br>    link&#x2F;ether 00:1b:21:bb:2c:1c brd ff:ff:ff:ff:ff:ff<br>5: ens20f2: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq master br0 state UP group default qlen 1000<br>    link&#x2F;ether 00:25:90:fd:d8:de brd ff:ff:ff:ff:ff:ff<br>    inet6 fe80::225:90ff:fefd:d8de&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br>6: ens20f3: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000<br>    link&#x2F;ether 00:25:90:fd:d8:df brd ff:ff:ff:ff:ff:ff<br>7: enp129s0f1: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000<br>    link&#x2F;ether 00:1b:21:bb:2c:1e brd ff:ff:ff:ff:ff:ff<br>8: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000<br>    link&#x2F;ether 00:25:90:fd:d8:dc brd ff:ff:ff:ff:ff:ff<br>    inet 10.15.2.71&#x2F;24 brd 10.15.2.255 scope global br0<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::225:90ff:fefd:d8dc&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br><strong>9: virbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</strong><br>    <strong>link&#x2F;ether 52:54:00:27:57:ac brd ff:ff:ff:ff:ff:ff</strong><br>    <strong>inet 192.168.122.1&#x2F;24 brd 192.168.122.255 scope global virbr0</strong><br>       <strong>valid_lft forever preferred_lft forever</strong><br>10: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc pfifo_fast master virbr0 state DOWN group default qlen 1000<br>    link&#x2F;ether 52:54:00:27:57:ac brd ff:ff:ff:ff:ff:ff<br>11: vnet0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast master br0 state UNKNOWN group default qlen 1000<br>    link&#x2F;ether fe:54:00:6a:b9:e2 brd ff:ff:ff:ff:ff:ff<br>    inet6 fe80::fc54:ff:fe6a:b9e2&#x2F;64 scope link<br>       valid_lft forever preferred_lft forever<br><strong>12: vnet1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast master virbr0 state UNKNOWN group default qlen 1000</strong><br>    <strong>link&#x2F;ether fe:54:00:42:50:e3 brd ff:ff:ff:ff:ff:ff</strong><br>    <strong>inet6 fe80::fc54:ff:fe42:50e3&#x2F;64 scope link</strong><br>       <strong>valid_lft forever preferred_lft forever</strong><br>[root@localhost data]#</p>
<p><strong>[root@localhost data]# brctl show</strong><br>bridge name     bridge id               STP enabled     interfaces<br>br0             8000.002590fdd8dc       yes                  ens20f0<br>                                                                                      ens20f2<br>                                                                                      vnet0<br><strong>virbr0          8000.5254002757ac       yes                 virbr0-nic</strong><br>                                                                                       <strong>vnet1</strong><br>[root@localhost data]#</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103202446755.png" class="" title="image-20221103202446755">

<p>vm中。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103211259085.png" class="" title="image-20221103211259085">

<p><strong>virbr0桥提供dhcp功能，dns功能，同时桥上有port virbr0充当网关。宿主机iptables配置nat转换规则进行nat转换。</strong></p>
<p>注意，dhcp和dns功能通过宿主机上的dnsmasq实现的。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103213039619.png" class="" title="image-20221103213039619">



<h4 id="Route模型"><a href="#Route模型" class="headerlink" title="Route模型"></a>Route模型</h4><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103210725290.png" class="" title="image-20221103210725290">

<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103211355161.png" class="" title="image-20221103211355161">

<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103213757074.png" class="" title="image-20221103213757074">

<p>路由模型跟nat模型图一样，只是是routing模式了。打开内核的网卡间转发功能，就是路由了。各guest通过虚拟桥设备virnet1（虚拟交换机）上工作的dnsmasq动态获得地址。各个guest网关指向虚拟桥设备virnet1的地址。源地址guest1的eth0，目标地址是A地址，当A收到报文之后，发现请求者是guest1的eth0，因此，回应报文是给guest1的eth0，那么这个guest1上的eth0要能够被hypervisor路由，那么也意味着A要想到达guest1的eth0必须要经过peth0（宿主机的eth0）这个接口，否则的话，报文是送不回来的。因此，A上要有一个静态路由条目，要想到达guest1的eth0，必须经过peth0。如果中间经过其它的路由设备，那么这个路由设备也得知道才行。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103224438562.png" class="" title="image-20221103224438562">

<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103224458480.png" class="" title="image-20221103224458480">

<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225311039.png" class="" title="image-20221103225311039">

<p>宿主机</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225326629.png" class="" title="image-20221103225326629">

<p>宿主机</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225430381.png" class="" title="image-20221103225430381">

<p>宿主机</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225641945.png" class="" title="image-20221103225641945">

<p>宿主机</p>
<p>ip ro add 192.168.222.5 via 10.15.2.67</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225409548.png" class="" title="image-20221103225409548">

<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225502101.png" class="" title="image-20221103225502101">

<p>宿主机</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225551774.png" class="" title="image-20221103225551774">

<p>宿主机</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225609776.png" class="" title="image-20221103225609776">

<p>宿主机</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225727420.png" class="" title="image-20221103225727420">

<p>宿主机</p>
<p>ip ro add 192.168.122.249 via 10.15.2.71</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225840337.png" class="" title="image-20221103225840337">



<h4 id="Hostonly模型"><a href="#Hostonly模型" class="headerlink" title="Hostonly模型"></a>Hostonly模型</h4><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103225937307.png" class="" title="image-20221103225937307">

<p>隔离模型。这里的隔离模型就是vmware workstation上vmnet1，vmnet2这样的。这里就是创建一个虚拟桥，但是这个虚拟桥不是实际存在，就是在物理机上没有那个具体的虚拟桥设备virnet。但是guest1和guest2都连接到了这个虚拟桥上了（其实就是一个虚拟交换机，只是不同于之前的两种模型在物理机上有具体的虚拟桥接设备virnet）。这样，guest1和guest2彼此能够通信，但是不能够跟物理机进行通信。<strong>这个网桥也叫做透明网桥，也就是物理机上看不到这个虚拟的网桥设备的。</strong></p>
<p><strong>本质和NAT，Route模型类似，只是不具备网关了，但是可以自己配置网关。</strong></p>
<p>详情看实验贴。</p>
<p>[root@localhost networks]# ip a</p>
<p>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</p>
<p>  inet 127.0.0.1&#x2F;8 scope host lo</p>
<p>  inet6 ::1&#x2F;128 scope host </p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</p>
<p>  link&#x2F;ether 00:0c:29:c5:23:c3 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet6 fe80::20c:29ff:fec5:23c3&#x2F;64 scope link </p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>4: pan0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN </p>
<p>  link&#x2F;ether 0a:6b:28:2e:1a:dc brd ff:ff:ff:ff:ff:ff</p>
<p>5: virbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;ether 52:54:00:73:09:38 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 192.168.122.1&#x2F;24 brd 192.168.122.255 scope global virbr0</p>
<p>6: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</p>
<p>  link&#x2F;ether 52:54:00:73:09:38 brd ff:ff:ff:ff:ff:ff</p>
<p>18: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;ether 00:0c:29:c5:23:c3 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 192.168.75.4&#x2F;24 brd 192.168.75.255 scope global br0</p>
<p>  inet6 fe80::20c:29ff:fec5:23c3&#x2F;64 scope link </p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>25: vnet0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 500</p>
<p>  link&#x2F;ether fe:54:00:ba:24:05 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet6 fe80::fc54:ff:feba:2405&#x2F;64 scope link </p>
<p>​    valid_lft forever preferred_lft forever</p>
<p><strong>26: virbr1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN</strong> </p>
<p>  <strong>link&#x2F;ether 52:54:00:ef:96:1b brd ff:ff:ff:ff:ff:ff</strong></p>
<p>  <strong>inet 192.168.1.1&#x2F;24 brd 192.168.1.255 scope global virbr1</strong></p>
<p><strong>27: virbr1-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</strong></p>
<p>  <strong>link&#x2F;ether 52:54:00:ef:96:1b brd ff:ff:ff:ff:ff:ff</strong></p>
<p>[root@localhost networks]#</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103234704939.png" class="" title="image-20221103234704939">



<h4 id="桥接模型"><a href="#桥接模型" class="headerlink" title="桥接模型"></a>桥接模型</h4><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103234936832.png" class="" title="image-20221103234936832">



<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103235056452.png" class="" title="image-20221103235056452">

<p>多路桥接</p>
<p>注意，不要将一个主机上两个网卡都接到同一个交换机上，否则可能会出现环路，这个时候，注意要将stp功能打开。</p>
<p><strong>[root@localhost networks]# brctl show</strong></p>
<p>bridge name bridge id    STP enabled   interfaces</p>
<p><strong>br0          8000.000c29c523c3   yes          eth0</strong></p>
<p>pan0       8000.000000000000   no      </p>
<p>virbr0      8000.525400bd558b  yes        virbr0-nic</p>
<p>​                                                                      vnet0</p>
<p>virbr1      8000.525400ef961b   yes         virbr1-nic</p>
<p>virbr2      8000.525400914c4c   yes         virbr2-nic</p>
<p>[root@localhost networks]#</p>
<p><strong>网桥bridge创建脚本：</strong></p>
<p>[root@localhost ~]# more bridge_create.sh </p>
<p>#!&#x2F;bin&#x2F;bash</p>
<p>#</p>
<p>service NetworkManager stop &amp;&gt; &#x2F;dev&#x2F;null</p>
<p>chkconfig NetworkManager off</p>
<p>cat &gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-br0 &lt;&lt; EOF</p>
<p>DEVICE&#x3D;br0</p>
<p>ONBOOT&#x3D;yes</p>
<p>TYPE&#x3D;Bridge</p>
<p>BOOTPROTO&#x3D;none</p>
<p>IPADDR&#x3D;192.168.75.4</p>
<p>GATEWAY&#x3D;192.168.75.2</p>
<p>STP&#x3D;on</p>
<p>DELAY&#x3D;0</p>
<p>DNS1&#x3D;114.114.114.114</p>
<p>EOF</p>
<p>cat &gt; &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0 &lt;&lt; EOF</p>
<p>DEVICE&#x3D;eth0</p>
<p>ONBOOT&#x3D;yes</p>
<p>BRIDGE&#x3D;br0</p>
<p>EOF</p>
<p>service network restart &amp;&gt; &#x2F;dev&#x2F;null</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221103235326989.png" class="" title="image-20221103235326989">

<p>[root@localhost networks]# ip a</p>
<p>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</p>
<p>  inet 127.0.0.1&#x2F;8 scope host lo</p>
<p>  inet6 ::1&#x2F;128 scope host </p>
<p>​    valid_lft forever preferred_lft forever</p>
<p><strong>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</strong></p>
<p>  <strong>link&#x2F;ether 00:0c:29:c5:23:c3 brd ff:ff:ff:ff:ff:ff</strong></p>
<p>  <strong>inet6 fe80::20c:29ff:fec5:23c3&#x2F;64 scope link</strong> </p>
<p>​    <strong>valid_lft forever preferred_lft forever</strong></p>
<p>4: pan0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN </p>
<p>  link&#x2F;ether 0a:6b:28:2e:1a:dc brd ff:ff:ff:ff:ff:ff</p>
<p>5: virbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;ether 52:54:00:73:09:38 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 192.168.122.1&#x2F;24 brd 192.168.122.255 scope global virbr0</p>
<p>6: virbr0-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</p>
<p>  link&#x2F;ether 52:54:00:73:09:38 brd ff:ff:ff:ff:ff:ff</p>
<p><strong>18: br0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN</strong> </p>
<p>  <strong>link&#x2F;ether 00:0c:29:c5:23:c3 brd ff:ff:ff:ff:ff:ff</strong></p>
<p>  <strong>inet 192.168.75.4&#x2F;24 brd 192.168.75.255 scope global br0</strong></p>
<p>  <strong>inet6 fe80::20c:29ff:fec5:23c3&#x2F;64 scope link</strong> </p>
<p>​    <strong>valid_lft forever preferred_lft forever</strong></p>
<p>25: vnet0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 500</p>
<p>  link&#x2F;ether fe:54:00:ba:24:05 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet6 fe80::fc54:ff:feba:2405&#x2F;64 scope link </p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>26: virbr1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN </p>
<p>  link&#x2F;ether 52:54:00:ef:96:1b brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 192.168.1.1&#x2F;24 brd 192.168.1.255 scope global virbr1</p>
<p>27: virbr1-nic: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN qlen 500</p>
<p>  link&#x2F;ether 52:54:00:ef:96:1b brd ff:ff:ff:ff:ff:ff</p>
<p>[root@localhost networks]#</p>
<p>网桥，br0，在kvm虚机图形管理界面中创建之后，自动会在宿主机上进行创建。Eth0作为br0网桥的接口，工作在混杂模式下，作为对外部网络的一个接口。而kvm中虚机的网络和br0所在同一个网络，并且分配的ip处于同一网段。同时在网桥模式下，创建的kvm虚机，在宿主机上仍会显示对应的tap设备，即vnetXXX。</p>
<h4 id="伪桥接模型"><a href="#伪桥接模型" class="headerlink" title="伪桥接模型"></a>伪桥接模型</h4><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221104000857852.png" class="" title="image-20221104000857852">

<p>虚机之间能够通信，但是跟物理宿主机不能够进行通信。</p>
<p> 这样就是伪网桥模型，也就是仅主机模型。这样guest1，2和物理机就能够通信了。<strong>这个时候，这个虚拟网桥设备在物理机上是能够看到的，virnet。注意，上面那些图中的vnet0，vnet1这些就可以想成是现实中的网线接口一样（在OpenStack中，看到的就是tap，就是通过tap搞出的网卡）。</strong>只是这些type接口应该是在虚拟机启动的时候自动创建出来，虚拟机关闭的时候自动删掉。script脚本。注意，tap就理解为是网卡，网线，交换机。tun就理解为是路由器。</p>
<hr>
<h2 id="以下内容来自网络"><a href="#以下内容来自网络" class="headerlink" title="以下内容来自网络"></a>以下内容来自网络</h2><h3 id="虚拟化发展史"><a href="#虚拟化发展史" class="headerlink" title="虚拟化发展史"></a>虚拟化发展史</h3><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221104095756494.png" class="" title="image-20221104095756494">

<p>其中，KVM 全称是 基于内核的虚拟机（Kernel-based Virtual Machine），它是Linux 的一个内核模块，该内核模块使得 Linux 变成了一个 Hypervisor：</p>
<ul>
<li>它由 Quramnet 开发，该公司于 2008年被 Red Hat 收购。</li>
<li>它支持 x86 (32 and 64 位), s390, Powerpc 等 CPU。</li>
<li>它从 Linux 2.6.20 起就作为一模块被包含在 Linux 内核中。</li>
<li>它需要支持虚拟化扩展的 CPU。</li>
<li>它是完全开源的。<a href="http://www.linux-kvm.org/page/Main_Page">官网</a>。</li>
</ul>
<h3 id="KVM架构"><a href="#KVM架构" class="headerlink" title="KVM架构"></a>KVM架构</h3><p> KVM 是基于虚拟化扩展（Intel VT 或者 AMD-V）的 X86 硬件的开源的 Linux 原生的全虚拟化解决方案。KVM 中，虚拟机被实现为常规的 Linux 进程，由标准 Linux 调度程序进行调度；虚机的每个虚拟 CPU 被实现为一个常规的 Linux 线程。这使得 KMV 能够使用 Linux 内核的已有功能。</p>
<p> 但是，KVM 本身不执行任何硬件模拟，需要用户空间程序通过 &#x2F;dev&#x2F;kvm 接口设置一个客户机虚拟服务器的地址空间，向它提供模拟 I&#x2F;O，并将它的视频显示映射回宿主的显示屏。目前这个应用程序是 QEMU。</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221104100347398.png" class="" title="image-20221104100347398">

<ul>
<li>Guest：客户机系统，包括CPU（vCPU）、内存、驱动（Console、网卡、I&#x2F;O 设备驱动等），被 KVM 置于一种受限制的 CPU 模式下运行。</li>
<li>KVM：运行在内核空间，提供 CPU 和内存的虚级化，以及客户机的 I&#x2F;O 拦截。Guest 的 I&#x2F;O 被 KVM 拦截后，交给 QEMU 处理。</li>
<li>QEMU：修改过的被 KVM 虚机使用的 QEMU 代码，运行在用户空间，提供硬件 I&#x2F;O 虚拟化，通过 IOCTL &#x2F;dev&#x2F;kvm 设备和 KVM 交互。</li>
</ul>
<p><strong>KVM 是实现拦截虚机的 I&#x2F;O 请求的原理：</strong></p>
<p>  现代 CPU 本身实现了对特殊指令的截获和重定向的硬件支持，甚至新硬件会提供额外的资源来帮助软件实现对关键硬件资源的虚拟化从而提高性能。以 X86 平台为例，支持虚拟化技术的 CPU  带有特别优化过的指令集来控制虚拟化过程。通过这些指令集，VMM 很容易将客户机置于一种受限制的模式下运行，一旦客户机试图访问物理资源，硬件会暂停客户机运行，将控制权交回给 VMM 处理。VMM 还可以利用硬件的虚级化增强机制，将客户机在受限模式下对一些特定资源的访问，完全由硬件重定向到 VMM 指定的虚拟资源，整个过程不需要暂停客户机的运行和 VMM 的参与。由于虚拟化硬件提供全新的架构，支持操作系统直接在上面运行，无需进行二进制转换，减少了相关的性能开销，极大简化了VMM的设计，使得VMM性能更加强大。从 2005 年开始，Intel 在其处理器产品线中推广 Intel Virtualization Technology 即 IntelVT 技术。</p>
<p><strong>QEMU-KVM：</strong></p>
<p> 其实 QEMU 原本不是 KVM 的一部分，它自己就是一个纯软件实现的虚拟化系统，所以其性能低下。但是，QEMU 代码中包含整套的虚拟机实现，包括处理器虚拟化，内存虚拟化，以及 KVM需要使用到的虚拟设备模拟（网卡、显卡、存储控制器和硬盘等）。</p>
<p>为了简化代码，KVM 在 QEMU 的基础上做了修改。VM 运行期间，QEMU 会通过 KVM 模块提供的系统调用进入内核，由 KVM 负责将虚拟机置于处理的特殊模式运行。当虚机进行 I&#x2F;O 操作时，KVM 会从上次系统调用出口处返回 QEMU，由 QEMU 来负责解析和模拟这些设备。</p>
<p>从 QEMU 角度看，也可以说是 QEMU 使用了 KVM 模块的虚拟化功能，为自己的虚机提供了硬件虚拟化加速。除此以外，虚机的配置和创建、虚机运行所依赖的虚拟设备、虚机运行时的用户环境和交互，以及一些虚机的特定技术比如动态迁移，都是 QEMU 自己实现的。</p>
<p><strong>KVM：</strong></p>
<p>  KVM 内核模块在运行时按需加载进入内核空间运行。KVM 本身不执行任何设备模拟，需要 QEMU 通过 &#x2F;dev&#x2F;kvm 接口设置一个 GUEST OS 的地址空间，向它提供模拟的 I&#x2F;O 设备，并将它的视频显示映射回宿主机的显示屏。它是KVM 虚机的核心部分，其主要功能是初始化 CPU 硬件，打开虚拟化模式，然后将虚拟客户机运行在虚拟机模式下，并对虚机的运行提供一定的支持。以在 Intel 上运行为例，KVM 模块被加载的时候，它：</p>
<ol>
<li>首先初始化内部的数据结构；</li>
<li>做好准备后，KVM 模块检测当前的 CPU，然后打开 CPU 控制及存取 CR4 的虚拟化模式开关，并通过执行 VMXON 指令将宿主操作系统置于虚拟化模式的根模式；</li>
<li>最后，KVM 模块创建特殊设备文件 &#x2F;dev&#x2F;kvm 并等待来自用户空间的指令。</li>
</ol>
<p>  接下来的虚机的创建和运行将是 QEMU 和 KVM 相互配合的过程。两者的通信接口主要是一系列针对特殊设备文件 &#x2F;dev&#x2F;kvm 的 IOCTL 调用。其中最重要的是创建虚机。它可以理解成KVM 为了某个特定的虚机创建对应的内核数据结构，同时，KVM 返回一个文件句柄来代表所创建的虚机。</p>
<p>  针对该句柄的调用可以对虚机做相应地管理，比如创建用户空间虚拟地址和客户机物理地址、真实物理地址之间的映射关系，再比如创建多个 vCPU。KVM 为每一个 vCPU 生成对应的文件句柄，对其相应地 IOCTL 调用，就可以对vCPU进行管理。其中最重要的就是“执行虚拟处理器”。通过它，虚机在 KVM 的支持下，被置于虚拟化模式的非根模式下，开始执行二进制指令。在非根模式下，所有敏感的二进制指令都被CPU捕捉到，CPU 在保存现场之后自动切换到根模式，由 KVM 决定如何处理。</p>
<p>  除了 CPU 的虚拟化，内存虚拟化也由 KVM 实现。实际上，内存虚拟化往往是一个虚机实现中最复杂的部分。CPU 中的内存管理单元 MMU 是通过页表的形式将程序运行的虚拟地址转换成实际物理地址。在虚拟机模式下，MMU 的页表则必须在一次查询的时候完成两次地址转换。因为除了将客户机程序的虚拟地址转换了客户机的物理地址外，还要将客户机物理地址转化成真实物理地址。 </p>
<p>kvm提供CPU和内存的虚拟化，通过用户空间的&#x2F;dev&#x2F;kvm接口，使得qemu通过该接口去创建vm，而真正vm的创建是在内核的kvm模块中进行，创建的vm在kvm模块中过来看就是一个数据结构，vm的cpu和内存都是该数据结构中的一部分。当vm执行非特权指令时，会直接调度到物理cpu的vcpu所属的线程上直接运行，当vm执行特权指令时，调度到物理cpu的vcpu所属线程，然后被物理cpu捕获，然后会转到内核模式下的kvm中来决定该特权指令应该如何执行。</p>
<p>qemu提供了IO的虚拟化，当vm进行IO操作的时候，会被kvm捕获，然后转到用户空间的qemu进程（模拟了OS合并）进行处理，qemu进程会去调用内核系统调用，从而去操作IO硬件。而对于virtIO半虚拟化情况下，vm进行IO操作的时候，vm中IO半虚拟化驱动直接将该操作信息发送给qemu的virtIO的后端驱动，然后qemu去调用内核进行物理硬件操作，省去了kvm捕获的过程。</p>
<h3 id="KVM功能列表"><a href="#KVM功能列表" class="headerlink" title="KVM功能列表"></a>KVM功能列表</h3><p>KVM 所支持的功能包括：</p>
<ul>
<li>支持 CPU 和 memory 超分（Overcommit）</li>
<li>支持半虚拟化 I&#x2F;O （virtio）</li>
<li>支持热插拔 （cpu，块设备、网络设备等）</li>
<li>支持对称多处理（Symmetric Multi-Processing，缩写为 SMP ）</li>
<li>支持实时迁移（Live Migration）</li>
<li>支持 PCI 设备直接分配和 单根 I&#x2F;O 虚拟化 （SR-IOV）</li>
<li>支持 内核同页合并 （KSM ）</li>
<li>支持 NUMA （Non-Uniform Memory Access，非一致内存访问结构 ）</li>
</ul>
<h3 id="KVM工具集合"><a href="#KVM工具集合" class="headerlink" title="KVM工具集合"></a>KVM工具集合</h3><ul>
<li>libvirt：操作和管理KVM虚机的虚拟化 API，使用 C 语言编写，可以由 Python,Ruby, Perl, PHP, Java 等语言调用。可以操作包括 KVM，vmware，XEN，Hyper-v, LXC 等在内的多种 Hypervisor。</li>
<li>Virsh：基于 libvirt 的 命令行工具 （CLI）</li>
<li>Virt-Manager：基于 libvirt 的 GUI 工具</li>
<li>virt-v2v：虚机格式迁移工具</li>
<li>virt-* 工具：包括 Virt-install （创建KVM虚机的命令行工具）， Virt-viewer （连接到虚机屏幕的工具），Virt-clone（虚机克隆工具），virt-top 等</li>
<li>sVirt：安全工具</li>
</ul>
<h3 id="RedHat-Linux-KVM-安装"><a href="#RedHat-Linux-KVM-安装" class="headerlink" title="RedHat Linux KVM 安装"></a>RedHat Linux KVM 安装</h3><p>RedHat 有两款产品提供 KVM 虚拟化：</p>
<ul>
<li>Red Hat Enterprise Linux：适用于小的环境，提供数目较少的KVM虚机。最新的版本包括 6.5 和 7.0.</li>
<li>Red Hat Enterprise Virtualization (RHEV)：提供企业规模的KVM虚拟化环境，包括更简单的管理、HA，性能优化和其它高级功能。最新的版本是 3.0.</li>
</ul>
<p> RedHat Linux KVM:</p>
<ul>
<li>KVM 由 libvirt API 和基于该 API的一组工具进行管理和控制</li>
<li>KVM 支持系统资源超分，包括内存和CPU的超分。RedHat Linux 最多支持物理 CPU 内核总数的10倍数目的虚拟CPU，但是不支持在一个虚机上分配超过物理CPU内核总数的虚拟CPU。</li>
<li>支持 KSM （Kenerl Same-page Merging 内核同页合并）</li>
</ul>
<p> <strong>RedHat Linux KVM 有如下两种安装方式：</strong></p>
<h4 id="在安装-RedHat-Linux-时安装-KVM"><a href="#在安装-RedHat-Linux-时安装-KVM" class="headerlink" title="在安装 RedHat Linux 时安装 KVM"></a>在安装 RedHat Linux 时安装 KVM</h4><p>选择安装类型为 Virtualizaiton Host ：</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221104105835192.png" class="" title="image-20221104105835192">

<p>可以选择具体的 KVM 客户端、平台和工具：</p>
<img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221104105905213.png" class="" title="image-20221104105905213">



<h4 id="在已有的-RedHat-Linux-中安装-KVM"><a href="#在已有的-RedHat-Linux-中安装-KVM" class="headerlink" title="在已有的 RedHat Linux 中安装 KVM"></a>在已有的 RedHat Linux 中安装 KVM</h4><p>这种安装方式要求该系统已经被注册，否则会报错：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[root@rh65 ~]<span class="params">#</span> yum install qemu-kvm qemu-img</span><br><span class="line">Loaded plugins: product-id, refresh-packagekit, security, subscription-manager</span><br><span class="line">This system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.</span><br><span class="line">Setting up Install Process</span><br><span class="line">Nothing to do</span><br></pre></td></tr></table></figure>

<p>你至少需要安装 qemu-kvm qemu-img 这两个包。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> yum install qemu-kvm qemu-img</span><br></pre></td></tr></table></figure>

<p>你还可以安装其它工具包：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span> yum install virt-manager libvirt libvirt-python python-virtinst libvirt-client</span><br></pre></td></tr></table></figure>



<h4 id="QEMU-x2F-KVM-代码下载编译安装"><a href="#QEMU-x2F-KVM-代码下载编译安装" class="headerlink" title="QEMU&#x2F;KVM 代码下载编译安装"></a>QEMU&#x2F;KVM 代码下载编译安装</h4><h5 id="QEMU-x2F-KVM-的代码结构"><a href="#QEMU-x2F-KVM-的代码结构" class="headerlink" title="QEMU&#x2F;KVM 的代码结构"></a>QEMU&#x2F;KVM 的代码结构</h5><p>QEMU&#x2F;KVM 的代码包括几个部分：</p>
<p>（1）KVM 内核模块是 Linux 内核的一部分。通常 Linux 比较新的发行版（2.6.20+）都包含了 KVM 内核，也可以从<a href="https://www.kernel.org/">这里</a>得到。比如在我的RedHat 6.5 上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@rh65 isoimages]# uname -r</span><br><span class="line">2.6.32-431.el6.x86_64</span><br><span class="line">[root@rh65 isoimages]# modprobe -l | grep kvm</span><br><span class="line">kernel/arch/x86/kvm/kvm.ko</span><br><span class="line">kernel/arch/x86/kvm/kvm-intel.ko</span><br><span class="line">kernel/arch/x86/kvm/kvm-amd.ko</span><br></pre></td></tr></table></figure>

<p>（2）用户空间的工具即 qemu-kvm。qemu-kvm 是 KVM 项目从 QEMU 新拉出的一个分支（<a href="http://wiki.qemu.org/KVM">看这篇文章</a>）。在 QEMU 1.3 版本之前，QEMU 和 QEMU-KVM 是有区别的，但是从 2012 年底 GA 的 QEMU 1.3 版本开始，两者就完全一样了。</p>
<p>（3）Linux Guest OS virtio 驱动，也是较新的Linux 内核的一部分了。</p>
<p>（4）Windows Guest OS virtio 驱动，可以从<a href="http://www.linux-kvm.org/page/WindowsGuestDrivers/Download_Drivers">这里</a>下载。</p>
<h5 id="安装-QEMU"><a href="#安装-QEMU" class="headerlink" title="安装 QEMU"></a>安装 QEMU</h5><p>RedHat 6.5 上自带的 QEMU 太老，0.12.0 版本，最新版本都到了 2.* 了。</p>
<p>（1）. 参考 <a href="http://www.yimiju.com/articles/531.html">这篇文章</a>，将 RedHat 6.5 的 ISO 文件当作本地源</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">mount -o loop soft/rhel-server-6.4-x86<span class="built_in">_</span>64-dvd.iso /mnt/rhel6/</span><br><span class="line"></span><br><span class="line">vim /etc/fstab</span><br><span class="line">=&gt; /root/isoimages/soft/RHEL6.5-20131111.0-Server-x86<span class="built_in">_</span>64-DVD1.iso /mnt/rhel6 iso9660 ro,loop</span><br><span class="line">[root@rh65 qemu-2.3.0]<span class="params">#</span> cat /etc/yum.repos.d/local.repo</span><br><span class="line">[local]</span><br><span class="line">name=local</span><br><span class="line">baseurl=file:///mnt/rhel6/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcjeck=0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum clean all</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure>

<p>（2）. 安装依赖包包</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">yum install gcc</span><br><span class="line">yum install autoconf</span><br><span class="line">yum install autoconf automake libtool</span><br><span class="line">yum install -y glib*</span><br><span class="line">yum install zlib*</span><br></pre></td></tr></table></figure>

<p>（3）. 从 <a href="http://wiki.qemu.org/Download">http://wiki.qemu.org/Download</a> 下载代码，上传到我的编译环境 RedHat 6.5.</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">tar -jzvf qemu-2.3.0.tar.bz2</span><br><span class="line">cd qemu-2.3.0</span><br><span class="line">./configure</span><br><span class="line">make -j 4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>（4）. 安装完成</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">[root@rh65 qemu-2.3.0]<span class="params">#</span> /usr/local/bin/qemu-x86<span class="built_in">_</span>64 -version</span><br><span class="line">qemu-x86<span class="built_in">_</span>64 version 2.3.0, Copyright (c) 2003-2008 Fabrice Bellard</span><br></pre></td></tr></table></figure>

<p>（5）. 为方便起见，创建一个link</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">ln -s /usr/bin/qemu-system-x86<span class="built_in">_</span>64 /usr/bin/qemu-kvm</span><br></pre></td></tr></table></figure>

<h5 id="安装-libvirt"><a href="#安装-libvirt" class="headerlink" title="安装 libvirt"></a>安装 libvirt</h5><p>可以从 libvirt 官网下载安装包。最新的版本是 0.10.2. </p>
<h3 id="创建-KVM-虚机的几种方式"><a href="#创建-KVM-虚机的几种方式" class="headerlink" title="创建 KVM 虚机的几种方式"></a>创建 KVM 虚机的几种方式</h3><h4 id="使用-virt-install-命令"><a href="#使用-virt-install-命令" class="headerlink" title="使用 virt-install 命令"></a>使用 virt-install 命令</h4><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">virt-install <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>--name=guest1-rhel5-64 <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>--file=/var/lib/libvirt/images/guest1-rhel5-64.dsk <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>--file-size=8 <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>--nonsparse --graphics spice <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>--vcpus=2 --ram=2048 <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>--location=http://example1.com/installation<span class="built_in">_</span>tree/RHEL5.6-Serverx86<span class="built_in">_</span>64/os <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>--network bridge=br0 <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>--os-type=linux <span class="keyword">\</span></span><br><span class="line"><span class="keyword"></span>--os-variant=rhel5.4</span><br></pre></td></tr></table></figure>

<h4 id="使用-virt-manager-工具"><a href="#使用-virt-manager-工具" class="headerlink" title="使用 virt-manager 工具"></a>使用 virt-manager 工具</h4><img src="/2022/11/04/KVM/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8EKVM/image-20221104111131109.png" class="" title="image-20221104111131109">

<p><strong>使用 VMM GUI 创建的虚机的xml 定义文件在 &#x2F;etc&#x2F;libvirt&#x2F;qemu&#x2F; 目录中。</strong></p>
<h4 id="使用-qemu-img-和-qemu-kvm-命令行方式安装"><a href="#使用-qemu-img-和-qemu-kvm-命令行方式安装" class="headerlink" title="使用 qemu-img 和 qemu-kvm 命令行方式安装"></a>使用 qemu-img 和 qemu-kvm 命令行方式安装</h4><p>（1）创建一个空的qcow2格式的镜像文件</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2 windows-master.qcow2 10G</span><br></pre></td></tr></table></figure>

<p>（2）启动一个虚机，将系统安装盘挂到 cdrom，安装操作系统</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">qemu-kvm  -hda  windows-master.qcow2  -m  512  -boot d  -cdrom /home/user/isos/en<span class="built_in">_</span>winxp<span class="built_in">_</span>pro<span class="built_in">_</span>with<span class="built_in">_</span>sp2.iso</span><br></pre></td></tr></table></figure>

<p>（3）现在你就拥有了一个带操作系统的镜像文件。你可以以它为模板创建新的镜像文件。使用模板的好处是，它会被设置为只读所以可以免于破坏。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">qemu-img create -b windows-master.qcow2 -f  qcow2   windows-clone.qcow2</span><br></pre></td></tr></table></figure>

<p>（4）你可以在新的镜像文件上启动虚机了</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">qemu-kvm  -hda  windows-clone.qcow2  -m 400</span><br></pre></td></tr></table></figure>



<p>参考：</p>
<p><a href="https://www.cnblogs.com/sammyliu/p/4543110.html">KVM 介绍（1）：简介及安装 - SammyLiu - 博客园 (cnblogs.com)</a></p>
<hr>
]]></content>
      <categories>
        <category>KVM</category>
      </categories>
      <tags>
        <tag>KVM</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5标签介绍</title>
    <url>/2022/11/11/Front/html/HTML5/</url>
    <content><![CDATA[<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="浏览器介绍"><a href="#浏览器介绍" class="headerlink" title="浏览器介绍"></a>浏览器介绍</h2><h3 id="认识网页"><a href="#认识网页" class="headerlink" title="认识网页"></a>认识网页</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。</span><br></pre></td></tr></table></figure>

<p>flash已经越来越不推荐使用了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221109223344621.png" class="" title="image-20221109223344621">

<p>对于前端人员来说，需要写的是上面的html代码这些。手工去写。</p>
<p>html代码通过浏览器的渲染，然后最终是客户眼中的美丽网页。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221109223421812.png" class="" title="image-20221109223421812">

<h3 id="常见浏览器"><a href="#常见浏览器" class="headerlink" title="常见浏览器"></a>常见浏览器</h3><p>chrome，Firefox，edge</p>
<h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><p>浏览器内核（理解）-面试用</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。</span><br></pre></td></tr></table></figure>

<p>后来js用的多了，因此，将js单独拿出去了，脱离了浏览器内核。因此，现在说的浏览器内核，主要就是指渲染引擎。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。</span><br><span class="line">JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。</span><br><span class="line"></span><br><span class="line">最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。</span><br></pre></td></tr></table></figure>

<p>（1）Trident(IE内核) </p>
<p>国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。</p>
<p>代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。</p>
<p>Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。</p>
<p>360有一个极速浏览器，因为它用了两个内核，一个IE内核，一个google的内核。</p>
<p> win10出现之后，微软就不在支持IE了，主要支持Edge浏览器，并且使用新内核EdgeHTML了。</p>
<p>（2）Gecko(firefox) </p>
<p>Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。</p>
<p>Firefox慢的原因就是它支持非常好的flash，而flash加载又慢，因此，越来越多的人不爱使用Firefox了。</p>
<p>（3） webkit(Safari) </p>
<p>Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。</p>
<p>现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。</p>
<p>代表浏览器：傲游浏览器3、 Apple Safari (Win&#x2F;Mac&#x2F;iPhone&#x2F;iPad)、Symbian手机浏览器、Android 默认浏览器，</p>
<p>注意，webkit内核是苹果公司发明的。只是开始的时候google浏览器没有自己的内核的，拿苹果的浏览器内核webkit直接使用而已。</p>
<p>（4） Chromium&#x2F;Bink(chrome)</p>
<p>在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。 </p>
<p>大部分国产浏览器最新版都采用Blink内核。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221109233642515.png" class="" title="image-20221109233642515">



<p>（5） Presto(Opera) </p>
<p>Presto 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。</p>
<p>目前，Opera使用的也是google的blink内核了。</p>
<p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p>
<p>目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。</p>
<p>后面讲解移动开发的时候，会说明移动设备上哪个内核用的多，哪个少。</p>
<h3 id="web标准"><a href="#web标准" class="headerlink" title="web标准"></a>web标准</h3><p>通过以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221109233831951.png" class="" title="image-20221109233831951">

<p><strong>Web 标准的好处</strong></p>
<p><em>1</em>、让Web的发展前景更广阔 </p>
<p><em>2</em>、内容能被更广泛的设备访问 </p>
<p><em>3</em>、更容易被搜寻引擎搜索 </p>
<p><em>4</em>、降低网站流量费用 </p>
<p><em>5</em>、使网站更易于维护 </p>
<p><em>6</em>、提高页面浏览速度</p>
<p><strong>Web 标准构成</strong></p>
<p>Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。</span><br><span class="line">样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。</span><br><span class="line">行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分</span><br></pre></td></tr></table></figure>

<p>理想状态我们的源码： .HTML .css .js</p>
<p>html控制结构。骨骼</p>
<p>css控制样式。外表</p>
<p>js控制行为。动作</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221109234019469.png" class="" title="image-20221109234019469">



<h2 id="HTML基本结构"><a href="#HTML基本结构" class="headerlink" title="HTML基本结构"></a>HTML基本结构</h2><h3 id="HTML初识"><a href="#HTML初识" class="headerlink" title="HTML初识"></a>HTML初识</h3><p>一般先学习HTML+CSS， 这里我们先定一个小目标，先学HTML,后学习CSS。</p>
<p>HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span> 我是加粗的字体 <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意： 体会 文本 标签 语言 几个词语 </p>
<h3 id="HTML骨架"><a href="#HTML骨架" class="headerlink" title="HTML骨架"></a>HTML骨架</h3><p>HTML 有自己的语言语法骨架格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HTML</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HTML</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1 HTML标签：</span><br><span class="line"></span><br><span class="line">作用所有HTML中标签的一个根节点。</span><br><span class="line"></span><br><span class="line">2 head标签：</span><br><span class="line"></span><br><span class="line">作用：用于存放：title,meta,base,style,script,link</span><br><span class="line"></span><br><span class="line">注意在head标签中我们必须要设置的标签是title</span><br><span class="line"></span><br><span class="line">3.title标签：</span><br><span class="line"></span><br><span class="line">作用：让页面拥有一个属于自己的标题。</span><br><span class="line"></span><br><span class="line">4.body标签：</span><br><span class="line"></span><br><span class="line">作用：页面在的主体部分，用于存放所有的HTML标签：p,h,a,b,u,i,s,em,del,ins,strong,img</span><br></pre></td></tr></table></figure>



<h3 id="我的第一个页面及其标签简介"><a href="#我的第一个页面及其标签简介" class="headerlink" title="我的第一个页面及其标签简介"></a>我的第一个页面及其标签简介</h3><img src="/2022/11/11/Front/html/HTML5/image-20221109234357238.png" class="" title="image-20221109234357238">

<img src="/2022/11/11/Front/html/HTML5/image-20221109234439439.png" class="" title="image-20221109234439439">



<h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><h3 id="什么是标签及其分类"><a href="#什么是标签及其分类" class="headerlink" title="什么是标签及其分类"></a>什么是标签及其分类</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;HTML&gt;、&lt;head&gt;、&lt;body&gt;都是HTML标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素。</span><br></pre></td></tr></table></figure>

<p>1.双标签</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;标签名&gt; 内容 &lt;/标签名&gt;</span><br></pre></td></tr></table></figure>

<p>该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;&#x2F;标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“&#x2F;”。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">比如 &lt;body&gt;我是文字  &lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>2.单标签</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;标签名 /&gt;</span><br></pre></td></tr></table></figure>

<p>单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">比如  &lt;br /&gt;</span><br></pre></td></tr></table></figure>

<p>单标签数量不多。</p>
<h3 id="标签嵌套和并列关系"><a href="#标签嵌套和并列关系" class="headerlink" title="标签嵌套和并列关系"></a>标签嵌套和并列关系</h3><p>标签的相互关系就分为两种：</p>
<p>1.嵌套关系</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  <span class="tag">&lt;<span class="name">title</span>&gt;</span> <span class="tag">&lt;/<span class="name">title</span>&gt;</span>  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>html标签是所有标签的顶级标签。</p>
<p>2.并列关系</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="简单小测验"><a href="#简单小测验" class="headerlink" title="简单小测验"></a>简单小测验</h3><p>测试题：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">请问下列哪个标签是错误的？</span><br><span class="line">A  &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;</span><br><span class="line">B  &lt;strong&gt;&lt;div&gt;&lt;/div&gt;&lt;/strong&gt;</span><br><span class="line">C  &lt;head&gt;&lt;title&gt;&lt;/head&gt;&lt;/title&gt;</span><br><span class="line">D  &lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p> 答案：c</p>
<p>倡议： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位。如果是并列关系，最好上下对齐。</p>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><img src="/2022/11/11/Front/html/HTML5/image-20221109234910690.png" class="" title="image-20221109234910690">

<p>hbuilder是一个国产软件。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在页面中输入 以下2个单词</span><br><span class="line">1.  html: 5   </span><br><span class="line">2.  !</span><br><span class="line">   在sublime里面然后按下tab键盘即可生成HTML骨架</span><br></pre></td></tr></table></figure>

<p> 需要安装emmet插件。</p>
<h3 id="doctype文档类型"><a href="#doctype文档类型" class="headerlink" title="doctype文档类型"></a>doctype文档类型</h3><p><strong>文档类型&lt;!DOCTYPE&gt;</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这句话就是告诉我们使用哪个html版本？ 我们使用的是 html 5 的版本。 html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。</p>
<p>标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。</p>
<p>注意： 一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用HTML5的文档类型就好了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> 这种标识，就是告诉浏览器，当前使用的html版本是5的。</span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Front/html/HTML5/image-20221109235151734.png" class="" title="image-20221109235151734">

<p>这个是html5的上一个版本。xhtml</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221109235323100.png" class="" title="image-20221109235323100">



<img src="/2022/11/11/Front/html/HTML5/image-20221109235337512.png" class="" title="image-20221109235337512">



<img src="/2022/11/11/Front/html/HTML5/image-20221109235422912.png" class="" title="image-20221109235422912">



<img src="/2022/11/11/Front/html/HTML5/image-20221109235441847.png" class="" title="image-20221109235441847">



<img src="/2022/11/11/Front/html/HTML5/image-20221109235455902.png" class="" title="image-20221109235455902">



<img src="/2022/11/11/Front/html/HTML5/image-20221109235518547.png" class="" title="image-20221109235518547">



<img src="/2022/11/11/Front/html/HTML5/image-20221109235540848.png" class="" title="image-20221109235540848">



<img src="/2022/11/11/Front/html/HTML5/image-20221109235602225.png" class="" title="image-20221109235602225">

<h3 id="字符集简介"><a href="#字符集简介" class="headerlink" title="字符集简介"></a>字符集简介</h3><p><strong>字符集</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt; 告诉浏览器，用什么编码集来解析当前页面，也就是告诉浏览器，我当前这个页面使用的字符集是什么，这样浏览器解析这个界面，就使用对应的字符集进行解析了。</span><br></pre></td></tr></table></figure>

<p>utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</p>
<p>gb2312 简单中文 包括6763个汉字</p>
<p>BIG5 繁体中文 港澳台等用</p>
<p>GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312</p>
<p>UTF-8则包含全世界所有国家需要用到的字符</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。</span><br></pre></td></tr></table></figure>

<p>gb2312是只支持简体中文的。</p>
<p>big5是只支持繁体中文的。</p>
<p>gbk则是简体中文和繁体中文都支持的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110094627152.png" class="" title="image-20221110094627152">

<p>现在没有指定字符集。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110094640591.png" class="" title="image-20221110094640591">

<p>页面乱码了。</p>
<p>这就是没有告诉浏览器当前我这个页面使用的字符集是什么，这样浏览器就使用默认字符集进行解析了。</p>
<p>当指定了字符集的时候，保存文件的时候，也会按照指定的字符集进行保存，然后浏览器解析文件的时候，加载文件到内存，然后使用指定的字符集进行解析。</p>
<p>如果不指定字符集的话，那么保存文件的时候，会使用默认的字符集对文件进行保存的，浏览器解析文件的时候，将文件加载到内存，然后会使用浏览器默认的字符集进行解析的，可能与保存文件的时候，使用的字符集不同的。因此，很容易发生乱码。</p>
<h3 id="标签的语义化"><a href="#标签的语义化" class="headerlink" title="标签的语义化"></a>标签的语义化</h3><p>白话： 所谓标签语义化，就是指标签的含义。</p>
<p>为什么要有语义化标签</p>
<p>1、方便代码的阅读和维护</p>
<p>2、同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 </p>
<p>3、使用语义化标签会具有更好地搜索引擎优化 </p>
<p>核心：合适的地方给一个最为合理的标签。</p>
<p>语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。</p>
<p>不管是谁都能看懂这块内容是什么。</p>
<p>遵循的原则：先确定语义的HTML ，再选合适的CSS。</p>
<p>标签语义化，就是指这个标签是干什么用的，见名知意。</p>
<h4 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h4><p>首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。</p>
<p>HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。</p>
<h5 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h5><p>排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。</p>
<p>排版标签，主要是完成网页的布局的。</p>
<h6 id="标题标签-熟记"><a href="#标题标签-熟记" class="headerlink" title="标题标签(熟记)"></a>标题标签(熟记)</h6><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">单词缩写： head 头部. 标题 </span><br><span class="line">为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即</span><br><span class="line">&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;</span><br><span class="line">标题标签语义：  作为标题使用，并且依据重要性递减</span><br><span class="line"></span><br><span class="line">其基本语法格式如下：</span><br><span class="line">&lt;hn&gt;   标题文本   &lt;/hn&gt;</span><br><span class="line"> 注意： h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。 一般h1 都是给logo使用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Front/html/HTML5/image-20221110101011553.png" class="" title="image-20221110101011553">

<img src="/2022/11/11/Front/html/HTML5/image-20221110101025804.png" class="" title="image-20221110101025804">

<p>注意，标题标签最小到h6，再往下就没有变化了，显示为正常的文本了。</p>
<h6 id="段落标签-熟记"><a href="#段落标签-熟记" class="headerlink" title="段落标签( 熟记)"></a>段落标签( 熟记)</h6><p>单词缩写： paragraph 段落</p>
<p>在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;  文本内容  &lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</p>
<h6 id="水平线标签-认识"><a href="#水平线标签-认识" class="headerlink" title="水平线标签(认识)"></a>水平线标签(认识)</h6><p>单词缩写： horizontal 横线</p>
<p>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，&lt;hr&#x2F;&gt;就是创建横跨网页水平线的标签。其基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hr /&gt;是单标签</span><br></pre></td></tr></table></figure>

<p>在网页中显示默认样式的水平线。</p>
<h6 id="换行标签-熟记"><a href="#换行标签-熟记" class="headerlink" title="换行标签(熟记)"></a>换行标签(熟记)</h6><p>单词缩写： break 打断 ,换行</p>
<p>在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;br /&gt;</span><br></pre></td></tr></table></figure>

<p>这时如果还像在word中直接敲回车键换行就不起作用了。</p>
<h6 id="div-span标签-重点"><a href="#div-span标签-重点" class="headerlink" title="div span标签(重点)"></a>div span标签(重点)</h6><p>div span 是没有语义的 是我们网页布局主要的2个盒子</p>
<p>div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。</p>
<p>span, 跨度，跨距；范围 </p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; 这是头部 &lt;/div&gt;    &lt;span&gt;今日价格&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>div和span，主要是用来进行布局使用的标签。</p>
<p>div和span是两个盒子标签。</p>
<h5 id="文本格式化标签-熟记"><a href="#文本格式化标签-熟记" class="headerlink" title="文本格式化标签(熟记)"></a>文本格式化标签(熟记)</h5><p>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110104828918.png" class="" title="image-20221110104828918">

<p>这里前面的标签和后面的标签标示的意义相同，但是仍然有区别，后面的标签具有语义，这样在页面优化的过程中会更好，后面说。</p>
<p>推挤使用后面的具有语义的标签。</p>
<p>b i s u 只有使用 没有 强调的意思 strong em del ins 语义更强烈</p>
<h5 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h5><p>属性就是特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的。。</p>
<p>使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">&lt;标签名 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; …&gt; 内容 &lt;/标签名&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的语法中，</p>
<p>1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</p>
<p>2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</p>
<p>3.任何标签的属性都有默认值，省略该属性则取默认值。例如：hr标签的width不写，那么就和浏览器一样宽。red不写，那么就有默认的颜色。</p>
<p>采取 键值对 的格式 key&#x3D;”value” 的格式 </p>
<p> 比如: </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>属性 是 宽度 </p>
<p>值 是 400 </p>
<p>提倡： 尽量不使用 样式属性。 样式通过css去控制。</p>
<h5 id="图像标签img-重点"><a href="#图像标签img-重点" class="headerlink" title="图像标签img(重点)"></a>图像标签img(重点)</h5><p>单词缩写： image 图像</p>
<p>HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签以及和他相关的属性。其基本语法格式如下：</p>
<p>该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>src属性是必须的，说明图片来自哪里。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110105818340.png" class="" title="image-20221110105818340">

<p>border后面讲解css的时候，再使用。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110113933165.png" class="" title="image-20221110113933165">

<img src="/2022/11/11/Front/html/HTML5/image-20221110114001427.png" class="" title="image-20221110114001427">



<img src="/2022/11/11/Front/html/HTML5/image-20221110114043293.png" class="" title="image-20221110114043293">

<img src="/2022/11/11/Front/html/HTML5/image-20221110114108406.png" class="" title="image-20221110114108406">

<img src="/2022/11/11/Front/html/HTML5/image-20221110114151486.png" class="" title="image-20221110114151486">

<img src="/2022/11/11/Front/html/HTML5/image-20221110114229062.png" class="" title="image-20221110114229062">

<p>边框也是可以改颜色的，学习完css的时候，就可以了，目前不行。</p>
<h5 id="链接标签-重点"><a href="#链接标签-重点" class="headerlink" title="链接标签(重点)"></a>链接标签(重点)</h5><p>单词缩写： anchor 的缩写 。基本解释 锚, 铁锚 的</p>
<p>在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本或图像<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用</p>
<p>target：用于指定链接页面的打开方式，其取值有self和blank两种，其中self为默认值当前窗口打开，blank为在新窗口中打开方式。</p>
<p>注意：</p>
<p>1.外部链接 需要添加 http:&#x2F;&#x2F; <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>2.内部链接 直接链接内部页面名称即可 比如 &lt; a href&#x3D;”index.html”&gt; 首页 </p>
<p>3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href&#x3D;”#”)，表示该链接暂时为一个空链接。</p>
<p>4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110120500642.png" class="" title="image-20221110120500642">

<p>外部连接，必须以http:&#x2F;&#x2F;开头的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110120536722.png" class="" title="image-20221110120536722">

<h6 id="锚点定位-难点"><a href="#锚点定位-难点" class="headerlink" title="锚点定位(难点)"></a>锚点定位(难点)</h6><p>通过创建锚点链接，用户能够快速定位到目标内容。 创建锚点链接分为两步：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.使用&quot;&lt;a href=&quot;<span class="params">#</span>id名&quot;&gt;链接文本&lt;/a&gt;&quot;创建链接文本。</span><br><span class="line"></span><br><span class="line">2.使用相应的id名标注跳转目标的位置。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Front/html/HTML5/image-20221110135204708.png" class="" title="image-20221110135204708">

<img src="/2022/11/11/Front/html/HTML5/image-20221110135216910.png" class="" title="image-20221110135216910">

<p>#id名</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110135307101.png" class="" title="image-20221110135307101">

<p>在下面相应的位置定义对应的id名，和上面的要一致。这里就是定义锚点。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110135409689.png" class="" title="image-20221110135409689">

<img src="/2022/11/11/Front/html/HTML5/image-20221110135444707.png" class="" title="image-20221110135444707">



<h6 id="base-标签"><a href="#base-标签" class="headerlink" title="base 标签"></a>base 标签</h6><p>base 可以设置整体的超链接的打开状态，就是在哪个页面打开的意思。 </p>
<p>base 写到&lt;head&gt;&lt;&#x2F;head&gt;之间</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110135741210.png" class="" title="image-20221110135741210">

<p>对于这些超链接，如果想要在新的页面打开，那么每个都需要这样来写。很麻烦。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110135803561.png" class="" title="image-20221110135803561">

<p>base标签也是一个单标签。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110135855723.png" class="" title="image-20221110135855723">

<p>此时就是在新窗口中打开的了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110135922713.png" class="" title="image-20221110135922713">

<p>个别的链接在当前页面打开，可以特别指定。</p>
<h5 id="特殊字符标签-理解"><a href="#特殊字符标签-理解" class="headerlink" title="特殊字符标签(理解)"></a>特殊字符标签(理解)</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110140117797.png" class="" title="image-20221110140117797">

<img src="/2022/11/11/Front/html/HTML5/image-20221110140136241.png" class="" title="image-20221110140136241">

<img src="/2022/11/11/Front/html/HTML5/image-20221110140150369.png" class="" title="image-20221110140150369">



<img src="/2022/11/11/Front/html/HTML5/image-20221110140204723.png" class="" title="image-20221110140204723">

<img src="/2022/11/11/Front/html/HTML5/image-20221110140219195.png" class="" title="image-20221110140219195">

<h5 id="注释标签"><a href="#注释标签" class="headerlink" title="注释标签"></a>注释标签</h5><p>在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：  </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 --&gt;</span></span><br></pre></td></tr></table></figure>

<p>注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110140418181.png" class="" title="image-20221110140418181">



<h5 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h5><p>实际工作中，通常新建一个文件夹专门用于存放图像文件，这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。</p>
<p>路径可以分为： 相对路径和绝对路径</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">相对路径</span><br><span class="line">1、图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=&quot;logo.gif&quot;/&gt;。</span><br><span class="line">2、图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=&quot;img/img01/logo.gif&quot;/&gt;。</span><br><span class="line">3、图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=&quot;../logo.gif&quot; /&gt;。</span><br><span class="line"></span><br><span class="line">绝对路径</span><br><span class="line">“D:<span class="keyword">\web</span><span class="keyword">\img</span><span class="keyword">\logo</span>.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><p><strong>无序列表 ul (重点)</strong></p>
<p>无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110141142618.png" class="" title="image-20221110141142618">



<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1、&lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。</span><br><span class="line">2、&lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。</span><br><span class="line">3、无序列表会带有自己样式属性，放下那个样式，一会让CSS来！</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Front/html/HTML5/image-20221110141301637.png" class="" title="image-20221110141301637">

<img src="/2022/11/11/Front/html/HTML5/image-20221110141319448.png" class="" title="image-20221110141319448">

<p>前面的圆点或者方块之类的，都是后面css来控制的，这里无需关系，不用考虑标签自己的属性。</p>
<p><strong>无序列表注意事项</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110141617326.png" class="" title="image-20221110141617326">

<p>这样写，不会报错，但是不科学，不符合规范。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110141638157.png" class="" title="image-20221110141638157">

<p>ul标签里面只能放li标签，不能放其他的任何内容。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110141656816.png" class="" title="image-20221110141656816">

<p>li标签里面可以放任何内容的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110141714389.png" class="" title="image-20221110141714389">

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1、&lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。</span><br><span class="line">2、&lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。</span><br><span class="line">3、无序列表会带有自己样式属性，放下哪个样式，一会让CSS来！</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>有序列表 ol (了解)</strong></p>
<p>有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所有特性基本与ul 一致。 </p>
<p>但是实际工作中， 较少用 ol 。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110141901232.png" class="" title="image-20221110141901232">

<img src="/2022/11/11/Front/html/HTML5/image-20221110141913606.png" class="" title="image-20221110141913606">

<p>同样，前面的1，2这些也能改，通过css来设置的。</p>
<p><strong>案例</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110142006938.png" class="" title="image-20221110142006938">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142018492.png" class="" title="image-20221110142018492">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142029741.png" class="" title="image-20221110142029741">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142043209.png" class="" title="image-20221110142043209">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142110028.png" class="" title="image-20221110142110028">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142124886.png" class="" title="image-20221110142124886">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142139310.png" class="" title="image-20221110142139310">



<p><strong>自定义列表</strong></p>
<p>自定义列表常用于对术语或名词进行解释和描述，自定义列表的列表项前没有任何项目符号。其基本语法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词1解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词2解释1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>名词2解释2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Front/html/HTML5/image-20221110142247192.png" class="" title="image-20221110142247192">

<p>dd是围绕dt来进行解释和描述的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110142321360.png" class="" title="image-20221110142321360">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142340852.png" class="" title="image-20221110142340852">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142435253.png" class="" title="image-20221110142435253">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142453121.png" class="" title="image-20221110142453121">

<img src="/2022/11/11/Front/html/HTML5/image-20221110142515076.png" class="" title="image-20221110142515076">

<p>上面的就是dt，下面的就是dd。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110142552149.png" class="" title="image-20221110142552149">



<h5 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h5><p><strong>认识表格</strong></p>
<p>有人说表格现在不是不用了么？实际上不是，只是说不用它来进行布局了。</p>
<p>表格出现的时候，本来就不是用来做布局的。</p>
<p><strong>表格 table(会使用)</strong></p>
<p>存在即是合理的。 表格的现在还是较为常用的一种标签，但不是用来布局，常见处理表格式数据。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110142818700.png" class="" title="image-20221110142818700">

<p>ps: 这些地方用表格，你会觉得生活还是那么美好。。。。</p>
<p>表格的作用就是用来处理各种数据的。</p>
<p><strong>创建表格</strong></p>
<p>在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>单元格内的文字<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的语法中包含三对HTML标签，分别为 &lt;table&gt;&lt;&#x2F;table&gt;、&lt;tr&gt;&lt;&#x2F;tr&gt;、&lt;td&gt;&lt;&#x2F;td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1.table用于定义一个表格。</span><br><span class="line"></span><br><span class="line">2.tr 用于定义表格中的一行，必须嵌套在 table /table标签中，在 table /table中包含几对 tr /tr，就有几行表格。</span><br><span class="line"></span><br><span class="line">3.td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">注意：</span><br><span class="line">1. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt;</span><br><span class="line">2. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Front/html/HTML5/image-20221110143052423.png" class="" title="image-20221110143052423">

<img src="/2022/11/11/Front/html/HTML5/image-20221110143113145.png" class="" title="image-20221110143113145">



<p><strong>表格使用注意事项</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110143152027.png" class="" title="image-20221110143152027">

<p>不能这样来写的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110143216120.png" class="" title="image-20221110143216120">

<p>注意，td标签就像li标签一样，里面可以放任意内容的。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">1. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt;</span><br><span class="line">2. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Front/html/HTML5/image-20221110143329745.png" class="" title="image-20221110143329745">

<p>td里面甚至再放一个表格，都是可以的。</p>
<p><strong>表格属性</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110143429491.png" class="" title="image-20221110143429491">

<p>表格的属性，因此，这些属性，应该写在table标签中的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110143513639.png" class="" title="image-20221110143513639">

<img src="/2022/11/11/Front/html/HTML5/image-20221110143526948.png" class="" title="image-20221110143526948">

<img src="/2022/11/11/Front/html/HTML5/image-20221110143541937.png" class="" title="image-20221110143541937">

<img src="/2022/11/11/Front/html/HTML5/image-20221110143609271.png" class="" title="image-20221110143609271">

<img src="/2022/11/11/Front/html/HTML5/image-20221110143626904.png" class="" title="image-20221110143626904">

<p>cellpadding控制内容和单元格边框之间的距离。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110143652434.png" class="" title="image-20221110143652434">

<img src="/2022/11/11/Front/html/HTML5/image-20221110143706424.png" class="" title="image-20221110143706424">

<img src="/2022/11/11/Front/html/HTML5/image-20221110143720560.png" class="" title="image-20221110143720560">

<img src="/2022/11/11/Front/html/HTML5/image-20221110143740629.png" class="" title="image-20221110143740629">

<p>align，只能设置表格的水平对齐方式，垂直对齐后面再说。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110143803671.png" class="" title="image-20221110143803671">

<img src="/2022/11/11/Front/html/HTML5/image-20221110143819536.png" class="" title="image-20221110143819536">



<p><strong>表头标签</strong></p>
<p>表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;&#x2F;th&gt;替代相应的单元格标签&lt;td&gt;&lt;&#x2F;td&gt;即可。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110144056909.png" class="" title="image-20221110144056909">

<p>表头一般就是指第一行或者第一列，再往里面就不能够使用表头了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110144123249.png" class="" title="image-20221110144123249">

<img src="/2022/11/11/Front/html/HTML5/image-20221110144147214.png" class="" title="image-20221110144147214">

<p><strong>表格结构(了解)</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示：</span><br><span class="line"></span><br><span class="line">&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。</span><br><span class="line"></span><br><span class="line">必须位于&lt;table&gt;&lt;/table&gt; 标签中，一般包含网页的logo和导航等头部信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。</span><br><span class="line"></span><br><span class="line">位于&lt;table&gt;&lt;/table&gt;标签中，一般包含网页中除头部和底部之外的其他内容。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Front/html/HTML5/image-20221110145408729.png" class="" title="image-20221110145408729">

<img src="/2022/11/11/Front/html/HTML5/image-20221110145424010.png" class="" title="image-20221110145424010">

<img src="/2022/11/11/Front/html/HTML5/image-20221110145446097.png" class="" title="image-20221110145446097">

<p>对于样式，后面css的时候，再说明。</p>
<p><strong>浏览器审查HTML标签元素</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110145741904.png" class="" title="image-20221110145741904">

<p>或者按f12</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110145803538.png" class="" title="image-20221110145803538">

<img src="/2022/11/11/Front/html/HTML5/image-20221110145824171.png" class="" title="image-20221110145824171">

<p>点击小箭头，然后页面点击任何一个元素，就会快速的跳到对应的标签了。</p>
<p>我们现在只看左边的elements部分，是html标签内容。右边的sytles是css的内容，后面再说。</p>
<p><strong>表格标题标签</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110145943593.png" class="" title="image-20221110145943593">

<img src="/2022/11/11/Front/html/HTML5/image-20221110150337814.png" class="" title="image-20221110150337814">

<img src="/2022/11/11/Front/html/HTML5/image-20221110150349555.png" class="" title="image-20221110150349555">



<p><strong>合并单元格</strong></p>
<p>跨行合并：rowspan 跨列合并：colspan</p>
<p>合并单元格的思想：</p>
<p>将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。</p>
<p>公式： 删除的个数 &#x3D; 合并的个数 - 1 </p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110150502235.png" class="" title="image-20221110150502235">

<img src="/2022/11/11/Front/html/HTML5/image-20221110150518017.png" class="" title="image-20221110150518017">

<img src="/2022/11/11/Front/html/HTML5/image-20221110150536581.png" class="" title="image-20221110150536581">

<img src="/2022/11/11/Front/html/HTML5/image-20221110150605293.png" class="" title="image-20221110150605293">

<p><strong>总结表格</strong></p>
<p>表格提供了HTML 中定义表格式数据的方法。</p>
<p>表格中由行中的单元格组成。</p>
<p>表格中没有列元素，列的个数取决于行的单元格个数。</p>
<p>表格不要纠结于外观，那是CSS 的作用。</p>
<h5 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h5><p><strong>表单的作用</strong></p>
<p>现实中的表单，类似我们去银行办理信用卡填写的单子。 如下图</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110150932185.png" class="" title="image-20221110150932185">

<p>目的是为了收集用户信息。</p>
<p>在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。</p>
<p>在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110151527020.png" class="" title="image-20221110151527020">

<p><strong>表单控件：</strong></p>
<p>包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</p>
<p><strong>提示信息：</strong></p>
<p>一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</p>
<p><strong>表单域：</strong> </p>
<p>他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</p>
<p><strong>文本框和密码框</strong></p>
<p><strong>input 控件(重点)</strong></p>
<p>在上面的语法中，&lt;input &#x2F;&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input &#x2F;&gt;标签还可以定义很多其他的属性，其常用属性如下表所示。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110151907730.png" class="" title="image-20221110151907730">

<p>input控件根据type的不同，而表现为不同的表单控件。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110152012958.png" class="" title="image-20221110152012958">

<img src="/2022/11/11/Front/html/HTML5/image-20221110152056730.png" class="" title="image-20221110152056730">



<img src="/2022/11/11/Front/html/HTML5/image-20221110152122413.png" class="" title="image-20221110152122413">



<p><strong>单选按钮和复选按钮</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110152246734.png" class="" title="image-20221110152246734">

<p>此时需要通过name属性，将他们定义为一个组。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110154716675.png" class="" title="image-20221110154716675">

<p>name相同，说明是同一组控件。注意，必须是name值相同，才能够是同一组控件的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110154753898.png" class="" title="image-20221110154753898">

<img src="/2022/11/11/Front/html/HTML5/image-20221110154804184.png" class="" title="image-20221110154804184">

<p>注意，相同的name的值，表示他们是同一组的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110154824946.png" class="" title="image-20221110154824946">



<p><strong>默认选中表单属性</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110154916616.png" class="" title="image-20221110154916616">

<p>此时女就是默认被选中的了。</p>
<p><strong>input按钮组</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110155025658.png" class="" title="image-20221110155025658">

<img src="/2022/11/11/Front/html/HTML5/image-20221110155048430.png" class="" title="image-20221110155048430">



<img src="/2022/11/11/Front/html/HTML5/image-20221110155117326.png" class="" title="image-20221110155117326">

<p>submit本身就是提交按钮，因此，不写value，默认value的值就是提交。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110155204941.png" class="" title="image-20221110155204941">

<p>现在还没有表单域，因此，提交按钮不能够提交到后台的。</p>
<p>普通按钮和提交按钮，都能够提交表单的。需要表单域的支持。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110162444453.png" class="" title="image-20221110162444453">

<p>先看外形。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110162502560.png" class="" title="image-20221110162502560">

<p>图片按钮，src指定图片位置。注意，只有图片按钮，才能够指定src的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110162534637.png" class="" title="image-20221110162534637">

<img src="/2022/11/11/Front/html/HTML5/image-20221110205525964.png" class="" title="image-20221110205525964">

<p>上传文件按钮。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110205542109.png" class="" title="image-20221110205542109">



<p><strong>最多字符数和文本值</strong></p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110205727275.png" class="" title="image-20221110205727275">

<p>控制控件上最多允许输入的字符数。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110205848123.png" class="" title="image-20221110205848123">

<img src="/2022/11/11/Front/html/HTML5/image-20221110205911639.png" class="" title="image-20221110205911639">

<p><strong>label标签(理解)</strong></p>
<p>label 标签为 input 元素定义标注（标签）。</p>
<p>作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点</p>
<p>如何绑定元素呢？</p>
<p>for 属性规定 label 与哪个表单元素绑定。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>Male<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Front/html/HTML5/image-20221110210227444.png" class="" title="image-20221110210227444">

<p>当我们点击左边的文字，右边的文本输入框就能够获得焦点。label就是起到这个作用的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110210256975.png" class="" title="image-20221110210256975">

<p>直接将对应的元素包裹即可。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110210324427.png" class="" title="image-20221110210324427">

<p>此时点击左边的文字，焦点定位到了右边的输入框中了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110210408213.png" class="" title="image-20221110210408213">

<p>当有多个input的表单元素的时候，那么label包裹，那么只能默认第一个能够获得焦点。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110210440448.png" class="" title="image-20221110210440448">

<p>只能焦点到第一个输入框，第二个输入框不能够获得焦点。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110210519508.png" class="" title="image-20221110210519508">

<img src="/2022/11/11/Front/html/HTML5/image-20221110210606037.png" class="" title="image-20221110210606037">

<img src="/2022/11/11/Front/html/HTML5/image-20221110210619503.png" class="" title="image-20221110210619503">



<p><strong>文本域</strong></p>
<p><strong>textarea控件(文本域)</strong></p>
<p>如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;&#x2F;textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;每行中的字符数&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;显示的行数&quot;</span>&gt;</span></span><br><span class="line">  文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>下拉菜单</strong></p>
<p>使用select控件定义下拉菜单的基本语法格式如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>选项3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1、&lt;select&gt;&lt;&#x2F;select&gt;中至少应包含一对&lt;option&gt;&lt;&#x2F;option&gt;。</p>
<p>2、在option 中定义selected &#x3D;” selected “时，当前项即为默认选中项。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110211224212.png" class="" title="image-20221110211224212">

<img src="/2022/11/11/Front/html/HTML5/image-20221110211240836.png" class="" title="image-20221110211240836">

<img src="/2022/11/11/Front/html/HTML5/image-20221110211256935.png" class="" title="image-20221110211256935">

<img src="/2022/11/11/Front/html/HTML5/image-20221110211309793.png" class="" title="image-20221110211309793">

<img src="/2022/11/11/Front/html/HTML5/image-20221110211459799.png" class="" title="image-20221110211459799">

<p>后面学习了js之后，就可以进行联动了，选择北京之后，自动选择通州。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110211527475.png" class="" title="image-20221110211527475">



<p><strong>表单域</strong></p>
<p>在HTML中，form标签被用于定义表单域，即创建一个表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单域的基本语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单域名称&quot;</span>&gt;</span></span><br><span class="line">  各种表单控件</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>常用属性：</p>
<p>1、Action 在表单域收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单域数据的服务器程序的url地址。</p>
<p>2、method 用于设置表单域数据的提交方式，其取值为get或post。</p>
<p>3、name 用于指定表单域的名称，以区分同一个页面中的多个表单域。</p>
<p>注意： 每个表单控件都应该有自己表单域。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110211818021.png" class="" title="image-20221110211818021">

<img src="/2022/11/11/Front/html/HTML5/image-20221110211850826.png" class="" title="image-20221110211850826">

<p>form就是红色的边框。表单域。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110211913914.png" class="" title="image-20221110211913914">

<p>快速输入方式。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110211933192.png" class="" title="image-20221110211933192">

<img src="/2022/11/11/Front/html/HTML5/image-20221110212000796.png" class="" title="image-20221110212000796">

<img src="/2022/11/11/Front/html/HTML5/image-20221110212207088.png" class="" title="image-20221110212207088">

<img src="/2022/11/11/Front/html/HTML5/image-20221110212254683.png" class="" title="image-20221110212254683">

<img src="/2022/11/11/Front/html/HTML5/image-20221110212310526.png" class="" title="image-20221110212310526">

<p>现在的表单控件，需要有name属性，目的是提交到服务器的时候，能够通过name拿到表单控件中输入的值。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110212352439.png" class="" title="image-20221110212352439">

<img src="/2022/11/11/Front/html/HTML5/image-20221110212401308.png" class="" title="image-20221110212401308">

<p>get提交不安全，会在url后面跟上提交的内容。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110212427721.png" class="" title="image-20221110212427721">

<p>一般使用post提交。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110212533023.png" class="" title="image-20221110212533023">

<img src="/2022/11/11/Front/html/HTML5/image-20221110212546672.png" class="" title="image-20221110212546672">

<img src="/2022/11/11/Front/html/HTML5/image-20221110212607670.png" class="" title="image-20221110212607670">

<p>页面中有多个表单的时候，通过name进行区分。彼此之间互不影响。不管是重置按钮还是提交按钮，互相不影响。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110212648342.png" class="" title="image-20221110212648342">



<h4 id="HTML5新增标签和属性"><a href="#HTML5新增标签和属性" class="headerlink" title="HTML5新增标签和属性"></a>HTML5新增标签和属性</h4><h5 id="html5文档类型和字符集"><a href="#html5文档类型和字符集" class="headerlink" title="html5文档类型和字符集"></a>html5文档类型和字符集</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110212833899.png" class="" title="image-20221110212833899">

<img src="/2022/11/11/Front/html/HTML5/image-20221110212844133.png" class="" title="image-20221110212844133">

<p>html5的发展历程。</p>
<p>我们学习的是html5版本。</p>
<p>我们只需要认出其他版本的html和html5之间的不同即可。</p>
<p><strong>文档类型设定</strong></p>
<p>document</p>
<p>HTML: sublime中输入html:4s</p>
<p>XHTML: sublime中输入html:xt</p>
<p>HTML5: sublime中输入html:5 &lt;!DOCTYPE html&gt;</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110212953513.png" class="" title="image-20221110212953513">

<p>可以看到meta写法不同，字符集是这样的一种写法。DOCTYPE写法也不同。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110213034151.png" class="" title="image-20221110213034151">



<img src="/2022/11/11/Front/html/HTML5/image-20221110213120741.png" class="" title="image-20221110213120741">

<p>可以看到，使用的是XHTML1.0的版本的。这个目前互联网上用的还是比较多的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110213209878.png" class="" title="image-20221110213209878">

<p>这个是html5中的文档类型和字符集的变化和以前版本的区别。</p>
<h5 id="查看手册及其新增标签"><a href="#查看手册及其新增标签" class="headerlink" title="查看手册及其新增标签"></a>查看手册及其新增标签</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110213353117.png" class="" title="image-20221110213353117">

<p>我们前面学习的那些标签，是兼容性比较好的标签，不管是用html4，还是xhtml，还是html5，那些标签都能够识别的。</p>
<p>现在这里学习的是html5中新增的标签，对于html4和xhtml是不认识这些标签的。只有html5认识这些标签的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110213431446.png" class="" title="image-20221110213431446">

<p>官方文档。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110213500375.png" class="" title="image-20221110213500375">

<img src="/2022/11/11/Front/html/HTML5/image-20221110213515726.png" class="" title="image-20221110213515726">

<p>直接看这里，html5中新增的标签即可。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110213540259.png" class="" title="image-20221110213540259">

<p>没有写5的是兼容以前的。</p>
<p>标记5的是html5中新加的标签。</p>
<h5 id="下面介绍常用html5新增的标签"><a href="#下面介绍常用html5新增的标签" class="headerlink" title="下面介绍常用html5新增的标签"></a><strong>下面介绍常用html5新增的标签</strong></h5><h5 id="header标签"><a href="#header标签" class="headerlink" title="header标签"></a><strong>header标签</strong></h5><img src="/2022/11/11/Front/html/HTML5/image-20221110213754465.png" class="" title="image-20221110213754465">

<img src="/2022/11/11/Front/html/HTML5/image-20221110213811789.png" class="" title="image-20221110213811789">

<p>就是页面中的头这里。</p>
<h5 id="nav标签"><a href="#nav标签" class="headerlink" title="nav标签"></a>nav标签</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110213851739.png" class="" title="image-20221110213851739">

<p>页面中的这个部分就是导航栏。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110213914330.png" class="" title="image-20221110213914330">



<h5 id="footer标签"><a href="#footer标签" class="headerlink" title="footer标签"></a>footer标签</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110214630101.png" class="" title="image-20221110214630101">

<p>这里是页面的底部。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110214644636.png" class="" title="image-20221110214644636">

<h5 id="article标签"><a href="#article标签" class="headerlink" title="article标签"></a>article标签</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110214736082.png" class="" title="image-20221110214736082">

<p>页面中间的这个文字说明的部分，就是文章内容部分。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110214800578.png" class="" title="image-20221110214800578">



<h5 id="section标签，定义文档中的节（区块，区段）"><a href="#section标签，定义文档中的节（区块，区段）" class="headerlink" title="section标签，定义文档中的节（区块，区段）"></a>section标签，定义文档中的节（区块，区段）</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110214833302.png" class="" title="image-20221110214833302">

<p>页面中的这个小块，就可以是section，没有严格的限制。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110214851765.png" class="" title="image-20221110214851765">

<p>section就理解为是一个盒子。</p>
<h5 id="aside标签，定义侧边块"><a href="#aside标签，定义侧边块" class="headerlink" title="aside标签，定义侧边块"></a>aside标签，定义侧边块</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110214927311.png" class="" title="image-20221110214927311">

<p>定义侧边。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110214953635.png" class="" title="image-20221110214953635">

<p>上面这些新增的标签，后面讲解css布局的时候，就会看出效果了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110215028743.png" class="" title="image-20221110215028743">

<img src="/2022/11/11/Front/html/HTML5/image-20221110215044019.png" class="" title="image-20221110215044019">

<p>后面会讲解让其兼容浏览器的写法。article。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110215107765.png" class="" title="image-20221110215107765">

<p>要求就是看到新标签，知道这个标签用来做什么的即可。</p>
<h5 id="datalist标签"><a href="#datalist标签" class="headerlink" title="datalist标签"></a>datalist标签</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110215210765.png" class="" title="image-20221110215210765">

<p>html5新增标签。</p>
<p>datalist很类似select标签，但是更加强大。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110215240392.png" class="" title="image-20221110215240392">

<p>输入小米，然后下面会拉出一个下拉框。datalist就能够模拟这个东西。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110215356339.png" class="" title="image-20221110215356339">

<img src="/2022/11/11/Front/html/HTML5/image-20221110215414550.png" class="" title="image-20221110215414550">

<p>datalist我们是看不到的。</p>
<p>我们需要将input和datalist连起来。这样用户输入内容的时候，就去datalist中来找。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110215438828.png" class="" title="image-20221110215438828">

<img src="/2022/11/11/Front/html/HTML5/image-20221110215530496.png" class="" title="image-20221110215530496">

<p>输入刘，可以看到下面列出了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110215601109.png" class="" title="image-20221110215601109">

<p>点击这里，都能够拉出来。</p>
<p>因此，比select更加强大，能够起到一个提示的功能。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110215635741.png" class="" title="image-20221110215635741">



<h5 id="fieldset标签"><a href="#fieldset标签" class="headerlink" title="fieldset标签"></a>fieldset标签</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110215734976.png" class="" title="image-20221110215734976">

<p>fieldset和legend搭配使用。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110215806628.png" class="" title="image-20221110215806628">

<img src="/2022/11/11/Front/html/HTML5/image-20221110215821488.png" class="" title="image-20221110215821488">

<img src="/2022/11/11/Front/html/HTML5/image-20221110220049758.png" class="" title="image-20221110220049758">

<img src="/2022/11/11/Front/html/HTML5/image-20221110220100186.png" class="" title="image-20221110220100186">

<img src="/2022/11/11/Front/html/HTML5/image-20221110220121759.png" class="" title="image-20221110220121759">

<img src="/2022/11/11/Front/html/HTML5/image-20221110220145091.png" class="" title="image-20221110220145091">

<img src="/2022/11/11/Front/html/HTML5/image-20221110220208133.png" class="" title="image-20221110220208133">



<h5 id="HTML5新增的input表单类型-一"><a href="#HTML5新增的input表单类型-一" class="headerlink" title="HTML5新增的input表单类型(一)"></a>HTML5新增的input表单类型(一)</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110220259271.png" class="" title="image-20221110220259271">

<p>这些是html5中新增的input type属性值。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110220356986.png" class="" title="image-20221110220356986">

<p>此时输入邮箱格式不对的，但是也没有任何的提示。原因是需要和提交按钮一起使用。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110220442336.png" class="" title="image-20221110220442336">

<p>此时可以正常提交了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110225526924.png" class="" title="image-20221110225526924">

<p>这个在移动端上效果更加明显，光标定位进去之后，会弹出数字键盘的。这个在pc端，效果不明显。</p>
<p>但是下一个type，number在pc端就很明显了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110225558118.png" class="" title="image-20221110225558118">

<p>这里只能输入数字，输入非数字的根本输入不进去。</p>
<p>右边的上下箭头，点击，可以使输入的数字向上增加或者向下减少。</p>
<p>这个如果在移动端，那么焦点定位之后，直接弹出一个数字键盘。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110225657941.png" class="" title="image-20221110225657941">

<img src="/2022/11/11/Front/html/HTML5/image-20221110225818696.png" class="" title="image-20221110225818696">

<p>可以看到后面多了一个×，如果输入错了，直接点击×即可。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110225844849.png" class="" title="image-20221110225844849">

<p>后面学习了js之后，可以配置js来控制音量大小，颜色的变化，等等。</p>
<h5 id="HTML5新增的input表单类型-二"><a href="#HTML5新增的input表单类型-二" class="headerlink" title="HTML5新增的input表单类型(二)"></a>HTML5新增的input表单类型(二)</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110230021051.png" class="" title="image-20221110230021051">

<p>可以点击上下箭头来调节。设定时间的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230055292.png" class="" title="image-20221110230055292">

<img src="/2022/11/11/Front/html/HTML5/image-20221110230108932.png" class="" title="image-20221110230108932">

<p>可以帮助我们进行选择。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230143777.png" class="" title="image-20221110230143777">

<img src="/2022/11/11/Front/html/HTML5/image-20221110230207281.png" class="" title="image-20221110230207281">

<img src="/2022/11/11/Front/html/HTML5/image-20221110230311838.png" class="" title="image-20221110230311838">

<img src="/2022/11/11/Front/html/HTML5/image-20221110230331974.png" class="" title="image-20221110230331974">

<img src="/2022/11/11/Front/html/HTML5/image-20221110230357801.png" class="" title="image-20221110230357801">

<img src="/2022/11/11/Front/html/HTML5/image-20221110230414281.png" class="" title="image-20221110230414281">

<p>上面讲解的这些都是html5中的input中的type属性新增的内容。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230451004.png" class="" title="image-20221110230451004">

<p>在后面讲解移动端开发的时候，会说明这个软件如何使用。</p>
<p>可以看到光标定位到手机输入框，会自动弹出数字键盘。</p>
<h5 id="新增占位符焦点多选属性"><a href="#新增占位符焦点多选属性" class="headerlink" title="新增占位符焦点多选属性"></a>新增占位符焦点多选属性</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110230534035.png" class="" title="image-20221110230534035">

<img src="/2022/11/11/Front/html/HTML5/image-20221110230554186.png" class="" title="image-20221110230554186">

<p>淘宝这里输入内容之后，里面内容自动消失。现在也要达到这个目的。</p>
<p>使用html5新增的属性，placeholder，占位符。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230634797.png" class="" title="image-20221110230634797">

<p>不用value属性了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230650990.png" class="" title="image-20221110230650990">

<p>此时输入内容，里面内容自动消失了。将输入的内容删除，又恢复原状。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230704244.png" class="" title="image-20221110230704244">



<img src="/2022/11/11/Front/html/HTML5/image-20221110230728581.png" class="" title="image-20221110230728581">

<p>页面加载之后，可以看到输入框自动获得了焦点。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230832253.png" class="" title="image-20221110230832253">

<p>可以看到，页面加载之后，输入框自动获得焦点了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230900945.png" class="" title="image-20221110230900945">

<p>也可以这样写。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230923113.png" class="" title="image-20221110230923113">

<p>之前上传文件的写法。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230938284.png" class="" title="image-20221110230938284">

<p>一次，这里只能上传一个文件的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110230958392.png" class="" title="image-20221110230958392">

<img src="/2022/11/11/Front/html/HTML5/image-20221110231010539.png" class="" title="image-20221110231010539">

<p>此时按住ctrl，可以多选文件了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231022596.png" class="" title="image-20221110231022596">

<h5 id="autocomplete属性"><a href="#autocomplete属性" class="headerlink" title="autocomplete属性"></a>autocomplete属性</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110231117113.png" class="" title="image-20221110231117113">

<p>例如，我们输入的名字很长，那么我们提交一次之后，是否能够自动记录下来，下次输入一个爱，自动就弹出来呢？</p>
<p>又例如，输入身份证很长，输入一次，下次会自动记录下来。</p>
<p>这个就可以通过autocomplete属性来完成。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231200010.png" class="" title="image-20221110231200010">

<img src="/2022/11/11/Front/html/HTML5/image-20221110231210991.png" class="" title="image-20221110231210991">

<p>此时还不会自动记录的。</p>
<p>因为没有提交，因此，需要配合提交按钮来使用的。提交之后，才会记录的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231238819.png" class="" title="image-20221110231238819">

<p>提交。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231256412.png" class="" title="image-20221110231256412">

<p>此时再输入，还没有提示。</p>
<p>因为，需要有名字name属性才行。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231346588.png" class="" title="image-20221110231346588">

<p>提交。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231401970.png" class="" title="image-20221110231401970">

<p>下次再输入，可以看到有提示了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231507041.png" class="" title="image-20221110231507041">

<p>2.表单控件必须指定name属性才行。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231601106.png" class="" title="image-20221110231601106">

<p>autocomplete有两个属性值，如果直接就写autocomplete的话，那么默认就是on的。</p>
<p>如果不想要其有记忆功能，为了安全，那么可以设为off。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231624037.png" class="" title="image-20221110231624037">

<img src="/2022/11/11/Front/html/HTML5/image-20221110231635012.png" class="" title="image-20221110231635012">

<p>此时就不会有提示了。</p>
<h5 id="内容不能为空和获得焦点属性"><a href="#内容不能为空和获得焦点属性" class="headerlink" title="内容不能为空和获得焦点属性"></a>内容不能为空和获得焦点属性</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110231933985.png" class="" title="image-20221110231933985">

<p>这个就是说，这个输入框不能为空，必须填内容的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110231955253.png" class="" title="image-20221110231955253">

<p>这里现在不输入内容为空，看不到效果。不同的浏览器有不同的解释方式。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110232018911.png" class="" title="image-20221110232018911">

<p>Firefox中，这里输入内容之后，将其删除，然后点击其他地方，可以看到，提示为红色了。告诉不能为空。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110232116965.png" class="" title="image-20221110232116965">

<p>alt+s，可以看到，光标自动进入了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110232129414.png" class="" title="image-20221110232129414">

<img src="/2022/11/11/Front/html/HTML5/image-20221110232149629.png" class="" title="image-20221110232149629">

<img src="/2022/11/11/Front/html/HTML5/image-20221110232208486.png" class="" title="image-20221110232208486">

<p>按alt+s，光标焦点得到了。</p>
<h5 id="表单综合案例-学生档案"><a href="#表单综合案例-学生档案" class="headerlink" title="表单综合案例-学生档案"></a>表单综合案例-学生档案</h5><img src="/2022/11/11/Front/html/HTML5/image-20221110233341122.png" class="" title="image-20221110233341122">

<img src="/2022/11/11/Front/html/HTML5/image-20221110233358894.png" class="" title="image-20221110233358894">

<img src="/2022/11/11/Front/html/HTML5/image-20221110233411901.png" class="" title="image-20221110233411901">

<img src="/2022/11/11/Front/html/HTML5/image-20221110233454501.png" class="" title="image-20221110233454501">

<img src="/2022/11/11/Front/html/HTML5/image-20221110233511931.png" class="" title="image-20221110233511931">

<img src="/2022/11/11/Front/html/HTML5/image-20221110233537989.png" class="" title="image-20221110233537989">

<img src="/2022/11/11/Front/html/HTML5/image-20221110233552103.png" class="" title="image-20221110233552103">

<img src="/2022/11/11/Front/html/HTML5/image-20221110233610249.png" class="" title="image-20221110233610249">

<img src="/2022/11/11/Front/html/HTML5/image-20221110233622976.png" class="" title="image-20221110233622976">



<h5 id="embed引入网上视频"><a href="#embed引入网上视频" class="headerlink" title="embed引入网上视频"></a>embed引入网上视频</h5><p><strong>多媒体标签</strong></p>
<p>embed：标签定义嵌入的内容</p>
<p>audio：播放音频</p>
<p>video：播放视频</p>
<p>网站上也是可以放置视频，音频的。</p>
<p>目前网站上放置视频，比较多的是embed这种方式。现在网络上用的几乎都是这种。</p>
<p>再往后发展的话，就会往后面两种进行过度了，也就是audio和video。因为embed这种方式需要进行兼容处理。</p>
<p>注意，在本地是不提倡放置视频的，因为网站的空间容量是有限的，而一个视频可能就上百兆了，因此，将网站最终要放到服务器上的，空间资源是很贵的。</p>
<p>因此，现在用的最多的方式是，可以将视频传到youku上去，然后我们的网站去调用youku上的视频的地址即可了。这样就既不会占用我们网站的空间，同时还能够显示视频，一举两得的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110234206335.png" class="" title="image-20221110234206335">

<p>我们复制这个html代码即可。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110234226871.png" class="" title="image-20221110234226871">

<p>然后贴到自己的页面中即可。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110234258503.png" class="" title="image-20221110234258503">

<p>点击允许。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221110234313861.png" class="" title="image-20221110234313861">



<p><strong>多媒体 embed（会使用）</strong></p>
<p>embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。</p>
<p>因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;http://player.youku.com/player.php/sid/XMTI4MzM2MDIwOA==/v.swf&quot;</span> <span class="attr">allowFullScreen</span>=<span class="string">&quot;true&quot;</span> <span class="attr">quality</span>=<span class="string">&quot;high&quot;</span> <span class="attr">width</span>=<span class="string">&quot;480&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span> <span class="attr">align</span>=<span class="string">&quot;middle&quot;</span> <span class="attr">allowScriptAccess</span>=<span class="string">&quot;always&quot;</span> <span class="attr">type</span>=<span class="string">&quot;application/x-shockwave-flash&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优酷，土豆，爱奇艺，腾讯、乐视等等</p>
<p>1、先上传 </p>
<p>2、在分享</p>
<h5 id="播放音频audio"><a href="#播放音频audio" class="headerlink" title="播放音频audio"></a>播放音频audio</h5><p><strong>多媒体 audio</strong></p>
<p>HTML5通过&lt;audio&gt;标签来解决音频播放的问题。</p>
<p>使用相当简单，如下图所示</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111095233847.png" class="" title="image-20221111095233847">

<p>并且可以通过附加属性可以更友好控制音频的播放，如：</p>
<p>autoplay 自动播放</p>
<p>controls 是否显示默认播放控件</p>
<p>loop 循环播放</p>
<p>由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100351494.png" class="" title="image-20221111100351494">

<p>多浏览器支持的方案，如下图</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100421717.png" class="" title="image-20221111100421717">

<img src="/2022/11/11/Front/html/HTML5/image-20221111100447811.png" class="" title="image-20221111100447811">

<p>此时浏览器打开是没有背景声音的。</p>
<p>此时需要audio的属性设置的，默认autoplay属性是不自动播放的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100519341.png" class="" title="image-20221111100519341">

<p>也可以直接就写一个autoplay即可。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100534720.png" class="" title="image-20221111100534720">

<p>此时页面加载之后，就有背景音乐了。但是此时没法控制这个音乐。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100618900.png" class="" title="image-20221111100618900">

<p>通过controls属性，控制音乐播放。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100650763.png" class="" title="image-20221111100650763">

<p>此时就可以控制播放和音量了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100705414.png" class="" title="image-20221111100705414">

<p>loop循环播放的意思，loop&#x3D;2，就是播放两次。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100718819.png" class="" title="image-20221111100718819">

<p>loop&#x3D;-1，就是无限循环播放。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100746187.png" class="" title="image-20221111100746187">

<p>由于不同浏览器支持的播放格式不同。因此，现在通常是将一首歌转换为3种格式的。然后将3种格式都放上来，这样任何一个浏览器都可以播放了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100807652.png" class="" title="image-20221111100807652">

<p>浏览器解析文件是从上往下解析的，因此，先看mp3这个是否支持，如果浏览器不支持，那么就往下看ogg的，如果ogg的也不支持，那么就显示浏览器不支持播放声音。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111100844471.png" class="" title="image-20221111100844471">



<h5 id="播放视频video"><a href="#播放视频video" class="headerlink" title="播放视频video"></a>播放视频video</h5><img src="/2022/11/11/Front/html/HTML5/image-20221111100913559.png" class="" title="image-20221111100913559">

<p>前面讲解embed的时候，针对比较大的视频，我们不推荐放到自己的网站上的。而针对现在发展的一些小视频，我们是可以放到自己的网站上的。</p>
<p>html5上支持如图的3种小视频格式。ogg，mpeg4，webm的。对于html5本身来说，目前只支持这3种小视频格式。当然浏览器得html5解析引擎得支持这3种格式才行。</p>
<p>仅限于这3种格式的，其它格式的视频，html5不支持。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111101026125.png" class="" title="image-20221111101026125">

<img src="/2022/11/11/Front/html/HTML5/image-20221111101059258.png" class="" title="image-20221111101059258">

<img src="/2022/11/11/Front/html/HTML5/image-20221111101110058.png" class="" title="image-20221111101110058">

<p>可以看到，不会自动播放的。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111101139471.png" class="" title="image-20221111101139471">

<img src="/2022/11/11/Front/html/HTML5/image-20221111101156775.png" class="" title="image-20221111101156775">

<p>此时页面加载就会自动播放了。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111101231349.png" class="" title="image-20221111101231349">

<p>增加控制。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111101301722.png" class="" title="image-20221111101301722">

<img src="/2022/11/11/Front/html/HTML5/image-20221111101312564.png" class="" title="image-20221111101312564">

<p>视频还是可以改宽度的。音频不行。</p>
<img src="/2022/11/11/Front/html/HTML5/image-20221111101335997.png" class="" title="image-20221111101335997">

<img src="/2022/11/11/Front/html/HTML5/image-20221111101353573.png" class="" title="image-20221111101353573">

<img src="/2022/11/11/Front/html/HTML5/image-20221111101402606.png" class="" title="image-20221111101402606">

<p>这里面的按钮这些，后续学习完js之后，都是可以控制的，可以换形状，搞的更加漂亮的。手动去控制它。</p>
<hr>
]]></content>
      <categories>
        <category>Front</category>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
</search>
