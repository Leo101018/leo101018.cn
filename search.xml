<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>针对硬盘大于2TB，centos7系统安装问题说明</title>
    <url>/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h1 id="针对硬盘大于2TB，centos7系统安装问题说明"><a href="#针对硬盘大于2TB，centos7系统安装问题说明" class="headerlink" title="针对硬盘大于2TB，centos7系统安装问题说明"></a><a href="https://www.cnblogs.com/Leo101018/p/13806461.html">针对硬盘大于2TB，centos7系统安装问题说明</a></h1><p>硬盘分区常见类型：</p>
<p>msdos（mbr分区）</p>
<p>gpt（gpt分区）</p>
<p>系统安装默认采用mbr分区。</p>
<p>MBR分区表(即主引导记录) 最大只支持2TB的分区，最多只支持4个主分区或3个主分区加一个扩展分区，信息只存储在一个区域；GPT（即GUID分区表），是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式，与MBR分区方式相比，突破4个主分区限制，每个磁盘最多支持128个分区，支持大于2T的分区，最大卷可达 18EB，信息存储在多个区域，当一部分受损后可修复。</p>
<p>设置GPT方式有UEFI和BIOS两种方式，UEFI启动是一种新的主板引导项，与传统的Bios方式相比可以提高开机后操作系统的启动速度。如今很多主板已经直接支持UEFI，这种场景下可以直接通过UEFI的方式设置GPT方式，如若主板不支持，那么还得通过传统的Bios方式强制设置GPT方式。</p>
<p>针对uefi启动，采用gpt分区，需要单独划分一个uefi分区</p>
<img src="/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/970770-20200929110620548-1970820754.png" class="" title="img">

<p>针对bios启动，mbr方式分区大于2TB硬盘会报错，如下</p>
<img src="/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/970770-20200929111340979-1715145746.png" class="" title="img">

<p> 此时bios启动安装时，输入inst.gpt强制采用gpt分区（实际这不不做也没关系）</p>
<img src="/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/970770-20200929111451537-931922777.png" class="" title="img">

<p>进入到分区页面</p>
<img src="/2022/10/04/CentOS/Install/%E9%92%88%E5%AF%B9%E7%A1%AC%E7%9B%98%E5%A4%A7%E4%BA%8E2TB%EF%BC%8Ccentos7%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AF%B4%E6%98%8E/970770-20200929111945993-147036960.png" class="" title="img">

<p>关键需要划分bios boot分区，其它分区正常划分即可。</p>
<p>投机方式：将所有分区删除，点击standard标准分区，点击自动划分分区，就会自动将bios boot分区划分好，之后将其它不用分区删除，按照自己规划进行划分即可。</p>
<p>注意，bios boot分区必须是标准分区，文件系统为bios boot，否则会报错。</p>
<p>后续正常安装即可。</p>
]]></content>
      <categories>
        <category>CentOS</category>
        <category>Install</category>
      </categories>
      <tags>
        <tag>centos-install</tag>
      </tags>
  </entry>
  <entry>
    <title>vim详解</title>
    <url>/2022/10/25/Linux/vim/vim/</url>
    <content><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>vim：Linux环境下编辑器。</p>
<p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p>
<p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。</p>
<p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p>
<p><strong>vim键盘图：</strong></p>
<img src="/2022/10/25/Linux/vim/vim/image-20221014131203980.png" class="" title="image-20221014131203980">



<h2 id="vim模式"><a href="#vim模式" class="headerlink" title="vim模式"></a>vim模式</h2><p><strong>vi&#x2F;vim 共分为三种模式，分别是</strong></p>
<p><strong>命令模式（Command mode）</strong></p>
<p><strong>插入模式（输入模式）（Insert mode）</strong></p>
<p><strong>底线命令模式（末行模式）（Last line mode）</strong></p>
<h3 id="命令模式（正常模式、普通模式）（normal-mode）"><a href="#命令模式（正常模式、普通模式）（normal-mode）" class="headerlink" title="命令模式（正常模式、普通模式）（normal mode）"></a>命令模式（正常模式、普通模式）（normal mode）</h3><p>刚启动 vi&#x2F;vim，便进入了命令模式。</p>
<p>此模式下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p>
<p>常用的几个命令：</p>
<ul>
<li><strong>i 切换到插入模式，以输入字符。</strong></li>
<li><strong>x 删除当前光标所在处的字符。</strong></li>
<li><strong>: 切换到末行命令模式，以在最底一行输入命令。</strong></li>
</ul>
<p>命令模式只有一些最基本的命令，因此仍要依靠末行命令模式输入更多命令。</p>
<h3 id="输入模式（insert-mode）"><a href="#输入模式（insert-mode）" class="headerlink" title="输入模式（insert mode）"></a>输入模式（insert mode）</h3><p>命令模式下按下i就进入了输入模式</p>
<p>使用esc退出输入模式，回到命令模式。</p>
<h3 id="末行模式（last-line-mode）"><a href="#末行模式（last-line-mode）" class="headerlink" title="末行模式（last line mode）"></a>末行模式（last line mode）</h3><p>在命令模式下按下:（英文冒号）就进入了末行命令模式。</p>
<p>末行命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p>
<p>在末行命令模式中，基本的命令有（已经省略了冒号）：</p>
<ul>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ul>
<p>按ESC键可随时退出末行命令模式。</p>
<h3 id="3种模式图解"><a href="#3种模式图解" class="headerlink" title="3种模式图解"></a>3种模式图解</h3><img src="/2022/10/25/Linux/vim/vim/image-20221014131933608.png" class="" title="image-20221014131933608">



<h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。</p>
<h3 id="替换模式"><a href="#替换模式" class="headerlink" title="替换模式"></a>替换模式</h3><p>正常模式下，按R进入。</p>
<h2 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><p>h：光标向左移动一个字符，←</p>
<p>j：光标向下移动一个字符，↓</p>
<p>k：光标向上移动一个字符，↑</p>
<p>l：光标向右移动一个字符，→</p>
<p>例：</p>
<p>向下移动30行，30j</p>
<p>Ctrl+f：屏幕『向下』移动一页</p>
<p>Ctrl+b：屏幕『向上』移动一页</p>
<p>Ctrl+d：屏幕『向下』移动半页</p>
<p>Ctrl+u：屏幕『向上』移动半页</p>
<p>+：光标移动到非空格符的下一行</p>
<p>-：光标移动到非空格符的上一行</p>
<p>n+空格：那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</p>
<p>0：光标移动到这一行最前面。</p>
<p>g0：移到光标所在屏幕行行首。</p>
<p>^：移动到本行第一个非空白字符。</p>
<p>g^：同 ^ ，但是移动到当前屏幕行第一个非空字符处。</p>
<p>$：光标移动到这一行最后面。</p>
<p>g$：移动光标所在屏幕行行尾。</p>
<p>n|：把光标移到第n列上。</p>
<p>H：光标移动到<strong>这个屏幕</strong>的最上方那一行的第一个字符</p>
<p>M：光标移动到<strong>这个屏幕</strong>的中央那一行的第一个字符</p>
<p>L：光标移动到<strong>这个屏幕</strong>的最下方那一行的第一个字符</p>
<p>G：光标移动到这个文件的最后一行(常用)</p>
<p>nG：n 为数字。移动到这个文件的第 n 行。</p>
<p>gg：移动到这个文件的第一行，相当于 1G 啊！ (常用)。</p>
<p>n+回车：n 为数字。光标从当前行向下移动 n 行(常用)。</p>
<p>w：前移一个单词，光标停在下一个单词开头</p>
<p>W：移动下一个单词开头，但忽略一些标点</p>
<p>e：前移一个单词，光标停在下一个单词末尾</p>
<p>E：移动到下一个单词末尾，如果词尾有标点，则移动到标点</p>
<p>b：后移一个单词，光标停在上一个单词开头</p>
<p>B：移动到上一个单词开头，忽略一些标点</p>
<h4 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h4><p>[n]x：剪切光标右边n个字符，相当于d[n]l。</p>
<p>[n]X：剪切光标左边n个字符，相当于d[n]h。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>yy or Y：复制整行文本。</p>
<p>y[n]w：复制一(n)个词。</p>
<p>y[n]l：复制光标右边1(n)个字符。</p>
<p>y[n]h：复制光标左边1(n)个字符。</p>
<p>y$：从光标当前位置复制到行尾。</p>
<p>y0：从光标当前位置复制到行首。</p>
<p>:m,ny+回车：复制m行到n行的内容。</p>
<p>y1G或ygg：复制光标以上的所有行。</p>
<p>yG：复制光标以下的所有行。</p>
<p>y：复制在可视模式下选中的文本。</p>
<h4 id="删除（剪切）"><a href="#删除（剪切）" class="headerlink" title="删除（剪切）"></a>删除（剪切）</h4><p>[n] dd：删除（剪切）1(n)行。</p>
<p>d[n]l：删除（剪切）光标右边1(n)个字符。</p>
<p>d[n]h：删除（剪切）光标左边1(n)个字符。</p>
<p>d[n]w：删除（剪切）1(n)个单词</p>
<p>d$ or D：删除（剪切）当前位置到行尾的内容。</p>
<p>d0：删除（剪切）当前位置到行首的内容</p>
<p>:m,nd+回车：剪切m行到n行的内容。</p>
<p>d1G或dgg：剪切光标以上的所有行。</p>
<p>dG：剪切光标以下的所有行。</p>
<p>d&#x2F;f+回车：这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。</p>
<p>d：删除（剪切）在可视模式下选中的文本。</p>
<h4 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h4><p>p：在光标之后粘贴。</p>
<p>P：在光标之前粘贴。</p>
<h3 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h3><h4 id="搜索（查找）和替换"><a href="#搜索（查找）和替换" class="headerlink" title="搜索（查找）和替换"></a>搜索（查找）和替换</h4><h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><p>&#x2F;word：向下寻找word字符串</p>
<p>?word：向上寻找word字符串</p>
<p>n：重复前一个搜索动作。例如：我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串</p>
<p>N：与n相反，反向搜索</p>
<p>&#x2F;pattern&#x2F;+number：将光标停在包含pattern的行后面第number行上。</p>
<p>&#x2F;pattern&#x2F;-number:：将光标停在包含pattern的行前面第number行上。</p>
<h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p>:s&#x2F;old&#x2F;new：用new替换当前行第一个old。</p>
<p>:s&#x2F;old&#x2F;new&#x2F;g：用new替换当前行所有的old。</p>
<p>:%s&#x2F;old&#x2F;new&#x2F;g：用new替换文件中所有的old。</p>
<p>:%s&#x2F;^&#x2F;xxx&#x2F;g：在每一行的行首插入xxx。^表示行首。</p>
<p>:%s&#x2F;$&#x2F;xxx&#x2F;g：在每一行的行尾插入xxx。$表示行尾。</p>
<p>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用)</p>
<p>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</p>
<p>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</p>
<p>注意，g表示global，全部替换。</p>
<p>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s&#x2F;old&#x2F;new&#x2F;gci，加上i则忽略大小写(ignore)。</p>
<p>还有一种比较灵活的替换方式：它是匹配到某个模式后执行某种命令</p>
<p>语法为 ：[range]g&#x2F;pattern&#x2F;command</p>
<p>例如 ：%g&#x2F;^ xyz&#x2F;normal dd。</p>
<p>表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。</p>
<p>关于range的规定为：</p>
<p>如果不指定range，则表示当前行。</p>
<p>m,n: 从m行到n行。</p>
<p>0: 最开始一行（可能是这样）。</p>
<p>$: 最后一行</p>
<p>.: 当前行</p>
<p>%: 所有行</p>
<h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><h4 id="基本插入"><a href="#基本插入" class="headerlink" title="基本插入"></a>基本插入</h4><p>i：在光标前插入。</p>
<p>一个小技巧：按8，再按i，进入插入模式，输入&#x3D;， 按esc进入命令模式，就会出现8个&#x3D;，即8i&#x3D;然后esc。 这在插入分割线时非常有用，如30i&#x3D;然后esc就插入了36个&#x3D;组成的分割线。</p>
<p>I：在当前行第一个非空字符前插入</p>
<p>gI：在当前行第一列插入</p>
<p>a：在光标后插入</p>
<p>A：在当前行最后插入</p>
<p>o：在下面新建一行插入</p>
<p>O：在上面新建一行插入</p>
<p>:r filename：在当前位置插入另一个文件的内容</p>
<p>:[n]r filename：在第n行插入另一个文件的内容。</p>
<p>:r !date：在光标处插入当前日期与时间。同理，:r !command 可以将其它shell命令的输出插入当前文档。</p>
<h4 id="改写插入"><a href="#改写插入" class="headerlink" title="改写插入"></a>改写插入</h4><p>c[n]w：改写光标后1(n)个词。</p>
<p>c[n]l：改写光标后n个字母。注意，l可以省。</p>
<p>c[n]h：改写光标前n个字母。</p>
<p>[n]cc：修改当前[n]行。</p>
<p>[n]s：以输入的文本替代光标之后1(n)个字符，相当于c[n]l。</p>
<p>[n]S：删除指定数目的行，并以所输入文本代替之。</p>
<h2 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h2><p>aw：一个词<br>as：一句。<br>ap：一段。<br>ab：一块（包含在圆括号中的）。<br>y, d, c, v都可以跟文本对象。</p>
<h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><p>:set spell：开启拼写检查功能</p>
<p>:set nospell：关闭拼写检查功能</p>
<p>:set hlsearch：搜索高亮</p>
<p>:set nohlsearch：取消搜索高亮</p>
<h2 id="快速编辑"><a href="#快速编辑" class="headerlink" title="快速编辑"></a>快速编辑</h2><p>~：反转光标所在字符的大小写。</p>
<p>可视模式下的U或u：把选中的文本变为大写或小写。</p>
<p>gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如：guG，就是把当前行到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</p>
<p>[n] u：取消一(n)个改动。</p>
<p>:undo 5 ： 撤销5个改变。</p>
<p>:undolist：你的撤销历史。</p>
<p>ctrl + r：重做最后的改动。</p>
<p>U：取消当前行中所有的改动。</p>
<p>. ：重复上一个编辑动作</p>
<p><strong>宏：</strong></p>
<p>. ：重复上一个编辑动作<br>qa：开始录制宏a（键盘操作记录）<br>q：停止录制<br>@a：播放宏a</p>
<h2 id="文件加密"><a href="#文件加密" class="headerlink" title="文件加密"></a>文件加密</h2><p>vim -x file：开始编辑一个加密的文件。</p>
<p>:X：为当前文件设置密码。</p>
<p>:set key&#x3D; ：去除文件的密码。</p>
<h2 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h2><p>:e ++enc&#x3D;utf8 filename：让vim用utf-8的编码打开这个文件。<br>:w ++enc&#x3D;gbk：不管当前文件什么编码，把它转存成gbk编码。<br>:set fenc或:set fileencoding：查看当前文件的编码。<br>在vimrc中添加set fileencoding&#x3D;ucs-bom,utf-8,cp936：vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。<br>让vim 正确处理文件格式和文件编码，有赖于 ~&#x2F;.vimrc的正确配置</p>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p>大致有三种文件格式：unix, dos, mac，三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有换行符，mac 下只有回车符。</p>
<p>:e ++ff&#x3D;dos filename：让vim用dos格式打开这个文件。<br>:w ++ff&#x3D;mac filename：以mac格式存储这个文件。<br>:set ff：显示当前文件的格式。<br>在vimrc中添加set fileformats&#x3D;unix,dos,mac，让vim自动识别文件格式。</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>:set nu：显示行号</p>
<p>:set nonu：取消行号</p>
<p>ZZ：保存并退出</p>
<p>:x：保存并退出</p>
<p>:saveas newfilename：另存为</p>
<hr>
<h2 id="vim键位图"><a href="#vim键位图" class="headerlink" title="vim键位图"></a>vim键位图</h2><img src="/2022/10/25/Linux/vim/vim/image-20221025095209012.png" class="" title="image-20221025095209012">



<img src="/2022/10/25/Linux/vim/vim/image-20221025095304209.png" class="" title="image-20221025095304209">

<p>“f”命令移动到光标右边的指定字符上，例如，”fx”，会把移动到光标右边的第一个’x’字符上。</p>
<p>“F”命令则反方向查找，也就是移动到光标左边的指定字符上。</p>
<p>“t”命令和”f”命令的区别在于，它移动到光标右边的指定字符之前。例如，”tx”会移动到光标右边第一个’x’字符的前面。</p>
<p>“T”命令是”t”命令的反向版本，它移动到光标左边的指定字符之后。</p>
<p>这四个命令只在当前行中移动光标，光标不会跨越回车换行符。</p>
<p>可以在命令前面使用数字，表示倍数。例如，”3fx”表示移动到光标右边的第3个’x’字符上。</p>
<p>“;”命令重复前一次输入的f, t, F, T命令，而”,”命令会反方向重复前一次输入的f, t, F, T命令。这两个命令前也可以使用数字来表示倍数。</p>
<p>d命令可以和w，f，j，k等连用。</p>
<p>2i，进入插入模式，然后输入内容，然后esc，输入内容会重复出现2次。</p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025102154433.png" class="" title="image-20221025102154433">

<p><strong>“寄存器</strong></p>
<p>Vim 提供了许多寄存器。我们可以使用这些寄存器作为多个剪贴板。这个特性在处理多个文件时非常有用。</p>
<p><strong>拷贝内容到指定寄存器：</strong></p>
<p>“&lt;register-name&gt;&lt;command&gt;</p>
<p>例如，要复制当前行文本到寄存器”a”中，请使用以下命令</p>
<p>“ayy</p>
<p><strong>从寄存器中粘贴文本：</strong></p>
<p>“&lt;register-name&gt;p</p>
<p>例如，下面的命令从寄存器”a”粘贴文本</p>
<p>“ap</p>
<p><strong>列出可用寄存器：</strong></p>
<p>:registers</p>
<p><strong>匿名寄存器（未命名寄存器）：</strong>未命名寄存器用””表示。 Vim 将已删除或复制的文本存储在这个寄存器中。</p>
<p><strong>命名寄存器（有名字寄存器）：</strong>我们可以使用26个指定的寄存器; 我们可以使用 a-z 或 A-Z。默认情况下vim不使用这些寄存器。如果我们使用小写寄存器名称，那么内容将被覆盖，如果我们使用大写名称，那么内容将被追加到该寄存器中。</p>
<p><strong>数字寄存器：</strong>我们可以使用0到9个命名寄存器。Vim fills these registers with text from yank and delete command.</p>
<p>编号寄存器0包含来自最近的 yank 命令的文本</p>
<p>编号寄存器1包含由最近的 delete 或 change 命令删除的文本</p>
<p><strong>默认寄存器：</strong></p>
<p>%：Name of the current file</p>
<p>当前文件的名称</p>
<p>#：Name of the alternate file for the current window</p>
<p>当前窗口的备用文件的名称</p>
<p>:     Most recently executed command</p>
<p>最近执行的命令</p>
<p>.：Contains the last inserted text</p>
<p>包含最后插入的文本</p>
<p>“：Last used register</p>
<p>最后使用的寄存器</p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025104853100.png" class="" title="image-20221025104853100">

<p><strong>:set incsearch   #很聪明的查找,输入一个字符马上自动匹配,而不是输入完再查找</strong></p>
<p>*<strong>：搜索当前单词的下一个出现</strong></p>
<p><strong>#：查找当前单词的以前出现</strong></p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025121437413.png" class="" title="image-20221025121437413">





<img src="/2022/10/25/Linux/vim/vim/image-20221025121504058.png" class="" title="image-20221025121504058">

<p><strong>marks标记：</strong></p>
<p>在编辑的时候，你忽然想起来需要修改同一个文档的另一个地方，但又想记住当前的位置，以便稍后再回来编辑。vim中我们可以对文本进行标记，方便vim编辑器在文档的不同位置间跳转。</p>
<p><strong>添加标记：</strong></p>
<p>ma：m 是标记命令，a 是所做标记的名称</p>
<p>可以使用小写字母 a-z 或大写字母 A-Z 中的任意一个做为标记名称，意味着一个文件里最多可以有52个命名标记。小写字母的标记，仅用于当前缓冲区；而大写字母的标记，则可以跨越不同的缓冲区。例如，你正在编辑 File1，但仍然可以使 用’A 命令，移动到 File2 中创建的标记A。</p>
<p><strong>跳转标记：</strong></p>
<p>‘a：a是标记名。跳转到指定标记行的首个非空字符</p>
<p>&#96;a：a是标记名。跳转到所做标记时的光标位置</p>
<p><strong>列出标记：</strong></p>
<p>:marks命令，可以列出所有标记</p>
<p>其中也包括一些系统内置的特殊标记（Special marks）：</p>
<p>.             最近编辑的位置</p>
<p>0-9        最近使用的文件</p>
<p>∧           最近插入的位置</p>
<p>‘            上一次跳转前的位置</p>
<p>“           上一次退出文件时的位置</p>
<p>[           上一次修改的开始处</p>
<p>]           上一次修改的结尾处</p>
<p><strong>删除标记：</strong></p>
<p>如果删除了做过标记的文本行，那么所做的标记也就不存了</p>
<p>不仅可以利用标记来快速移动，而且还可以使用标记来删除文本。例如在某一行用ma做了标记，然后就可以使用d’a来删掉这一行。也可以使用y’a命令就可以来复制这一行了。</p>
<p>:delmarks a b c命令，可以删除某个或多个标记。</p>
<p>:delmarks! 命令，则会删除所有标记。</p>
<p><strong>Macros宏：</strong></p>
<p>Vim 的 Macro 就是用来解决重复的问题。 macro 的操作都是以文本的方式存放在寄存器中。</p>
<p>宏是一组命令的集合，应用极其广泛。VIM同样支持宏操作。</p>
<p>q* 开始录制宏</p>
<p>q 停止录制宏</p>
<p>@* 执行宏</p>
<p>@@ 重复执行上次的@*命令一次</p>
<p>以上命令均是在VIM的一般模式(Normal)下使用的，其中*代表一个数字或单个字符。[0-9a-zA-Z]</p>
<p>:help recording 查看宏帮助</p>
<p><strong>录制宏：</strong></p>
<p>q[a-z]：使用 q + [a-z] 26个字母中的一个。</p>
<p>之后的命令都会被记录</p>
<p><strong>结束录制宏：</strong></p>
<p>按一下q结束录制。</p>
<p><strong>执行宏（播放宏）：</strong></p>
<p>10@a：执行 macro 的时候，在寄存器前加 @ ，比如记录在寄存器 a 中，执行 10 遍a寄存器中记录的命令。</p>
<p>@@：再执行一遍上一次的命令。</p>
<p><strong>查看宏：</strong></p>
<p>:reg a</p>
<p>macro 内容保存在寄存器 a 中，直接使用 :reg a 来查看内容即可。</p>
<p><strong>编辑宏：</strong></p>
<p>假设已经有一个 macro 保存在了 a 中，可以使用</p>
<p>:let @a&#x3D;’</p>
<p>输入Ctrl + r + a 来插入 a 中内容，然后追加其它内容</p>
<p>编辑内容然后以 ‘ 结束 Enter 退出</p>
<p><strong>案例：</strong></p>
<p>经典注释和尾部追加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span></span><br><span class="line"><span class="type">int</span> c = a+b</span><br><span class="line">print a</span><br><span class="line">print b</span><br><span class="line">print c</span><br></pre></td></tr></table></figure>

<p>注释，或者在每一行的末尾添加特定字符，比如在每行末加上分号; ，对于这个操作 Vim 中有太多的方式可以完成，比如说替换 :%s&#x2F;$&#x2F;;&#x2F;g </p>
<p>比如说 . 命令。</p>
<p>也可以使用宏。</p>
<p>如果是用 . 来实现的话，首先在第一行执行A;，然后重复5次执行j.，对于这种简单文件来说很容易使用，但是如果这个文件有 1000 行，那么显然 . 命令是不可行的。使用 macro , 可以先录制一遍，然后在 1000 行上执行便可。</p>
<p>比如可以在normal模式下使用 </p>
<p><strong>qa 然后A; 然后Esc 然后j 然后q</strong></p>
<p>说明：</p>
<p>qa 开启录制，存入 a 寄存器</p>
<p>A 在行尾进入插入模式</p>
<p>; 插入分号</p>
<p>esc退出插入模式</p>
<p>j 下一行</p>
<p>q 退出录制</p>
<p><strong>此时 a 寄存器中就保存了当前行的操作，在当前行尾部添加 ; 并将光标移动到下一行。</strong></p>
<p>播放宏：</p>
<p>1000@a   执行1000遍 macro ，就能将下面1000行尾部添加 ;</p>
<p><strong>案例：</strong></p>
<p>递增数字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">...</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<p>使用 macro 实现插入 1 到 100 个数字，每一行自增一</p>
<p>首先在第一行插入1，然后光标定位了”1”处，进入normal模式</p>
<p>输入命令：qayyp&lt;Ctrl&gt;aq</p>
<p>yyp     拷贝一行再粘贴在新的一行</p>
<p>&lt;Ctrl&gt;a    数字+1</p>
<p>q     结束录制</p>
<p>播放宏：98@a</p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025130708412.png" class="" title="image-20221025130708412">

<p>K，光标放到某个单词上，按K，会看到对应单词的man帮助，例如，定位到systemed，然后按K，就会查看systemed的man帮助。前提是有对应单词的man手册才行。</p>
<img src="/2022/10/25/Linux/vim/vim/image-20221025131517427.png" class="" title="image-20221025131517427">



<img src="/2022/10/25/Linux/vim/vim/image-20221025132334412.png" class="" title="image-20221025132334412">

<hr>
<img src="/2022/10/25/Linux/vim/vim/image-20221025132641477.png" class="" title="image-20221025132641477">



<img src="/2022/10/25/Linux/vim/vim/image-20221025132714438.png" class="" title="image-20221025132714438">

<img src="/2022/10/25/Linux/vim/vim/image-20221025132744618.png" class="" title="image-20221025132744618">



<img src="/2022/10/25/Linux/vim/vim/image-20221025132806470.png" class="" title="image-20221025132806470">

<hr>
]]></content>
      <categories>
        <category>Linux</category>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行</title>
    <url>/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行"><a href="#01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行" class="headerlink" title="01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行"></a>01-JavaSE入门、JDK的下载与安装、第一个Java程序、Java程序的编译与执行</h1><h2 id="Java的发展历史"><a href="#Java的发展历史" class="headerlink" title="Java的发展历史"></a>Java的发展历史</h2><p>Java是一种面向对象的程序设计语言，由Sun Microsystems公司的James Gosling等人于20世纪90年代初开发。它最初被命名为Oak，用来开发消费类电子产品，解决诸如电话、电视机等家用电器的控制和通讯问题。后来随着互联网的发展，Sun看到了Oak在计算机网络上的广阔应用前景，于是改造了Oak，在1995年5月正式命名为”Java”，变化历程如下图1.1和1.2所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image001.png" class="">



<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image002.png" class="" title="img">

<h2 id="Java语言的版本"><a href="#Java语言的版本" class="headerlink" title="Java语言的版本"></a>Java语言的版本</h2><p><strong>JavaSE</strong></p>
<p>　　 Java SE（Java Platform，Standard Edition）。Java SE 以前称为J2SE。它允许开发和部署在<a href="http://baike.baidu.com/view/79807.htm">桌面</a>、<a href="http://baike.baidu.com/view/899.htm">服务器</a>、嵌入式环境和实时环境中使用的Java <a href="http://baike.baidu.com/view/330120.htm">应用程序</a>。Java SE 包含了支持Java Web 服务开发的类，并为Java Platform，Enterprise Edition（Java EE）提供基础。<br>    例子：类似QQ、扫雷、飞秋、凌波这样子的桌面应用。</p>
<p><strong>Java EE</strong></p>
<p>　　 Java EE（Java Platform，Enterprise Edition）。这个版本以前称为J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在Java SE 的基础上构建的，它提供Web 服务、<a href="http://baike.baidu.com/view/3852154.htm">组件模型</a>、管理和通信API，可以用来实现企业级的面向服务<a href="http://baike.baidu.com/view/1188494.htm">体系结构</a>（service-oriented architecture，SOA）和Web 2.0 应用程序。 </p>
<p><strong>Java ME</strong></p>
<p>　　 Java ME（Java Platform，Micro Edition）。这个版本以前称为J2ME，也叫<a href="http://baike.baidu.com/view/412221.htm">K-JAVA</a>。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视<a href="http://baike.baidu.com/view/16791.htm">机顶盒</a>和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以<a href="http://baike.baidu.com/view/31294.htm">动态</a>下载的连网和离线应用程序的丰富支持。基于Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</p>
<h2 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h2><p><strong>1.跨平台</strong></p>
<p>何谓平台：即一套特定的硬件再加上运行其上的操作系统，即硬件＋软件。</p>
<p>Java编译器将Java源程序编译成一种与体系结构无关的中间文件格式，称为字节码。只要有Java运行系统的机器都能执行这种中间代码。从而使同一版本的应用程序可以运行在不同的平台上。</p>
<p>怎样理解平台无关性呢？JVM (java Virtual Machine)起到了主要作用。JVM是运行在平台之上的程序，它能够虚拟出一台目标机，所有字节码就是在虚拟出的目标机上运行。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image004.jpg" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image002-1664876304333-1.png" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/image-20221004173848525.png" class="" title="image-20221004173848525">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/image-20221004173904530.png" class="" title="image-20221004173904530">

<p>110是Windows上的指令。</p>
<p>101是linux上的指令。</p>
<p><strong>Java跨平台</strong></p>
<p>“write once run anywhere”</p>
<p>Java的跨平台是相对于其他编程语言而言的，通过Java语言编写的应用程序在不同的系统平台上都可以运行。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。在windows编译的c语言程序，在linux下是不能运行的，想要在linux下运行，那么就需要将c语言程序源码在linux平台上重新编译成linux平台的目标代码才行。当然在linux下编译的c语言程序在windows下也是不能运行的。<strong>而Java语言在不同平台上运行时不需要重新编译。</strong></p>
<p>Java跨平台的原理：Java的跨平台是通过Java虚拟机（JVM）来实现的。</p>
<p><strong>2.半编译半解释</strong></p>
<p>源程序先编译成字节码，Java解释器(运行系统)能直接对Java字节码进行解释执行。链接程序通常比编译程序所需资源少，Java的编译和解释执行过程如下图1.4所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image005.png" class="" title="img">

<p><strong>3.简单</strong></p>
<p>Java是个精简的系统，无需强大的硬件环境便可以很好地运行。Java的风格和语法类似于C++，因此，C++程序员可以很快就掌握Java编程技术。Java摒弃了C++中容易引发程序错误的地方，如多重继承、运算符重载、指针和内存管理等，Java语言具有支持多线程、自动垃圾收集和采用引用等特性。Java提供了丰富的类库，方便用户迅速掌握Java。</p>
<p><strong>4.面向对象</strong></p>
<p>对象可以是人们研究的任何实体，小到一个原子大到整个宇宙，均可看作对象，它不仅能表示具体的事物，还能表示抽象的规则、概念等。对象之间通过消息相互作用，用公式表示，面向对象编程语言可以表示为：程序&#x3D;对象+消息。现实世界中的对象均有属性和行为，映射到计算机程序上，属性就表示对象的数据（用来表示对象的状态），行为就表示对象的方法（用来处理数据或同外界交互）。</p>
<p>所有面向对象编程语言都支持三个概念：封装、继承和多态，Java也不例外。</p>
<p>面向对象可以说是Java最基本的特性。Java语言的设计完全是面向对象的，它不支持类似C语言那样的面向过程的程序设计技术。所有的Java程序和applet均是对象，Java支持静态和动态风格的代码继承及重用。</p>
<p><strong>5.分布式</strong></p>
<p>Java包括一个支持HTTP和FTP等基于TCP&#x2F;IP协议的子库。因此，Java应用程序可凭借URL打开并访问网络上的对象，就像访问本地文件一样简单方便。Java的分布性为实现在分布环境尤其是Internet下实现动态内容提供了技术途径。</p>
<p><strong>6.健壮</strong></p>
<p>Java提供了自动垃圾收集机制来进行内存管理，并检测程序对内存的访问，确定合法并不会引起任何问题后，才允许访问。</p>
<p>Java还提供了异常处理机制用来检查编译及运行时可能出现的问题，Java在编译和运行程序时要对可能出现的异常进行检查；同时，Java在编译时还可捕获类型声明中的许多常见错误，帮助程序员消除错误，防止系统崩溃。</p>
<p><strong>7、安全</strong></p>
<p>作为网络语言，安全是非常重要的。Java的安全性可从两个方面得到保证。一方面，在Java语言里，像指针和释放内存等C++功能被删除，避免了非法内存操作。另一方面，当Java用来创建浏览器时，语言功能和一类浏览器本身提供的功能结合起来，使它更安全。Java语言在你的机器上执行前，要经过很多次的测试。它经过代码校验，检查代码段的格式，检测指针操作，试图改变一个对象的类型。另外，Java拥有多个层次的互锁保护措施，能有效地防止病毒的入侵和破坏行为的发生。Java不支持指针，避免了由于指针操作所引起的错误和非法入侵。同时，Java在运行应用程序时，严格检查其访问数据的权限，保证数据的可靠性。</p>
<p><strong>8.多线程</strong></p>
<p>线程有时也称小进程，是一个大进程里分出来的小的独立运行的基本单位。Java提供的多线程功能使得在一个程序里可同时执行多个小任务，即同时进行不同的操作或处理不同的事件。多线程带来的更大的好处是具有更好的网上交互性能和实时控制性能，尤其是实现多媒体功能。</p>
<h2 id="Java开发环境的搭建"><a href="#Java开发环境的搭建" class="headerlink" title="Java开发环境的搭建"></a>Java开发环境的搭建</h2><p>Java运行环境就是JRE (Java Runtime Environment），是由Sun所研发的，是一个软件, JRE可以让计算机系统执行Java应用程序，它是运行JAVA程序所必须的环境的集合，JRE的内部有一个JAVA虚拟机（Java Virtual Machine，JVM）以及一些标准的类库（Class Library），如果你只需要运行Java程序,下载并安装它即可。</p>
<p>如果你要自行开发 Java软件，请下载JDK。在JDK中附带有JRE。最新版本下载地址<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html%E3%80%82">http://www.oracle.com/technetwork/java/javase/downloads/index.html。</a></p>
<p>java的环境的搭建：</p>
<p>​    </p>
<p>​    <strong>jre: java运行环境。 jre &#x3D; java虚拟机 + 核心类库(辅助java虚拟机运行的文件)</strong></p>
<p>​    </p>
<p>​    <strong>jdk： java开发工具集  jdk &#x3D; jre + java开发工具。</strong></p>
<p>java开发工具，例如，javac编译工具，java解释器执行工具。</p>
<p>如果只是软件使用者，那么安装jre即可，提供运行环境。</p>
<p>如果是软件开发者，那么就需要安装jdk。因为需要开发工具。</p>
<p>JRE Java Runtime Environment Java运行环境。包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<p>JDK 是整个Java的核心，包括了Java运行环境、Java工具和Java基础类库。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/image-20221004174307304.png" class="" title="image-20221004174307304">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/image-20221004174351709.png" class="" title="image-20221004174351709">



<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image006.png" class="" title="img">

<h2 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h2><img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image007.png" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image008.png" class="" title="img">

<h2 id="Java程序运行的原理"><a href="#Java程序运行的原理" class="headerlink" title="Java程序运行的原理"></a>Java程序运行的原理</h2><p>Java程序运行在Java虚拟机上，Java虚拟机就是指JVM (Java Virtual Machine) ，这是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬件架构,如处理器、堆栈、寄存器等,还具有相应的指令系统，编辑、编译及运行Java程序的过程如图1.13所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image009.png" class="" title="img">

<p><strong>图1.13编辑、编译及运行Java程序的过程</strong></p>
<p>一个运行时的Java虚拟机实例的天职就是：负责运行一个Java程序。Java虚拟机的主要任务是装载class文件并且解释执行其中的字节码。当启动一个Java程序时，一个虚拟机实例也就诞生了。当该程序关闭退出，这个虚拟机实例也就随之消亡。如果同一台计算机上同时运行三个Java程序，将得到三个Java虚拟机实例。每个Java程序都运行于它自己的Java虚拟机实例中，如下图1.14所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image010.png" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image011.png" class="" title="img">

<p><strong>图 运行时过程</strong></p>
<p>编译源文件：java源代码被java编译器编译（Compile)。如果这时产生错误，我们称为编译错误。如果没有错误，则生成字节码（byte code）。</p>
<p>运行字节码：这里，java字节码被装载到java虚拟机中，解释成本地代码再运行。如果此时产生错误，我们称之为运行时错误（Runtime）。</p>
<h2 id="注释的使用"><a href="#注释的使用" class="headerlink" title="注释的使用"></a>注释的使用</h2><p>Java 的注释是被Javac忽略的部分，Java中的注释包含下面三种。</p>
<p>1．单行注释</p>
<p>&#x2F;&#x2F; 单行注释</p>
<p>2．多行注释</p>
<p>&#x2F;* 多行注释 *&#x2F;</p>
<p>3．文档注释</p>
<p>&#x2F;** 文档注释 *&#x2F;</p>
<p>Java的注释如下图1.17所示。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image012.png" class="" title="img">

<p>Java中的修饰符如下图1.19所示，其中public用来修饰类，也可以修饰方法，static用来修饰main方法，void是main方法的返回值类型，表示此方法没有返回值。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image013.png" class="" title="img">

<h2 id="类和主方法"><a href="#类和主方法" class="headerlink" title="类和主方法"></a>类和主方法</h2><p>Java中的类和主方法的结构图下图1.20所示，主方法在类的内部，类里包含方法。</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image014.png" class="" title="img">

<hr>
<p>Java跨平台性是通过JVM（Java虚拟机）来实现的。</p>
<p>JVM是不具有跨平台性的，针对不同的平台分别设计了对应的JVM。通过不同平台的JVM来实现了Java程序的跨平台性。也就是通过JVM的不跨平台性来支持Java程序的跨平台性。</p>
<p>Java代码的执行：</p>
<p>编译：Java源码通过javac命令编译成class字节码文件。</p>
<p>解释执行：class字节码文件通过java命令解释执行。</p>
<p>Java源码-&gt;编译-&gt;class字节码文件-&gt;解释器解释执行</p>
<p>注意，class字节码文件是与特定硬件平台无关的中间代码，从而实现了在不同平台上的JVM上的解释执行，实现跨平台性。</p>
<p> Java字节码的两种执行方式：</p>
<p>即时编译：解释器（JVM）将字节码编译成对应硬件平台的机器码（二进制指令），然后再在该平台上直接执行该机器码，速度快，效率高。</p>
<p>解释执行：解释器每次解释并执行字节码中的一小段代码，从而实现字节码的执行。</p>
<p> Java程序执行与C&#x2F;C++程序执行对比：</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image015.png" class="" title="img">

<p>JVM相当于80x86计算机。</p>
<p>JVM中的Java解释器相当于80x86 CPU。</p>
<p>在80x86 CPU上运行的是C&#x2F;C++源码编译之后的机器码，在JVM解释器上运行的是Java源码编译之后的字节码。</p>
<p>当前不是所有平台都提供了JVM的，因此，Java代码只能在已经实现了JVM软件的并且安装了JVM软件的平台上运行。</p>
<p>javac命令就是java编译器。</p>
<p>java命令就是java解释器。利用解释器去装载字节码的时候，会自动的启动jvm虚拟机。使字节码在jvm内部运行。</p>
<p>Java源文件编译过程：</p>
<p>Java应用程序的开发周期包括编译、下载、解释和执行几个部分。Java编译程序将Java源程序翻译为JVM可执行代码—字节码。这一编译过程同C&#x2F;C++的编译有些不同。当C编译器编译生成一个对象的代码时，该代码是为在某一特定硬件平台运行而产生的。因此，在编译过程中，编译程序通过查表将所有对符号的引用转换为特定的内存偏移量，以保证程序运行。Java编译器却不将对变量和方法的引用编译为数值引用，也不确定程序执行过程中的内存布局，而是将这些符号引用信息保留在字节码中，由解释器在运行过程中创建内存布局，然后再通过查表来确定一个方法所在的地址。这样就有效的保证了Java的可移植性和安全性。</p>
<p>解释器解释执行分为3步：</p>
<p>代码的装入、代码的校验、代码的执行。</p>
<p>运行JVM字节码的工作是由解释器来完成的。解释执行过程分三步进行：代码的装入、代码的校验和代码的执行。装入代码的工作由“类装载器”（class loader）完成。类装载器负责装入运行一个程序需要的所有代码，这也包括程序代码中的类所继承的类和被其调用的类。当类装载器装入一个类时，该类被放在自己的名字空间中。除了通过符号引用自己名字空间以外的类，类之间没有其他办法可以影响其它类。在本台计算机上的所有类都在同一地址空间内，而所有从外部引进的类，都有一个自己独立的名字空间。这使得本地类通过共享相同的名字空间获得较高的运行效率，同时又保证它们与从外部引进的类不会相互影响。当装入了运行程序需要的所有类后，解释器便可确定整个可执行程序的内存布局。解释器为符号引用同特定的地址空间建立对应关系及查询表。通过在这一阶段确定代码的内存布局，Java很好地解决了由超类改变而使子类崩溃的问题，同时也防止了代码对地址的非法访问。</p>
<p>随后，被装入的代码由字节码校验器进行检查。校验器可发现操作数栈溢出，非法数据类型转换等多种错误。通过校验后，代码便开始执行了。</p>
<p>Java基础类库，都内置在jdk中。</p>
<p>demo目录是提供的一些例子程序。</p>
<p> lib目录就是提供的一些基础类库。</p>
<p> jre目录就是运行时环境。</p>
<p><strong>linux&#x2F;unix</strong>下，换行是一个字符来表示的，ascII表示就是10。</p>
<p><strong>windows</strong>下，换行是两个字符来表示，实际是回车+换行，ascII表示就是13和10。来表示一个回车+换行。</p>
<p><strong>Java</strong>中所有功能都需要通过类来完成，也就是说Java中最小组织单位就是类。</p>
<p><strong>JDK</strong>、JRE、JVM关系示意图</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image017.jpg" class="" title="img">

<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image019.png" class="" title="https:&#x2F;&#x2F;img2020.cnblogs.com&#x2F;blog&#x2F;2170368&#x2F;202010&#x2F;2170368-20201013143113378-1314191418.png">

<p>JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。<br> JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。<br> 我们想要运行一个已有的Java程序，那么只需安装 JRE 即可。<br> 我们想要开发一个全新的Java程序，那么必须安装 JDK 。</p>
<p>三者关系： JDK &gt; JRE &gt; JVM</p>
<img src="/2022/09/29/Java/JavaSE/01-JavaSE%E5%85%A5%E9%97%A8%E3%80%81JDK%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F%E3%80%81Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E6%89%A7%E8%A1%8C/clip_image021.jpg" class="" title="img">

<p>Java程序的执行过程</p>
<p>所有的Java代码，其后缀都是以java结尾，Java程序的执行过程分为两步：</p>
<p>\1. 编译</p>
<p>\2. 执行</p>
<p>Class文件是字节码文件，程序最终执行的就是这个字节码（bytecode）文件。</p>
<p>编译命令：java Hello.java</p>
<p>执行命令：java Hello（注意，Test后面没有.class）</p>
<p><strong>注意，加载的是类，而不是class字节码文件。执行的流程就是首先根据java命令后面的要加载的类的名字来找到对应的名字的class文件，然后JVM会将class文件加载到内存的方法区中，然后将class文件解开，就会找到里面对应的那个类，然后就可以加载这个类进行运行。</strong></p>
<p>Java是跨平台的语言，真正执行的不是二进制代码，而是字节码。</p>
<p>JVM（Java Virtual Machine，Java虚拟机）</p>
<p>Java是跨平台的，而JVM不是跨平台的（JVM是由C语言编写的）</p>
<p>Java之所以能够做到跨平台，本质原因在于JVM不是跨平台的。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>03-JavaHome&amp;临时环境变量&amp;classpath环境变量</title>
    <url>/2022/10/04/Java/JavaSE/03-JavaHome&amp;%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&amp;classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="1-配置java-home、临时环境变量信息"><a href="#1-配置java-home、临时环境变量信息" class="headerlink" title="1.配置java_home、临时环境变量信息"></a>1.配置java_home、临时环境变量信息</h1><p>PATH环境信息：</p>
<p>D:;</p>
<p>D:\JDK\JDK\bin;</p>
<p>D:\eclipse4.3\adt-bundle-windows-x86-20131030\adt-bundle-windows-x86-20131030\sdk\platform-tools;</p>
<p>C:\Program Files\Intel\iCLS Client;</p>
<p>%SystemRoot%\system32;</p>
<p>%SystemRoot%;</p>
<p>%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Intel\OpenCL SDK\2.0\bin\x86;D:\mysql\bin;C:\Program Files\TortoiseSVN\bin;D:\firfox\quicktime\QTSystem\</p>
<p>目前path环境变量除了保存了我们自己配置的信息以外，还有系统自带的信息，如果一旦不不小心删除了path环境变量信息，那么就可能导致系统部分功能无法使用。</p>
<p>尽量避免修改的path环境变量信息。</p>
<p>如果我们需要频繁的更换jdk的版本，那么就需要频繁的去修改path环境变量内容了，就容易出错。</p>
<p>那么为了尽量避免频繁修改path环境变量，如何做？</p>
<p>解决办法：新建一个环境变量保存jdk安装目录会发生变化的部分，然后在path环境变量上引用新环境变量所保存的信息。</p>
<p>即使用java_home，当然这个环境变量不叫java_home也行，但是一般都起名为java_home。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image001.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image002.png" class="" title="img">

<p>当jdk版本有变动的时候，去修改JAVA_HOME的值即可了。path环境变量就不用动了。</p>
<p>有的时候，某个jdk版本只用一次，那么可以使用临时配置环境变量即可。</p>
<p>需求： 在现实开发中有时候jdk版本的信息有时候只会使用一次或者几次就不再使用了，那么如果是这种需求，我们一般都是通过set命令配置临时环境变量。</p>
<p><strong>临时环境变量就是仅对于当前控制台窗口起作用，窗口一旦关闭，那么配置的临时环境变量信息会发生消失。</strong></p>
<p>set命令的用法：</p>
<p>​    </p>
<p>​    set              查看所有的环境变量信息。</p>
<p>​    set 环境变量的名字      查看指定的环境变量信息。</p>
<p>​    set 环境变量名字 &#x3D; 路径信息   设置指定的环境变量信息。</p>
<p>​    set 环境变量名字 &#x3D;       清空指定的环境变量信息。</p>
<p>​    <strong>set 环境变量名字 &#x3D; 新路径；%环境变量名字%  在原有的基础上添加新的路径信息。</strong></p>
<p>注意： 以后大家但凡看到是set命令设置的环境变量信息，都是临时环境变量信息。</p>
<p><strong>helloworld的小细节</strong></p>
<p>\1.  缺少main方法</p>
<p>出现提示：缺少一个名称为main的方法。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image004.png" class="" title="img">

<p>\2.  源文件中的大小写要注意。初学者请牢记，第一个hello例子中只有     String和System中两个字符是大写的，其他的都小写。</p>
<p>\3.  配置path和classpath时，里面的路径是所有查找的目标的父目录，        而不是目标自己。</p>
<p>\4.  A.java.txt</p>
<p>​        文本文件默认是txt结尾的，注意要把隐藏已知文件类型扩展名去掉。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image006.png" class="" title="img">

<p>\5.  大小写</p>
<p>只有类名Demo，String和System中三个个首字母是大写的。</p>
<p>  <strong>public</strong> <strong>class</strong> <strong>Demo</strong>{    <strong>public</strong> <strong>static</strong> <strong>void</strong>  main(<strong>String</strong>[] args) {      <strong>System</strong>.<em>out</em>.println(“hello  java”);    }  }  </p>
<p>\6.  path</p>
<p>看path环境变量配置 ，里面的路径是所有查找的目标的父目录，而不是目标自己。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image008.png" class="" title="img">

<p><strong>7.</strong>  <strong>写错类名</strong>, <strong>源文件名不存在或者写错，或者当前路径错误。</strong></p>
<p><strong>类文件名写错，或者类文件不在当前路径下，或者不在classpath指定  路径下。</strong></p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image010.png" class="" title="img">

<p><strong>java</strong>命令加载的是类，而不是<strong>class</strong>文件的。因此，如果人为的将<strong>class文件</strong>的文件名改成别的，那么java命令加载的时候，仍然需要写里面的类名，而不应该写<strong>class文件的文件名。</strong></p>
<p>\8.  javac 生成的.class 文件的名称取决于类名，跟.java名没有关系。</p>
<p><strong>javac编译源文件，生成的class文件的文件名默认就是类名。</strong></p>
<p>第一个hello world例子常见 的问题：</p>
<p>​    </p>
<p>​    \1. 找不到对应的文件</p>
<p>​       原因：</p>
<p>​           1 隐藏了后缀名，你的不是java文件是txt文件。</p>
<p>​           2.编译 的时候写错了文件名。</p>
<p>​    \2. 找不到或无法加载主类 Demo1 </p>
<p>​       原因： 运行的时候写错了类名. 注意： class文件的文件名是对应的类名的。不是对应的java文件名的。</p>
<p>​    \3. java的代码是严格区分大小写的。</p>
<p>​    </p>
<p>​    \4. ‘javac’ 不是内部或外部命令 </p>
<p>​       原因： 没有配置path环境变量信息，或者是配置错误了。</p>
<h1 id="2-classpath环境变量信息"><a href="#2-classpath环境变量信息" class="headerlink" title="2.classpath环境变量信息"></a>2.classpath环境变量信息</h1><p><strong>JVM查找类文件的顺序：</strong></p>
<p>•  <strong>如果没有配置classpath环境变量，JVM只在当前目录下查找要运行的类文件。</strong></p>
<p>•  <strong>如果配置了classpath环境，JVM会先在classpath环境变量值的目录中查找要运行的类文件。</strong></p>
<p>•  <strong>值的结尾处如果加上分号，那么JVM在classpath目录下没有找到要指定的类文件，会在当前目录下在查找一次。</strong></p>
<p>•  <strong>值的结尾出如果没有分号，那么JVM在classpath目录下没有找到要指定的类文件，不会在当前目录下查找，即使当前目录下有，也不会运行。</strong></p>
<p><strong>建议：配置classpath环境变量时，值的结尾处不要加分号，如果需要访问当前目录可以用 “.”表示。</strong></p>
<p>classpath 环境变量：</p>
<p>​    </p>
<p>​    设置了classpath环境变量的时候，启动jvm(java虚拟机)的时候，那么java虚拟机就会 根据classpath环境变量所保存路径信息下去寻找对应的class文件。</p>
<p>​    设置classpath环境变量信息的有分号与没有分号的区别： </p>
<p>​       \1. 如果配置classpath环境变量信息<strong>没有加上分号</strong>,那么java虚拟机仅会在classpath所保存的路径下去搜索对应的class文件，不会在当前路径下去搜索了。</p>
<p>​       \2. 如果配置classpath环境变量信息<strong>加上分号</strong>，那么java虚拟机除了会在classpath所保存的路径下去搜索对应 的class文件之外,如果能找到对应的class文件那么就马上指定对应的class文件，否则还会去 当前路径下去搜索。</p>
<p><strong>注意，分号;，就相当于是当前目录，就是那个点.。</strong></p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image011.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image012.png" class="" title="img">

<p>现在E盘和F盘都有同名的Demo1.java文件，并且类名也相同，都是Demo1。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image013.png" class="" title="img">

<p>当前F盘编译了Demo1.java，有对应的class文件。</p>
<p>此时由于设置了classpath，因此，首先会在classpath设置的目录去搜索Demo1的class文件的。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image014.png" class="" title="img">

<p>如果将F盘的class文件删除了。</p>
<p>那么在classpath里面指定的f盘里找不到class文件，就在当前目录E盘下找。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image015.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image016.png" class="" title="img">

<p>分号放前面了。分号，就相当于是当前路径。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image017.png" class="" title="img">

<p>注意，不建议将classpath配置成永久环境变量的。</p>
<p>以前的书籍，都让配置classpath问永久环境变量。</p>
<p>jdk5官方也不建议配置classpath为永久环境变量了。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image018.png" class="" title="img">

<p>如果这里配置了，然后最后又没有加上分号。</p>
<p>然后自己可能忘记了。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image019.png" class="" title="img">

<p>在F盘执行，想要执行的是F盘的Demo1的，结果却执行了E盘的，原因就是上面配置了classpath导致的。因此，就会产生误解。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image020.png" class="" title="img">

<p>将E盘的class文件删了。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image021.png" class="" title="img">

<p>这就是由于配置了classpath&#x3D;E:\的原因。</p>
<p>因此，不推荐配置classpath为永久环境变量的。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image022.png" class="" title="img">

<p>在jdk5.0之前，是必须要配置classpath的。原因是当时的jvm没有那么智能。</p>
<p><strong>jre&#x3D;jvm+核心类库。也就是jvm的运行要依赖核心类库的。</strong></p>
<p>jdk5.0之前，安装完的jdk之后，jvm不知道核心类库的位置。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image023.png" class="" title="img">

<p>核心类库在这个目录下的。</p>
<p>因此，jdk5.0之前的jvm需要这些核心类库支持才能运行，但是又不能够智能的找到它们，因此，就强制要求必须要配置classpath环境变量，指向到这些核心类库的jar包。</p>
<img src="/2022/10/04/Java/JavaSE/03-JavaHome&%E4%B8%B4%E6%97%B6%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/clip_image024.png" class="" title="img">

<p>即要求要这样来配置。</p>
<p>而在jdk5.0之后的jvm比较智能了，能够自动的找到这些核心类库的jar包了，因此，不需要配置classpath指向到这些核心类库的jar包了。</p>
<p><strong>注意，配置classpath的作用，它对jvm有作用，同时它对编译的时候，也会产生作用的，因为编译的时候，遇到import导包的时候，就需要参考classpath指定的路径去找对应的包下的类的class文件。</strong></p>
<p>classpath环境变量</p>
<p>\1.  classpath的作用: 作用是<strong>指定类搜索路径</strong>，要使用已经编写好的类，前提当然是能够找到它们了，一旦配置了classpath路径信息的时候，jvm<strong>（java运行命令）</strong>与java编译器都会根据classpath指定的路径去寻找class文件。</p>
<p>\2.  如何设置当前目录（.）</p>
<p>set classpath&#x3D;.;设置路径 与 set classpath&#x3D;设置路径;.有什么区别?</p>
<p>“.”在前面的时候，java虚拟机会先从当前路径去寻找class文件，然后再到指定的路径去需找。如果”.”在后面，java虚拟机则会先寻找指定好的路径,然后再在当前的路径去寻找。</p>
<p><strong>设置classpath的时候要加上 ; 就会在当前目录下查找。因为分号就相当于是当前路径。</strong></p>
<p>\1.  简述对JVM,JRE,JDK的理解。</p>
<p>JVM: JAVA虚拟机</p>
<p>Jre： java运行环境 jre &#x3D; java虚拟机+ 核心类库</p>
<p>Jdk : java开发工具集。 Jdk &#x3D; jre + java开发工具。</p>
<p>\2.    简述环境变量path和java_home \ classpath的作用？</p>
<p>Path: 为了让控制台在任意路径下都可以找到java的开发工具。</p>
<p>Java_home : 避免频繁修改path 环境变量信息。</p>
<p>Classpath : 设置class文件所在的路径信息。</p>
<p>\3.    独立编写hello world程序，编译并运行。</p>
<p>\4.    java语言是否区分大小写? class的作用,javac,java的作用？</p>
<p> 是， class的作用定义一个该类 的关键字，</p>
<p> java :  启动java虚拟机解释并执行对应的class文件。</p>
<p>javac： 启动java编译器对指定的java源文件进行编译</p>
<p>\5. 简述main方法(是什么，什么特点，怎么用，何时用？)</p>
<p>​    程序的主入口，代码是从住方法上开始执行的。</p>
<p>​    写法是固定的。</p>
<p>​    定义一个类中使用。</p>
<p>​    如果一个类需要独立运行的时候，就需要main方法。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>02-命令行下运行Java代码</title>
    <url>/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<h1 id="02-命令行下运行Java代码"><a href="#02-命令行下运行Java代码" class="headerlink" title="02-命令行下运行Java代码"></a><a href="https://www.cnblogs.com/Leo101018/p/13808541.html">02-命令行下运行Java代码</a></h1><img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013133731413-1792118278.png" class="" title="img">

<p>这里如果报错，说明环境变量PATH没有配置。</p>
<p>如果没有配置PATH环境变量，仍然想要执行javac命令，那么就需切换到javac命令目录下去执行。</p>
<p>当执行一个程序的时候，首先在当前目录下查找是否有这个程序，如果没有，那么就去path环境变量下查找，以找到的第一个为准，也就是在path下有多个这个程序，但是找到了第一个就停止往后找了。<br>如果都没找到，那么就会报错了。</p>
<p>查看环境变量内容</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013133951044-759302803.png" class="" title="img">

<p>命令行下设置环境变量PATH内容</p>
<p>set path&#x3D;jdk路径\bin</p>
<p>注意，配置到bin目录。</p>
<p>命令行下配置，退出cmd，即失效，永久配置到环境变量配置文件中进行配置。</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013134400039-1428974611.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013134445937-977223770.png" class="" title="img">

<p> 注意，这里配置JAVA_HOME环境变量，然后通过该环境变量再去指定到bin目录，目的是不用去频繁的更改PATH环境变量，方式修改错误。如果jdk变换其他版本了，只需要更改JAVA_HOME环境变量即可。</p>
<p>编写测试java文件</p>
<p>[</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Hello</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Welcome</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013134851725-1447593978.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013134927582-528866572.png" class="" title="img">

<p><strong>注意：编译的时候，对于文件名的大小写是不敏感的。</strong></p>
<p><strong>在Java的源文件中可以写入多个类，但是编译之后，每个类会单独生成一个字节码文件（class文件）。</strong></p>
<p>当有很多的class文件的时候，给别人提供使用是不方便的，因此，可以将多个class文件进行打包，jar文件。</p>
<p>可以使用jar cvf xxx.jar Hello.class Welcome.class方式打包。</p>
<p>通常打包操作可通过IDE完成。</p>
<p>[</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Hello</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Welcome</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013135517652-212396672.png" class="" title="img">

<p><strong>当在一个源文件中定义了一个public的类，那么这个源文件的文件名必须取名为这个public类的类名。java中的规定。</strong><br><strong>因此，在一个源文件中，有且只能有一个public的类。也可以没有public的类，那么文件名可以是任意类的类名或者是其它的名字。</strong></p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013135719935-1988852445.png" class="" title="img">

<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013135758658-1222200341.png" class="" title="img">

<p><strong>编译的时候，可以没有main函数，但是要想执行，必须有main函数。否则执行错误。</strong></p>
<p><strong>另外，java解释器，解释执行的时候，加载的是一个类，而不是一个文件，不是welcome.class这个文件。而是Welcome这个类。</strong></p>
<p> <strong>java解释器要加载这个类，因此，后面的这个类名是大小写相关的。</strong></p>
<p> <strong>注意，main函数必须是public static void的。java Welcome加载类的过程为，首先根据这个名字找到对应的</strong></p>
<p><strong>class文件，即找到Welcome.class文件，然后jvm将该文件加载入内存的方法区（代码区）中，然后将class文件解</strong></p>
<p><strong>开，然后搜寻找到public static void的main函数，然后将该main函数加载到方法调用栈上进行执行。</strong></p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013140208913-1985116180.png" class="" title="img">

<p>第一次运行java Welcome没有报错，原因是，在Welcome.class目录下运行，能够找到对应文件。</p>
<p>第二次运行java Welcome报错，原因是，当前目录下没有Welcome.class文件了，且classpath环境变量没有配置，所以找不到类文件。</p>
<p><strong>当定义了classpath之后，那么java解释器在加载一个类的时候，就会完全根据classpath定义的路径去搜索要加载的类。而不会去看是否当前目录下有这个class文件。</strong></p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/2170368-20201013140611958-1418112487.png" class="" title="img">

<p><strong>可以看到，java解释器加载类的时候，当定义了classpath的时候，是完全按照定义的classpath指定的路径去搜寻的，而不会在当前路径下查找了。即使当前路径下有这个类，也不会找到。</strong><br><strong>为了让当前路径下的类也能找到，那么classpath中添加当前路径‘.’即可。</strong></p>
<p>为了配置的classpath永久生效，也需要配置到环境变量中去。</p>
<p>因此，需要配置两个环境变量：</p>
<p>path和classpath。</p>
<p><strong>安装jdk的路径要注意： 不能带有中文路径或者是空格。</strong></p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/image-20221004165803557.png" class="" title="image-20221004165803557">

<p>安装过程中，先安装jdk，然后又会提示你安装jre，实际上这个jre完全可以不安装，因为前面安装的jdk已经包含了jre了。</p>
<p>jdk目录的介绍：</p>
<p>​    bin: 存放的是java的开发工具。   </p>
<p>​    db : JDK7附带的一个轻量级的数据库，名字叫做Derby。</p>
<p>​    include ：存放的调用系统资源的接口文件。java程序中向os调用的时候，需要的本地os接口文件。</p>
<p>​    jre ： java运行环境</p>
<p>​    lib : 核心类库。</p>
<p>​    src.zip : java源代码</p>
<p>java.exe 启动java虚拟机解释并执行指定的class文件。</p>
<p>​     java工具的使用格式：</p>
<p>​            java 指定的class文件</p>
<p> javac.exe 启动java编译器对指定的java源文件进行编译。</p>
<p>编写第一个java的程序：</p>
<p>​    第一步： 新建一个txt文件。把后缀名改成java。</p>
<p>​    第二步： <strong>java 代码全部都是写到类上面的。也就是在java中，类是程序组织的最小单位。</strong></p>
<p>​       如何编写一个类：</p>
<p>​           使用一个关键字class即可定义个类。</p>
<p>​       格式：</p>
<p>​           class 类名{</p>
<p>​           } 备注： 大括号表示是一个类的范围，在类的范围之内都可以写代码，</p>
<p>​    <strong>第三步： 编写一个主方法。 主方法的写法是固定的，是一个程序的入口，代码从主方法开始执行</strong></p>
<p> 当直接双击一个可执行文件一闪而过就关闭了，那么一般说明，这个可执行文件需要一个控制台中来执行它。</p>
<p>如何启动java编译对java的源文件进行编译？</p>
<p>​    javac的使用格式：</p>
<p>​       javac java源文件。   </p>
<p> 编译的过程中我们就面临 的问题：每次编译的时候都需要写上java源文件的完整路径。 烦！！！</p>
<p>即需要在javac可执行文件的目录下，执行”javac java源文件完整路径”</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/image-20221004170158393.png" class="" title="image-20221004170158393">

<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/image-20221004170206872.png" class="" title="image-20221004170206872">

<p>这样是不好的，将源文件放到了javac的安装目录了，不好。乱。</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/image-20221004170232725.png" class="" title="image-20221004170232725">

<p>每次都需要写全路径，麻烦。</p>
<p><strong>解决方案： 如果可以在任意的路径下都可以找到java的开发工具，那么该问题就解决了。</strong></p>
<p><strong>在控制台写一个可执行文件的文件名，然后能够执行的原理：</strong></p>
<p>​    在控制台写一个可执行文件的文件名,那么系统<strong>首先会在控制台当前路径下去搜索是否存在该文件</strong>，如果可以找到指定的文件，那么就执行该文件，如果找不到该文件，那么系统还会根据<strong>path</strong>的环境变量所保存的路径信息下去搜索是否有指定的文件，如果能找到，那么就执行该文件。</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/clip_image001.png" class="" title="img">



<p>SystemRoot是Windows系统的根路径。</p>
<img src="/2022/10/04/Java/JavaSE/02-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E8%BF%90%E8%A1%8CJava%E4%BB%A3%E7%A0%81/clip_image001-1664874219008-26.png" class="" title="img">

<p>即这个目录。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>04-标识符、常量（字面量）、变量和数据类型、运算符</title>
    <url>/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="04-标识符、常量（字面量）、变量和数据类型、运算符"><a href="#04-标识符、常量（字面量）、变量和数据类型、运算符" class="headerlink" title="04-标识符、常量（字面量）、变量和数据类型、运算符"></a>04-标识符、常量（字面量）、变量和数据类型、运算符</h1><h2 id="Java程序结构"><a href="#Java程序结构" class="headerlink" title="Java程序结构"></a>Java程序结构</h2><img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004214518848.png" class="" title="image-20221004214518848">



<p>其中数据类型确定要存储在内存中的数据的类型；变量是存储数据的基本单元；运算符是一个符号，用于操作一个或多个参数以得出结果；程序是按顺序执行的，控制流语句允许改变此顺序。</p>
<h2 id="标识符、关键字和保留字"><a href="#标识符、关键字和保留字" class="headerlink" title="标识符、关键字和保留字"></a>标识符、关键字和保留字</h2><p>在Java语言中，通过标识符来表示一些元素的名字，比如变量名、类名、方法名和包名等。Java中的标识符要符合下面的规则：</p>
<ol>
<li>标识符必须以字母、下划线（_）、数字或美元（$）组成；</li>
<li>标识符必须由字母、下划线（_）或美元（$）开头，不能由数字开头；</li>
<li>标识符不能是关键字或者保留字；</li>
<li>标识符中不能有空格;</li>
<li>标识符没有长度限制。</li>
</ol>
<p>例如，A_123，$abc，length都是合法的标识符，而1a，s+g就是非法的标识符，各种不同的元素命名规则如下图</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004214805746.png" class="" title="image-20221004214805746">

<p>提示：</p>
<ol>
<li>Java区分大小写，因此area和Area是两个不同的标识符；</li>
<li>为提高程序的可读性，建议使用有意义的命名标识符，如area，length等。</li>
</ol>
<p>命名规范： 软性建议<br>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。<br>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。<br>变量名规范：全部小写。</p>
<p> <strong>关键字和保留字</strong><br>下表是Java中的关键字和保留字，关键字是对Java的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等；保留字是为Java预留的关键字，虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字，关键字和保留字如下表所示。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004215024906.png" class="" title="image-20221004215024906">



<h2 id="常量（字面量）"><a href="#常量（字面量）" class="headerlink" title="常量（字面量）"></a>常量（字面量）</h2><p><strong>常量（字面量）：也叫做字面量</strong>，我们可以直观看到的值，是指在Java程序中固定不变的数据。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004215140584.png" class="" title="image-20221004215140584">



<h2 id="常量（使用final声明的常变量）"><a href="#常量（使用final声明的常变量）" class="headerlink" title="常量（使用final声明的常变量）"></a>常量（使用final声明的常变量）</h2><p>常量<br>在程序中往往会存在变量值不需要变化的情况，比如表示圆周率的变量，比如表示黄金分割点的变量，那么<strong>这些值不变的变量就叫常量</strong>。<br>在Java中，<strong>常量用关键字final来表示（在后面章节会详细讲解）</strong>，它也是有数据类型的，语法如下：<br><strong>final数据类型 常量名 &#x3D; 初始值;</strong><br>提示：</p>
<ol>
<li><p><strong>常量在声明的时候必须初始化；</strong></p>
</li>
<li><p><strong>常量在初始化后值不能再更改，否则会引起错误。</strong><br> 例如：<br> final double PI &#x3D; 3.14;</p>
</li>
</ol>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量（variable）是用来存储数据的一块存储区域，在程序运行中它的值可以发生变化。变量可以存放一种数据类型的值，Java程序在运行加载时会根据变量的不同数据类型来分配不同的内存空间，变量的数据类型在声明时指定。<br>变量是指在程序的运行过程中随时可以发生变化的量，作用是：<br>1．变量是程序中数据的临时存放场所<br>2．保存程序运行时用户输入的数据<br>3．特定的运算结果等</p>
<p><strong>变量的声明</strong><br>一个变量只有在声明后才有效，声明的作用就是确定该变量要存储的数据类型。声明变量的语法格式如下：<br>数据类型 变量名;<br>如果要同时声明多个相同数据类型的变量，可以如下写：<br>数据类型 变量名1,变量名2;<br>代码举例如下：<br>int number, max;</p>
<p>注意，变量必须要先声明，后使用。</p>
<p><strong>在局部作用域（例如函数体内）内声明的变量必须进行初始化才能够使用，否则就是一个随机值，不能够直接使用，编译会提示未初始化的变量错误。</strong></p>
<p>变量在声明后，不能直接访问，只有被赋值的变量才能够被访问，否则就会出现运行错误。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004215515107.png" class="" title="image-20221004215515107">

<p><strong>局部变量必须进行初始化。</strong></p>
<p><strong>变量的赋值</strong><br><strong>第一次给变量赋值叫”初始化”。</strong>使用等号”&#x3D;”来进行赋值，语法如下：<br>变量名 &#x3D; 数据值;<br>例如：<br>int number;<br>number &#x3D; 1000;<br>也可以把变量的声明和初始化合用一个语句实现出来，例如上面两行代码就可以改写成一行代码：<br>int number &#x3D; 1000;<br>每个已经声明了数据类型的存储变量只能存储对应类型的数据。如下代码是正确的：<br>int ii &#x3D; 100;<br>double pi &#x3D; 3.14;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String args[])</span> &#123;</span><br><span class="line">        <span class="type">double</span> salary; <span class="comment">//声明变量</span></span><br><span class="line">        salary = <span class="number">1500.00</span>; <span class="comment">//变量赋初值</span></span><br><span class="line">        System.out.println(salary); <span class="comment">//变量的访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004220048802.png" class="" title="image-20221004220048802">

<p>注意，Java中的变量如图，就是这个内存区域中存储的是5，这个内存区域就是变量a，不同于Python中的变量是一种指向的关系。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在Java中，数据类型分为两大类：<br><strong>基本数据类型：8种基本数据类型</strong><br>● 字符型<br>● 布尔型<br>● 数值型<br>  ○ 整型<br>  ○ 浮点型<br><strong>引用数据类型：存储地址的引用</strong><br>● 类<br>● 接口<br>● 数组</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004220409808.png" class="" title="image-20221004220409808">

<p>有的说法，java的数据类型中的复合数据类型，实际上就是引用数据类型，就是类，接口，数组，这些。</p>
<p>Java的数据类型分为两大类：<br>基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。<br>引用数据类型：包括 类 、 数组 、 接口 。</p>
<p>基本数据类型：</p>
<p>　　整数型 byte short int long<br>　　浮点型 float double<br>　　字符型 char<br>　　布尔型 boolean</p>
<p>引用数据类型：</p>
<p>　　字符串、数组、类、接口、Lambda</p>
<p>注意事项：<br>\1. <strong>字符串不是基本类型，而是引用类型。</strong><br>\2. <strong>浮点型可能只是一个近似值，并非精确的值。</strong><br>\3. <strong>数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。</strong><br>\4. <strong>浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。</strong><br>　<strong>如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。</strong></p>
<p>每个数据类型都有取值范围，编译器会对每种数据类型分配相应大小的存储空间。下面我们来详细介绍一下这8种基本数据类型。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004220730005.png" class="" title="image-20221004220730005">

<p><strong>Java中的默认类型：整数类型是 int ，声明long型后面需加上l或者L，否则会出错。浮点类型数据默认是 double 。</strong></p>
<h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><table>
<thead>
<tr>
<th>byte</th>
<th>字节型</th>
<th>1个字节（8位二进制）</th>
<th>-128 到 127</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>short</th>
<th align="left">短整型</th>
<th>2个字节（16位二进制）</th>
<th>-2^15 到 2^15-1</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>int</th>
<th>整型</th>
<th>4个字节（32位二进制）</th>
<th>-2^31到 2^31-1</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th>long</th>
<th>长整型</th>
<th>8个字节（64位二进制）</th>
<th>-2^63到 2^63-1</th>
</tr>
</thead>
</table>
<p><strong>Java中整型的四种表示形式</strong><br>十进制整数：0 ~ 9，注：第一位不能是0</p>
<p>十六进制数：0 ~ 9 A ~ F, 注：必须以0x或0X开头<br>例如： 0X8A 0x12</p>
<p>八进制整数：0 ~ 7，注：必须以0开头<br>例如： 0123 012</p>
<p>二进制整数：0~1，注：必须以0B开头（在java1.7及以上版本可用）<br>例如： 0B1010</p>
<p>例 在java中与语句int a &#x3D; 97;等效的声明语句是_____<br>A.int a &#x3D; 0X0061;<br>B.int a &#x3D; 0X61;<br>C.int a &#x3D; 0141;<br>D.int a &#x3D; 97.0;<br>答案：ABC</p>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>与整数类型相似，Java浮点数类型有固定的表示范围和字段长度，不受平台影响，浮点数据类型</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>占空间大小</strong></th>
<th><strong>值域</strong></th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>单精度浮点型</td>
<td>4个字节，精度约7位</td>
<td>-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>8个字节，精度约为17位</td>
<td>-1.798E308 ~ 1.798E308</td>
</tr>
</tbody></table>
<p>Java浮点数类型有两种表示形式，分别是十进制形式和科学计数法形式，具体表示方式如下：</p>
<p>十进制数形式，例如：3.14 314.0 .314</p>
<p>科学计数法形式，如：3.14e2 3.14E-1</p>
<p><strong>Java浮点型常量默认为double型，如要声明一个常量为float型，则需在数字后面加f或F，</strong>如:<br>double d &#x3D; 12345.6<br><strong>float f &#x3D; 12.3F</strong></p>
<p><strong>提示：</strong></p>
<ol>
<li><strong>带小数的数据默认是double型而非float型的；</strong></li>
<li>定义float型数据需要后面紧跟”f”或”F”来表示，比如float f &#x3D; 2.1f；</li>
<li>定义长整型数据，可以后面紧跟”l”或”L”来表示。</li>
</ol>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符数据类型用于<strong>存放单个字符，每个字符占用2个字节（16位二进制）的内存空间</strong>。一个字符型数据由单引号括起来，使用”char”关键字来说明数据类型，语法如下：</p>
<p>char letter &#x3D; ‘a’;</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004221957987.png" class="" title="image-20221004221957987">



<p>字符类型是一个16位无符号整数，Java中字符类型的值是对应字符的编码, 是unicode编码，其中，英文部分的值与ascII编码一致。char是定长编码, 所有的字符都是16位。例如：</p>
<p>‘A’ 对应的编码是0x0041</p>
<p>‘中’对用的编码是 0x4e2d</p>
<p>char类型在编码中: ‘0’<del>‘9’, ‘a’</del>‘z’, ‘A’~’Z’都是连续编码的，’0’与’\u0000’不是同一个字符，字符编码的最小值为0, 最大值是65535 ，也就是2^16-1，使用时要注意字符字面量使用单引号为定界符号。</p>
<p><strong>提示：</strong></p>
<ol>
<li>字符型只表示一个字符，不能表示多个字符，比如’abc’是错的；</li>
<li>字符型只能用单引号（’）括起来，用双引号（”）括起来的不是字符，而是字符串（String），比如”a”表示的不是char型字符而是String型字符串。</li>
</ol>
<p>Java还允许使用转义字符来表示特殊字符。转义字符用斜杠”\“打头，后面跟一个字符。</p>
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>转义字符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>退格键</td>
<td>\b</td>
<td>表示一次退格</td>
</tr>
<tr>
<td>Tab键</td>
<td>\t</td>
<td>表示一个Tab空格</td>
</tr>
<tr>
<td>换行符</td>
<td>\n</td>
<td>表示换行</td>
</tr>
<tr>
<td>回车键</td>
<td>\r</td>
<td>表示回车</td>
</tr>
<tr>
<td>斜杠</td>
<td>\\</td>
<td>表示斜杠</td>
</tr>
<tr>
<td>单引号</td>
<td>\‘</td>
<td>表示单引号</td>
</tr>
<tr>
<td>双引号</td>
<td>\“</td>
<td>表示双引号</td>
</tr>
</tbody></table>
<p>转义字符用在一些特殊字符的表示上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeCharDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;escape\bchar&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;escape\tchar&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;escape\rchar&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;escape\nchar&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\\我在斜线里\\&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\&#x27;我在单引号里\&#x27;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我没有单引号&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\&quot;我在双引号里\&quot;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;我没有双引号&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004222512443.png" class="" title="image-20221004222512443">



<p><strong>其中\b, \r，在java命令行中能够看到效果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;escape\bchar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;escape\tchar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;escape\rchar&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;escape\nchar&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004222613069.png" class="" title="image-20221004222613069">



<p><strong>ASCII码表</strong></p>
<p>对于字符来说，存储的时候，会转为对应的ascII码来进行存储的。<br>因此，字符在计算机中的表示都是以整数来进行表示的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//字符类型变量</span></span><br><span class="line">  <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//字符类型和int类型计算</span></span><br><span class="line">  System.out.println(c+i);<span class="comment">//输出结果是98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>ASCII（ American Standard Code for Information Interchange 美国标准信息交换码）。</strong></p>
<p>在char类型和int类型计算的过程中，char类型的字符先查询编码表，得到97，再和1求和，结果为98。</p>
<p>实际就是char类型提升为了int类型（自动类型转换）。char类型内存2个字节，int类型内存4个字节。</p>
<p><strong>ASCII码表</strong></p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004234949377.png" class="" title="image-20221004234949377">

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004235010409.png" class="" title="image-20221004235010409">



<p>java中1.3这种认为是double类型的，因此，1.3f这样表示1.3是float类型的。<br>c中非0即为真，因此可以while（1）这样，但是java中不行，java只能while（true）这样。</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔数据类型由关键字boolean来表示，<strong>布尔型数据的值域只有两个值：true和false</strong>。例如，下面两行代码：</p>
<p>boolean isOK &#x3D; true;</p>
<p>boolean isFirst &#x3D; false;</p>
<p><strong>提示：</strong></p>
<ol>
<li><strong>true和false都是小写，True、TRUE、False、FALSE都不是布尔型数据的值</strong>；</li>
<li><strong>布尔型数据不能用数字0和1来表示真假，只能用true和false；</strong></li>
<li><strong>布尔型数据默认值是false。</strong></li>
</ol>
<p><strong>例2.5 布尔数据类型</strong></p>
<p>boolean flag;</p>
<p>flag &#x3D; true;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//定义字节型变量</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//定义短整型变量</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//定义整型变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">//定义长整型变量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">12345678900L</span>;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        <span class="comment">//定义单精度浮点型变量</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">5.5F</span>;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">//定义双精度浮点型变量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">8.5</span>;</span><br><span class="line">        System.out.println(d);</span><br><span class="line">        <span class="comment">//定义布尔型变量</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        System.out.println(bool);</span><br><span class="line">        <span class="comment">//定义字符型变量</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>long类型：建议数据后加L表示。<br>ﬂoat类型：建议数据后加F表示。</p>
<p>注意事项：</p>
<p>变量名称：在同一个大括号范围内，变量的名字不可以相同。否者会报重复定义的错误。<br>变量赋值：定义的变量，不赋值不能使用。</p>
<p>变量要先定义后使用。</p>
<p>每条语句最后要加分号;否则语法错误。</p>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>Java是强类型语言，要求赋值或传递时数据类型必须匹配，我们可以利用Java提供的数据类型的转换来消除这种错误。</p>
<p>Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。</p>
<p><strong>Java提供了两种数据类型的转换方式：自动转换和强制转换</strong></p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004223055828.png" class="" title="image-20221004223055828">



<h3 id="自动数据类型转换"><a href="#自动数据类型转换" class="headerlink" title="自动数据类型转换"></a>自动数据类型转换</h3><p>自动数据类型转换也称之为隐式类型转换，我们在数值数据类型中了解到，不同类型的数据会占用不同大小的存储空间，那么<strong>数据类型自</strong></p>
<p><strong>动转换的原则就是</strong>：<strong>小空间的数据类型可以自动转换成大空间的数据类型</strong>，<strong>也就是说低精度的数据可以升级成高精度的数据</strong>，反之不行，</p>
<p>我们可以理解成高精度的数据转换成低精度的数据会失去数据的精度，所以不能这样转换。数据类型的自动转换顺序如下图</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004223327366.png" class="" title="image-20221004223327366">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// byte x = b + i; // 报错</span></span><br><span class="line">    <span class="comment">//int类型和byte类型运算，结果是int类型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b + i;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运算结果，变量的类型将是 int 类型，这就是出现了数据类型的自动类型转换现象。</p>
<p>byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类型。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004233905882.png" class="" title="image-20221004233905882">



<p>同理，当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">2.5</span>;</span><br><span class="line">    <span class="comment">//int类型和double类型运算，结果是double类型</span></span><br><span class="line">    <span class="comment">//int类型会提升为double类型</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> d+i;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>转换规则：</p>
<p>范围小的类型向范围大的类型提升， byte、short、char 运算时直接提升为 int 。</p>
<p>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</p>
<h3 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h3><p>将 1.5 赋值到 int 类型变量会发生什么？产生编译失败，肯定无法赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1.5</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>double 类型内存8个字节， int 类型内存4个字节。 1.5 是 double 类型，取值范围大于 int 。</p>
<p>想要赋值成功，只有通过强制类型转换，将 double 类型强制转换成 int 类型才能赋值。</p>
<p>自动转换是Java自动执行的，而强制转换需要我们自己手动执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// double类型数据强制转成int类型，直接去掉小数点。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1.5</span>;</span><br></pre></td></tr></table></figure>



<p>强制数据类型转换也称之为显式类型转换，既然有些数据类型不能互相自动进行转换，那么Java提供了强制转换的方法，强制转换的语法就是用圆括号括起你要转换成的目的数据类型：</p>
<p>变量&#x3D;（目标类型）值;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">a = (<span class="type">byte</span>) b;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">2.8</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> (<span class="type">float</span>)<span class="number">5.2</span>;</span><br></pre></td></tr></table></figure>



<p>当一个 short 类型与 1 相加，我们知道会类型提升，但是还想给结果赋值给short类型变量，就需要强制转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="comment">//short类型变量，内存中2个字节</span></span><br><span class="line">     <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">       出现编译失败</span></span><br><span class="line"><span class="comment">       s和1做运算的时候，1是int类型，s会被提升为int类型</span></span><br><span class="line"><span class="comment">       s+1后的结果是int类型，将结果在赋值会short类型时发生错误</span></span><br><span class="line"><span class="comment">       short内存2个字节，int类型4个字节</span></span><br><span class="line"><span class="comment">       必须将int强制转成short才能完成赋值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     s = s + <span class="number">1</span>；<span class="comment">//编译失败</span></span><br><span class="line">     s = (<span class="type">short</span>)(s+<span class="number">1</span>);<span class="comment">//编译成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004234246121.png" class="" title="image-20221004234246121">

<p><strong>注意：</strong></p>
<p>　　浮点转成整数，直接取消小数点，可能造成数据损失精度。<br>　　int 强制转成 short 砍掉2个字节，可能造成数据丢失。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义s为short范围内最大值</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">32767</span>;</span><br><span class="line"><span class="comment">// 运算后，强制转换，砍掉2个字节后会出现不确定的结果</span></span><br><span class="line">s = (<span class="type">short</span>)(s + <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004234426297.png" class="" title="image-20221004234426297">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> b;</span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line">b = b*<span class="number">3</span>;java会自动做类型提升，将b自动提升为<span class="type">int</span>，因此，会发生错误。</span><br><span class="line">b = （<span class="type">byte</span>）b*<span class="number">3</span>;这样，但是还是报错，因为强制类型转换比乘法优先级高。</span><br><span class="line">b = （<span class="type">byte</span>）（b*<span class="number">3</span>）;应该这样。</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestConvert</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String arg[])</span> &#123;</span><br><span class="line">    <span class="comment">/*自动类型转换*/</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">45</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> (i1 + i2) * <span class="number">1.0</span>;<span class="comment">//系统将转换为double型运算</span></span><br><span class="line">    System.out.println(d1);</span><br><span class="line">    <span class="comment">/*自动类型转换*/</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="number">12.3f</span>;<span class="comment">//必须加f</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">12300</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">300000000000L</span>;<span class="comment">//必须加l</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> l1 + l2 + f3;<span class="comment">//系统将转换为float型计算</span></span><br><span class="line">    System.out.println(f);</span><br><span class="line">    <span class="type">byte</span> m1=<span class="number">1</span>;</span><br><span class="line">    <span class="type">byte</span> m2=<span class="number">3</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">byte</span>)(m1+m2);<span class="comment">//byte类型参与运算会自动转换为int类型，然后再进行运算，结果为int，因此，需要强转为byte赋值</span></span><br><span class="line">    <span class="comment">/*强制类型转换*/</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> (<span class="type">long</span>)f;<span class="comment">//强制转换会舍去小数部分（不是四舍五入）</span></span><br><span class="line">    System.out.println(l);</span><br><span class="line">    <span class="comment">/*强制类型转换*/</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">67</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">89</span>;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b3</span> <span class="operator">=</span> (<span class="type">byte</span>)(b1 + b2);<span class="comment">//系统将转换为int型运算，需要强制转换符</span></span><br><span class="line">    System.out.println(b3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004225305700.png" class="" title="image-20221004225305700">

<p>67+89&#x3D;156</p>
<p>156-127&#x3D;28</p>
<p>byte范围是-128~127，因此，当超过了范围之后就会溢出，然后又会从最小的开始了。因此，128就是-128,129就是-127，以此类推，156就是-100。</p>
<p><strong>提示：</strong></p>
<ol>
<li><strong>boolean型数据不能和其他基本数据类型进行转换；</strong></li>
<li><strong>char型和int型数据可以互换；</strong></li>
<li><strong>byte、short、char之间不会相互转换，它们三者在计算时首先会转换为int类型；</strong></li>
<li>在强制类型转换过程中，源类型的值可能大于目标类型，因此可能造成精度降低或溢出，使用时需注意。</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符和表达式"><a href="#算术运算符和表达式" class="headerlink" title="算术运算符和表达式"></a>算术运算符和表达式</h3><p>算术运算是一种常见的运算，主要是对数值型数据进行加减乘除等运算</p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>名称</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加运算符</td>
<td></td>
</tr>
<tr>
<td>-</td>
<td>减运算符</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>乘运算符</td>
<td></td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除运算符</td>
<td>若是两个整数相除，只保留整数部分</td>
</tr>
<tr>
<td>%</td>
<td>取模（取余）运算符</td>
<td><strong>被除数为正数结果都为正，被除数为负数结果都为负</strong></td>
</tr>
<tr>
<td>++</td>
<td>自增</td>
<td>++变量名：变量在参与其他操作前先将自己加1; 变量名++：先用原来的值参与其他操作后，再将自己加1</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>算法同++</td>
</tr>
<tr>
<td>+</td>
<td>字符串连接</td>
<td>当操作数中只要有一个是String类型，系统会自动将另一个操作数转换成字符串类型，然后进行连接</td>
</tr>
</tbody></table>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004225941405.png" class="" title="image-20221004225941405">

<p>被除数为正，结果为正。不看除数正负</p>
<p>被除数为负，结果为负。不看除数正负</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004225958659.png" class="" title="image-20221004225958659">

<p>由于被除数是5.0，因此，2会自动类型转换为double，然后进行计算，因此，结果为double的。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230012172.png" class="" title="image-20221004230012172">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfplusOperatorDemo1</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i++;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;, &quot;</span> + i);<span class="comment">// 0,1</span></span><br><span class="line">    a = ++i;</span><br><span class="line">    System.out.println(a + <span class="string">&quot;, &quot;</span> + i);<span class="comment">// 2,2</span></span><br><span class="line">    i = i++;</span><br><span class="line">    System.out.println(i);<span class="comment">// 2</span></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 0</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 1</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 2</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 0</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 1</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 2</span></span><br><span class="line">    System.out.println(i++ % <span class="number">3</span>);<span class="comment">// 0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230310108.png" class="" title="image-20221004230310108">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelfplusOperatorDemo2</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">3</span>, y1 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="number">3</span>, y2 = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> r1, r2;</span><br><span class="line">    r1 = x1++ + x1*y1;</span><br><span class="line">    r2 = ++x2 + x2*y2;</span><br><span class="line">    System.out.println(<span class="string">&quot;x1=&quot;</span>+x1+<span class="string">&quot; y1=&quot;</span>+y1+<span class="string">&quot; r1=&quot;</span>+r1);</span><br><span class="line">    System.out.println(<span class="string">&quot;x2=&quot;</span>+x2+<span class="string">&quot; y2=&quot;</span>+y2+<span class="string">&quot; r2=&quot;</span>+r2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230544013.png" class="" title="image-20221004230544013">

<p>注意，+运算符是左结合性，也就是从左向右运算的。</p>
<h3 id="字符串和运算符"><a href="#字符串和运算符" class="headerlink" title="字符串和运算符"></a>字符串和运算符</h3><p>字符串连接运算符使用”+”运算符，但此时与算术运算符中的加法运算符”+”的意义是不同的。字符串连接运算符，能够将多个字符串合并到一起生成一个新的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">2.15f</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">5.7</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;c=&quot;</span> + c);</span><br><span class="line">    System.out.println(<span class="string">&quot;s=&quot;</span> + s);</span><br><span class="line">    System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">    System.out.println(<span class="string">&quot;f=&quot;</span> + f);</span><br><span class="line">    System.out.println(<span class="string">&quot;d=&quot;</span> + d);</span><br><span class="line">    System.out.println(<span class="string">&quot;b=&quot;</span> + b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230716894.png" class="" title="image-20221004230716894">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line">		<span class="type">float</span> f=<span class="number">2.5f</span>;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i+f+c+s);</span><br><span class="line">		</span><br><span class="line">		System.out.println(i+f+s+c);</span><br><span class="line">		</span><br><span class="line">		System.out.println(c+s+i+f);</span><br><span class="line">		</span><br><span class="line">		System.out.println(c+s+(i+f));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004230949690.png" class="" title="image-20221004230949690">



<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>名称</strong></th>
<th><strong>例子</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值运算符</td>
<td>i&#x3D;8</td>
<td>8赋值给i</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加简捷赋值运算符</td>
<td>i+&#x3D;8</td>
<td>同i&#x3D;i+8</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减简捷赋值运算符</td>
<td>i-&#x3D;8</td>
<td>同i&#x3D;i-8</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘简捷赋值运算符</td>
<td>i*&#x3D;8</td>
<td>同i&#x3D;i*8</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除简捷赋值运算符</td>
<td>i&#x2F;&#x3D;8</td>
<td>同i&#x3D;i&#x2F;8</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>取模简捷赋值运算符</td>
<td>i%&#x3D;8</td>
<td>同i&#x3D;i%8</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		i+=<span class="number">8</span>;<span class="comment">//18</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">		</span><br><span class="line">		i-=<span class="number">8</span>;<span class="comment">//10</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">	</span><br><span class="line">		i*=<span class="number">8</span>;<span class="comment">//	80</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">		</span><br><span class="line">		i/=<span class="number">8</span>;<span class="comment">//10</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">		</span><br><span class="line">		i%=<span class="number">8</span>;<span class="comment">//2</span></span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+i);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意，在java中的基本数据类型的赋值而言是将变量值放到变量的内存单元中去，然后该内存单元命名为变量名。不同于python中的变量值与变量名绑定的含义。</strong></p>
<p><strong>python中变量值与变量名绑定，更像是java中的引用类型的变量值与变量名的关系，变量中存储的是引用类型值的内存地址或者叫做引用地址。</strong></p>
<h3 id="关系运算符和表达式"><a href="#关系运算符和表达式" class="headerlink" title="关系运算符和表达式"></a>关系运算符和表达式</h3><p><strong>关系运算又叫比较运算</strong>，用来对两个操作数进行大小、等于的关系比较，</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>样例</th>
<th>结果说明</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于</td>
<td>1&gt;2</td>
<td>false</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td>1&gt;&#x3D;2</td>
<td>false</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>1&lt;2</td>
<td>true</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td>1&lt;&#x3D;2</td>
<td>true</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>等于</td>
<td>1&#x3D;&#x3D;2</td>
<td>false</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td>1!&#x3D;2</td>
<td>true</td>
</tr>
</tbody></table>
<p>比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 true 或者 false 。</p>
<p>注意，比较运算符最终的运算结果为布尔值的。</p>
<p><strong>关系表达式用于进行关系比较，关系表达式的值都是布尔型的</strong>，例如下面代码：</p>
<p>int i &#x3D; 10;</p>
<p>int j &#x3D; 16;</p>
<p>boolean smalli &#x3D; i&lt;j;</p>
<p>boolean equal &#x3D; i&#x3D;&#x3D;j;</p>
<p>boolean bigi &#x3D; i&gt;j;</p>
<p><strong>提示：</strong></p>
<ol>
<li>关系表达式的结果都是布尔值，true或false；</li>
<li>比较相等的是双等号”&#x3D;&#x3D;”，不是一个等号”&#x3D;”，一个等号”&#x3D;”只能用来赋值。</li>
</ol>
<h3 id="逻辑运算符和表达式"><a href="#逻辑运算符和表达式" class="headerlink" title="逻辑运算符和表达式"></a>逻辑运算符和表达式</h3><p>逻辑运算又叫布尔运算，包括四个运算符，分别是&amp;&amp;、||、！和^，用来进行与、或、非和异或的逻辑运算。</p>
<p><strong>逻辑运算的操作数和结果都是布尔类型的值。</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th><strong>运算符</strong></th>
<th><strong>名称</strong></th>
<th><strong>运算规则</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>与运算符</td>
<td>逻辑与</td>
<td>运算符左右两端的操作数都为true，表达式结果才为true，其它情况表达式结果为false</td>
</tr>
<tr>
<td>| |</td>
<td>或运算符</td>
<td>逻辑或</td>
<td>运算符左右两端的操作数都为false，表达式结果才为false，其它情况表达式结果为true</td>
</tr>
<tr>
<td>!</td>
<td>非运算符</td>
<td>逻辑取反</td>
<td>操作数为true，结果为false；操作数为false，结果为true</td>
</tr>
<tr>
<td>^</td>
<td>异或运算符</td>
<td>逻辑异或</td>
<td>运算符左右两端的操作数，相同结果为false，不同结果为true</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">y</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		</span><br><span class="line">		System.out.println(x&amp;&amp;y);<span class="comment">//false</span></span><br><span class="line">		System.out.println(x||y);<span class="comment">//true</span></span><br><span class="line">		System.out.println(!x);<span class="comment">//false</span></span><br><span class="line">		System.out.println(x^y);<span class="comment">//亦或，相同为假，不同为真				</span></span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>



<p><strong>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 true 或者 false</strong></p>
<p>注意，在python中，运算结果不一定是ture或者false的。要看两边的内容，例如，11 || False，那么结果是11，不是布尔值的，因为，python中，非0的11表示了True。</p>
<p>而在java中，逻辑运算符两侧必须是布尔类型的值才行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">55</span>&gt;<span class="number">13</span> || <span class="literal">false</span>); <span class="comment">//结果为true</span></span><br><span class="line"><span class="comment">//        System.out.println(55 || 0); error ||两侧数据类型错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>短路与vs非短路与</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//短路与&amp;&amp; vs 非短路与&amp;</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">20</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//boolean flag = a&gt;b &amp;&amp; ++b&gt;c;//左边为假，右边短路了</span></span><br><span class="line">		<span class="comment">//System.out.println(flag);//false</span></span><br><span class="line">		<span class="comment">//System.out.println(b);//20</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> a&gt;b &amp; ++b&gt;c;<span class="comment">//右边不短路</span></span><br><span class="line">		System.out.println(flag);<span class="comment">//false</span></span><br><span class="line">		System.out.println(b);<span class="comment">//21			</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>短路或 vs 非短路或</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//短路或|| vs 非短路|		</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">20</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span><span class="number">30</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//boolean flag = a&lt;b||++b&gt;c;//左边为真，右边短路了</span></span><br><span class="line">		<span class="comment">//System.out.println(flag);//true</span></span><br><span class="line">		<span class="comment">//System.out.println(b);//20</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> a&lt;b|++b&gt;c;<span class="comment">//右边不短路</span></span><br><span class="line">		System.out.println(flag);<span class="comment">//true</span></span><br><span class="line">		System.out.println(b);<span class="comment">//21	</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>三目条件运算符的语法为：</p>
<p><strong>表达式1 ? 表达式2 : 表达式3</strong></p>
<p>int a&#x3D;3, b&#x3D;6;</p>
<p>int x &#x3D; a&gt;b? a:b;</p>
<p>那么计算结果就是x&#x3D;6。</p>
<p><strong>在三目条件运算中，表达式1和表达式2的值可以是任意一种基本数据类型。</strong></p>
<p><strong>数据类型 变量名 &#x3D; 布尔类型表达式？结果1：结果2</strong></p>
<p><strong>三元运算符计算方式：</strong><br>　　布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。<br>　　布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 三目条件运算符		</span></span><br><span class="line">		<span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> a&lt;b?<span class="literal">true</span>:<span class="literal">false</span>;	</span><br><span class="line">		<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> a&lt;b?<span class="string">&#x27;真&#x27;</span>:<span class="string">&#x27;假&#x27;</span>;	</span><br><span class="line">		<span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> a&lt;b?<span class="string">&quot;正确&quot;</span>:<span class="string">&quot;错误&quot;</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a&lt;b?<span class="number">1</span>:<span class="number">0</span>;		</span><br><span class="line">		<span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> a&lt;b?<span class="number">1.0</span>:<span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004233201050.png" class="" title="image-20221004233201050">



<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>表达式通常由多个运算符组成。优先级的规则决定每个运算符在任何给定表达式中的计算顺序。表达式是按照从左到右运算符的优先级来进行运算的，正因为这种优先级的限制，才保证了每个表达式每次运算的结果都一样。</p>
<p>按操作数多少划分优先级</p>
<p>一元操作符 &gt; 二元操作符 &gt; 三元操作符</p>
<p>按运算类型划分优先级</p>
<p>算术运算符 &gt; 关系运算符 &gt; 逻辑运算符 &gt; 赋值运算符</p>
<p>尽量多的使用括号，括号优先级别最高，使用括号也可保证在不确定优先级的情况下，更好地控制语句的执行顺序。</p>
<img src="/2022/10/04/Java/JavaSE/04-%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E5%B8%B8%E9%87%8F%EF%BC%88%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%89%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6/image-20221004233454906.png" class="" title="image-20221004233454906">



<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>表达式是符合一定语法规则的运算符和运算数的序列。按照使用的运算符和运算结果的不同可以分为：</p>
<p>1.算术表达式</p>
<p>例如：(x+y-12)*100</p>
<p>2.关系表达式</p>
<p>例如：x&gt;y， x&gt;&#x3D;y， x!&#x3D;y， x&#x3D;&#x3D;y</p>
<p>3、逻辑表达式</p>
<p>例如：x&amp;&amp;y， x||y||z， (!x)&amp;&amp;(!y)</p>
<p>4、赋值表达式</p>
<p>例如：x&#x3D;y， x+&#x3D;y</p>
<p>关于表达式，有下面几个概念需要介绍。</p>
<p>表达式的值：对表达式中操作数进行运算得到的结果称为表达式的值；</p>
<p>表达式的类型：表达式值的数据类型即为表达式的类型；</p>
<p>表达式的运算顺序：应按照运算符的优先级从高到低的顺序进行，优先级相同的运算符按照事先约定的结合方向进行</p>
<p>表达式后面加上;，即为语句了。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>07-方法详解</title>
    <url>/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="07-方法详解"><a href="#07-方法详解" class="headerlink" title="07-方法详解"></a>07-方法详解</h1><p><strong>方法：</strong>就是将一个功能抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</p>
<p>不使用方法的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func_sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 打印一个3行，3列的矩形</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; <span class="number">3</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; <span class="number">3</span>; col++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 打印一个5行，6列的矩形</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 打印一个7行，8列的矩形</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (inti = <span class="number">0</span>; i&lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007200513995.png" class="" title="image-20221007200513995">







<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表）｛</span><br><span class="line">        代码...   </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>定义格式解释：</p>
<p>　　修饰符： 目前固定写法 public static 。后面还会学习其它的修饰符<br>　　返回值类型： 目前固定写法 void ，其他返回值类型在后面遇到再说。<br>　　方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法。<br>　　参数列表： 目前无参数， 带有参数的方法在后面遇到再说。<br>　　<strong>return：方法结束。因为返回值类型是void，方法大括号内的return可以不写。或者写成return;也是可以的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodName</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这是一个方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><p>方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法main中来调用我们自己定义好的方法。在主方法中，直接写要调用的方法名字并加上括号就可以调用了。</p>
<p><strong>注意，方法如果不调用，它是不会进入到方法调用栈进行执行的，只是在代码区中存放的死的代码而已。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//调用定义的方法method</span></span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义方法，被main方法调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;自己定义的方法，需要被main调用运行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，Java中将要调用的方法定义在主方法后面也是没有问题的，Java编译器能够识别到它编译通过，并且执行的时候，从上到下执行也是能够搜寻到它的。</strong></p>
<p><strong>方法定义注意事项：</strong><br>　　<strong>方法必须定义在一类中，方法外</strong>。<strong>在Java中，所有内容组织都是以类为最小单位的，不能够脱离类而单独存在。</strong><br>　　<strong>方法不能定义在另一个方法的里面，方法不支持嵌套定义。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//正确写法，类中，main方法外面可以定义方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//错误写法，一个方法不能定义在另一方法内部，不支持嵌套定义</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JShell脚本工具"><a href="#JShell脚本工具" class="headerlink" title="JShell脚本工具"></a>JShell脚本工具</h2><p><strong>JShell脚本工具是JDK9的新特性</strong><br>　　什么时候会用到 JShell 工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运行，这个时候可以使用JShell工具。<br>　　启动JShell工具，在DOS命令行直接输入JShell命令。</p>
<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007193143874.png" class="" title="image-20221007193143874">



<p>接下来可以编写Java代码，无需写类和方法，直接写方法中的代码即可，同时无需编译和运行，直接回车即可</p>
<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007193215249.png" class="" title="image-20221007193215249">

<p>JShell工具，只适合片段代码的测试，开发更多内容，建议编写在方法中。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="x3D-符号的扩展"><a href="#x3D-符号的扩展" class="headerlink" title="+&#x3D;符号的扩展"></a>+&#x3D;符号的扩展</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="type">short</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  s+=<span class="number">1</span>;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析： s +&#x3D; 1 逻辑上看作是 s &#x3D; s + 1 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能将取值范围大的类型赋值到取值范围小的类型。但是， s&#x3D;s+1进行两次运算 ， <strong>+&#x3D; 是一个运算符，只运算一次，并带有强制转换的特点，</strong>也就是说 s +&#x3D; 1 就是 s &#x3D; (short)(s + 1) ，因此程序没有问题编译通过，运行结果是2.</p>
<h3 id="常量和变量的运算"><a href="#常量和变量的运算" class="headerlink" title="常量和变量的运算"></a>常量和变量的运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  <span class="type">byte</span> b1=<span class="number">1</span>;</span><br><span class="line">  <span class="type">byte</span> b2=<span class="number">2</span>;</span><br><span class="line">  <span class="type">byte</span> b3=<span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">  <span class="type">byte</span> b4=b1 + b2;</span><br><span class="line">  System.out.println(b3);</span><br><span class="line">  System.out.println(b4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析： b3 &#x3D; 1 + 2 ， 1 和 2 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 1+2 的结果并没有超过byte类型的取值范围，可以赋值给变量 b3 ，因此 b3&#x3D;1 + 2 是正确的。<br>反之， b4 &#x3D; b1 + b2 ， b1 和 b2 是变量，变量的值是可能变化的，在编译的时候，编译器javac不确定b1+b2的结果是什么，编译器只是知道b1和b2的类型都是byte，因此会将b1和b2自动类型转换为int进行相加运算，结果为int的，会将结果以int类型进行处理，所以int类型不能赋值给byte类型，因此编译失败。</p>
<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007193940901.png" class="" title="image-20221007193940901">



<h2 id="方法进阶"><a href="#方法进阶" class="headerlink" title="方法进阶"></a>方法进阶</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问控制符] [修饰符] 返回值类型 方法名( 参数类型 形式参数,参数类型 形式参数,…) </span><br><span class="line">&#123; </span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数列表)&#123;</span><br><span class="line"><span class="comment">//代码省略...</span></span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修饰符： public static 固定写法，目前这样写，后续学习其它修饰符<br>返回值类型： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者。如果没有返回值，可以定义为void。<br>参数列表：方法在运算过程中的未知数据，调用者调用方法时传递。参数列表是可选的，可以为空。参数可以是0个或者多个，多个参数之间使用逗号分割。<br>return：将方法执行后的结果带给调用者，方法执行到 return ，整体方法运行结束。</p>
<p><strong>注意：参数列表中的参数，称之为“形参”。调用该方法传递的参数，称之为“实参”</strong></p>
<p><strong>定义方法的两个明确，即要确定参数列表和返回值类型</strong></p>
<p> <strong>明确返回值类型</strong></p>
<p> <strong>明确参数列表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用方法getSum，传递两个整数，这里传递的实际数据又称为实际参数</span></span><br><span class="line">        <span class="comment">// 并接收方法计算后的结果，返回值     </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义计算两个整数和的方法</span></span><br><span class="line"><span class="comment">    返回值类型，计算结果是int</span></span><br><span class="line"><span class="comment">    参数：不确定数据求和，定义int参数.参数又称为形式参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007194517802.png" class="" title="image-20221007194517802">





<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比较两个整数是否相同</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法compare，传递两个整数</span></span><br><span class="line">        <span class="comment">//并接收方法计算后的结果，布尔值</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">bool</span> <span class="operator">=</span> compare(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">        System.out.println(bool);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义比较两个整数是否相同的方法</span></span><br><span class="line"><span class="comment">        返回值类型，比较的结果布尔类型</span></span><br><span class="line"><span class="comment">        参数：不确定参与比较的两个整数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">计算<span class="number">1</span>+<span class="number">2</span>+<span class="number">3.</span>..+<span class="number">100</span>的和</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法getSum</span></span><br><span class="line">        <span class="comment">//并接收方法计算后的结果，整数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum();</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定义计算1~100的求和方法</span></span><br><span class="line"><span class="comment">        返回值类型，计算结果整数int</span></span><br><span class="line"><span class="comment">        参数：没有不确定数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//定义变量保存求和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从1开始循环，到100结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">实现不定次数打印</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//调用方法printHelloWorld，传递整数</span></span><br><span class="line">        printHelloWorld(<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义打印HelloWorld方法</span></span><br><span class="line"><span class="comment">    返回值类型，计算没有结果 void</span></span><br><span class="line"><span class="comment">    参数：不确定打印几次</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHelloWorld</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;HelloWorld&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="定义方法的注意事项"><a href="#定义方法的注意事项" class="headerlink" title="定义方法的注意事项"></a>定义方法的注意事项</h2><p><strong>定义位置，类中，其它方法外面。不支持嵌套定义</strong><br><strong>返回值类型，必须要和 return 语句返回的类型相同，否则编译失败</strong> 。</p>
<p><strong>对于return后面的值可以自动类型转换为定义方法时指定的返回值类型的，则不会报错，例如，return的是byte类型，然后返回值类型定义为int。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回值类型要求是int</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;<span class="comment">// 正确，int类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.2</span>;<span class="comment">// 错误，类型不匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 错误，类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能在 return 后面写代码， return 意味着方法结束，所有后面的代码永远不会执行，属于无效代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);<span class="comment">// 错误，return已经结束，这里不会执行，无效代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="调用方法的三种形式"><a href="#调用方法的三种形式" class="headerlink" title="调用方法的三种形式"></a>调用方法的三种形式</h2><h3 id="直接调用：直接写方法名调用"><a href="#直接调用：直接写方法名调用" class="headerlink" title="直接调用：直接写方法名调用"></a>直接调用：直接写方法名调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;方法被调用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="赋值调用：调用方法，在方法前面定义变量，接收方法返回值"><a href="#赋值调用：调用方法，在方法前面定义变量，接收方法返回值" class="headerlink" title="赋值调用：调用方法，在方法前面定义变量，接收方法返回值"></a>赋值调用：调用方法，在方法前面定义变量，接收方法返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> getSum(<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="输出语句调用：在输出语句中调用方法"><a href="#输出语句调用：在输出语句中调用方法" class="headerlink" title="输出语句调用：在输出语句中调用方法"></a>输出语句调用：在输出语句中调用方法</h3><p>在输出语句中调用方法， System.out.println(方法名()) 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(getSum(<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能用输出语句调用 void 类型的方法。因为方法执行后没有结果，也就打印不出任何内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(printHello());<span class="comment">// 错误，不能输出语句调用void类型方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printHello</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果方法返回一个值，对方法的调用通常就当做一个值处理。<br>如果方法返回void，对方法的调用应是当做语句处理。</p>
<p>所谓调用方法，其实就是给方法的入口传入一些值（参数），然后在出口得到方法执行的结果（返回值）。给方法传入参数的过程，称为“传参”。实际上，方法传参的过程就是把实参赋值给对应的形参的过程，并且实参和形参的数量、类型必须匹配。</p>
<ul>
<li>形参必须注明数据类型</li>
<li>实参直接写，不需要类型声明</li>
<li>return只能返回一次</li>
<li>遇到return语句，方法结束执行，后续语句不执行</li>
<li>方法的返回值，必须与方法声明中的返回值类型匹配</li>
<li>方法定义，不能写在main()中</li>
<li>方法的定义是不能嵌套的</li>
</ul>
<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007203513036.png" class="" title="image-20221007203513036">



<h2 id="方法调用的值传递（简单类型或者叫做基本类型）和引用传递（引用类型）"><a href="#方法调用的值传递（简单类型或者叫做基本类型）和引用传递（引用类型）" class="headerlink" title="方法调用的值传递（简单类型或者叫做基本类型）和引用传递（引用类型）"></a>方法调用的值传递（简单类型或者叫做基本类型）和引用传递（引用类型）</h2><img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007203757588.png" class="" title="image-20221007203757588">



<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Func_sample2</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 打印一个n行，m列的矩形</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">printRectangle</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        printRectangle(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        printRectangle(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        printRectangle(<span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/07/Java/JavaSE/07-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/image-20221007201729233.png" class="" title="image-20221007201729233">



<h2 id="方法分类"><a href="#方法分类" class="headerlink" title="方法分类"></a>方法分类</h2><p><strong>根据参数个数：</strong></p>
<ul>
<li>无参方法</li>
<li>有参方法</li>
</ul>
<p><strong>根据返回值类型:</strong></p>
<ul>
<li>有返回值的方法</li>
</ul>
<p>​			根据返回值的类型细分为：</p>
<p>​						基本数据类型<br>​						引用数据类型</p>
<ul>
<li>无返回值的方法</li>
</ul>
<p>​			void</p>
<p><strong>无返回值，无入参的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">drawRect</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> width=<span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> height=<span class="number">5</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;width;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>无返回值，有入参的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getBigger</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y )</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>( x&gt;=y ) &#123; </span><br><span class="line">             System.out.println( x ); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">             System.out.println( y ); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//没有返回值，return可以省略</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>有返回值，无入参的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">100</span>;</span><br><span class="line">		<span class="type">int</span> y=<span class="number">200</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span>x+y;</span><br><span class="line">		<span class="keyword">return</span> z;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><strong>有返回值，有入参的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionDemo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">absolut</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x; </span><br><span class="line">         &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -x;</span><br><span class="line">         &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p><strong>方法重载：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。</strong><br>参数列表：个数不同，数据类型不同，顺序不同。<br>重载方法调用：JVM通过方法名和方法的参数列表，来确定要调用的方法，从而调用不同的方法。</p>
<p><strong>注意：方法名相同，参数个数不同，数据类型不同，顺序不同，构成重载，与其它都无关。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">比较两个数据是否相等。参数类型分别为两个 <span class="type">byte</span> 类型，两个 <span class="type">short</span> 类型，两个 <span class="type">int</span> 类型，两个 <span class="type">long</span> 类型，并</span><br><span class="line">在 main 方法中进行测试。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//定义不同数据类型的变量</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        System.out.println(compare(a, b));</span><br><span class="line">        System.out.println(compare(c, d));</span><br><span class="line">        System.out.println(compare(e, f));</span><br><span class="line">        System.out.println(compare(g, h));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 两个byte类型的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">byte</span> a, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;byte&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 两个short类型的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">short</span> a, <span class="type">short</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;short&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 两个int类型的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;int&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 两个long类型的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a == b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">判断哪些方法是重载关系。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> i,<span class="type">double</span> d)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">OPEN</span><span class="params">()</span>&#123;&#125; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;&#125; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">模拟输出语句中的 println 方法效果，传递什么类型的数据就输出什么类型的数据，只允许定义一个方法名</span><br><span class="line">println 。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Method_Demo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">byte</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">short</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">long</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">float</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">double</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">char</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(<span class="type">boolean</span> a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String a)</span> &#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>05-流程控制语句</title>
    <url>/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="05-流程控制语句"><a href="#05-流程控制语句" class="headerlink" title="05-流程控制语句"></a>05-流程控制语句</h1><p><strong>顺序结构：代码从上向下执行。</strong></p>
<p><strong>选择结构</strong></p>
<p><strong>循环结构</strong></p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>在Java语言中，条件语句主要有两类语法：if语句和switch语句</p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p><strong>if语句（单一条件）</strong></p>
<p>该类语句的语法格式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式) &#123;</span><br><span class="line">执行语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005193048890.png" class="" title="image-20221005193048890">



<p><strong>语法说明：</strong></p>
<ol>
<li>if是该语句中的关键字，后续小括号不可省略；</li>
<li>条件表达式返回的结果为布尔型，当返回为真值时才能执行if功能代码；</li>
<li><strong>功能代码块为多行时，应将其放在花括号”{}”中间，当功能代码块为单行时，则不需要花括号；</strong></li>
<li><strong>不论if语句块是单行还是多行，建议都用花括号”{}”括起来；</strong></li>
<li>if()子句后不能跟分号”;”。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">If_sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x等于1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;x的值为&quot;</span>+x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204105922.png" class="" title="image-20221005204105922">



<p><strong>if语句(二选一)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    功能代码块<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    功能代码块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204132567.png" class="" title="image-20221005204132567">

<p><strong>如果功能代码1和2只有一句，则不需要加花括号”{}”。</strong></p>
<p><strong>语法说明：</strong></p>
<p>if-else语句的代码执行过程等价于 三目条件运算符。</p>
<p>变量 &#x3D; 布尔表达式 ? 语句1:语句2</p>
<p>如果布尔表达式的值为true，则执行语句1</p>
<p>如果布尔表达式的值为false，则执行语句2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">If_Sample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;n是奇数&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;条件表达式返回值为真&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;n不是奇数&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;条件表达式返回值为假&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204143342.png" class="" title="image-20221005204143342">





<p>当有多个if在程序的语句中存在时，else与最近的if匹配。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">2</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    功能代码块<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，else对应条件表达式2，条件表达式1的if语句将独立执行。</p>
<p>if语句和三元运算符的互换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//定义变量，保存a和b的较大值</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">        c = a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以上述功能改写为三元运算符形式</span></span><br><span class="line">    c = a &gt; b ? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>if语句(多选一)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">2</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">3</span>)&#123;</span><br><span class="line">    功能代码块<span class="number">3</span>;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    功能代码块n;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204154312.png" class="" title="image-20221005204154312">

<p><strong>语法说明：</strong></p>
<ol>
<li>else if是else和if两个关键字，中间使用空格进行间隔；</li>
<li>条件表达式返回值都是布尔类型；</li>
<li>else if语句可以有任意多句；</li>
<li><strong>最后的else语句为可选；</strong></li>
<li><strong>如果功能代码部分只有一条语句而不是语句块，花括号”{}”可以省略。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">If_Sample3</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">55</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">100</span> &amp;&amp; i &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是A&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是B&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是C&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是D&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成绩是E&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005204433192.png" class="" title="image-20221005204433192">





<h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">   <span class="keyword">case</span> 取值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">   <span class="keyword">case</span> 取值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">   ......</span><br><span class="line">   <span class="keyword">case</span> 取值n:</span><br><span class="line">        语句块n;</span><br><span class="line">        [<span class="keyword">break</span>;]</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">        语句块n+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>语法说明：</strong></p>
<ol>
<li><strong>表达式的类型只能为byte、short、char、int、enum（枚举），在Java7中增加了对String类型的支持；</strong></li>
<li>case语句是标号语句，只确定程序的入口；</li>
<li><strong>值1、值2……值n只能为常数或常量，不能为变量，而且值不能重复；</strong></li>
<li>功能代码部分可以写任意多句；</li>
<li>break关键字结束switch语句，为可选项；</li>
<li>default语句功能类似于if-else语句中的else。</li>
</ol>
<p><strong>注意，continue语句不能用于Switch中。</strong></p>
<p><strong>break有两个地方可以使用，Switch中，循环语句中。</strong></p>
<p><strong>switch语句的代码执行过程为：</strong></p>
<p>将case语句后的值和表达式的值比较，若相等即从该case语句开始向下执行，如果没有break语句，则一直执行到switch语句的结束，如果遇到break语句，则结束switch语句的执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch_sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Block A&quot;</span>);</span><br><span class="line">            result = n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Block B&quot;</span>);</span><br><span class="line">            result = n * n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;Block C&quot;</span>);</span><br><span class="line">            result = n * n * n;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;result=&quot;</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005212718524.png" class="" title="image-20221005212718524">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch_sample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">switch</span> (score / <span class="number">10</span>) &#123;<span class="comment">//注意，这里可以是表达式，但是表达式的运算结果必须是byte，short，int，char，String</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为A&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为B&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为C&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为D&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;成绩等级为E&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005212917127.png" class="" title="image-20221005212917127">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Switch_</span> sample3 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Finally Friday!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Super Saturday!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Sleepy Sunday!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;I hope for my Weekend!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213022570.png" class="" title="image-20221005213022570">





<p>case的穿透性 ：</p>
<p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运行，直到遇到break，或者整体switch结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      System.out.println(<span class="string">&quot;执行case0&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">      System.out.println(<span class="string">&quot;执行case5&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">      System.out.println(<span class="string">&quot;执行case10&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      System.out.println(<span class="string">&quot;执行default&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序中，执行case5后，由于没有break语句，程序会一直向后走，不会在判断case，也不会理会前面的break，直接运行完整体switch。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213147397.png" class="" title="image-20221005213147397">

<p><strong>while语句的代码执行过程为：</strong></p>
<p>首先判断循环条件，如果循环条件为true，则执行循环体代码，然后再判断循环条件，直到循环条件不成立时停止执行。如果首先判断循环条件就为false，则不执行循环体，直接执行while语句后续的代码。</p>
<p><strong>语法说明：</strong></p>
<ol>
<li>循环条件的类型为布尔类型，指循环成立的条件；</li>
<li><strong>花括号{}不是必须的，当循环体中只有一条语句时，可以省略；</strong></li>
<li>循环体是需要重复执行的代码。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line">  <span class="keyword">while</span>(布尔表达式②)&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程<br>　　执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<br>　　①负责完成循环变量初始化。<br>　　②负责判断是否满足循环条件，不满足则跳出循环。<br>　　③具体执行的语句。<br>　　④循环后，循环变量的变化情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">While_sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213401677.png" class="" title="image-20221005213401677">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">While_sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            x++;</span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213438605.png" class="" title="image-20221005213438605">



<p><strong>使用while语句计算1+2+3+…+10的和。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">While_Sum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1+2+...+10=&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005213903586.png" class="" title="image-20221005213903586">



<p><strong>使用while语句计算从1到100的所有奇数相加。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">While_OddSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">            	sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1到100之间的奇数和为&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214313314.png" class="" title="image-20221005214313314">



<h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do-while语句"></a>do-while语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214421763.png" class="" title="image-20221005214421763">

<p><strong>语法说明：</strong></p>
<ol>
<li>循环体是重复执行的代码部分，循环条件要求是布尔类型，值为true时执行循环体，否则循环结束，最后整个语句以分号结束；</li>
<li>do-while语句是 “先循环再判断”的流程控制结构。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化表达式①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体③</span><br><span class="line">    步进表达式④</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式②);</span><br></pre></td></tr></table></figure>

<p>执行流程<br>　　执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。<br>　　①负责完成循环变量初始化。<br>　　②负责判断是否满足循环条件，不满足则跳出循环。<br>　　③具体执行的语句<br>　　④循环后，循环变量的变化情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoWhile_sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">            x++;</span><br><span class="line">        &#125; <span class="keyword">while</span>(x&lt;<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214550405.png" class="" title="image-20221005214550405">





<p><strong>使用do-while语句计算从1到100的所有奇数相加。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoWhile_OddSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            	sum += i;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt;= <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;1到100之间的奇数和为&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214659459.png" class="" title="image-20221005214659459">





<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line">循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005214747630.png" class="" title="image-20221005214747630">

<p><strong>for语句的代码执行过程为：</strong></p>
<ol>
<li>执行表达式1，实现初始化；</li>
<li>执行表达式2，判断循环条件是否成立，如果循环条件为false，则结束循环，否则执行下一步；</li>
<li>执行循环体；</li>
<li>执行表达式3，完成迭代；</li>
<li>跳转到步骤2重复执行。</li>
</ol>
<p><strong>语法说明：</strong></p>
<ol>
<li>表达式1用于初始化，一般书写变量初始化的代码，例如循环变量的声明、赋值等，它在for语句中执行且只执行一次。<strong>表达式1可以为空；</strong></li>
<li><strong>表达式2是循环条件，要求必须为布尔类型，如果该条件为空，则默认为true，即条件成立；</strong></li>
<li><strong>表达式3为迭代语句，</strong>是指循环变量变化的语句，一般书写i++、i–这样的结构。<strong>该语句可以为空。</strong></li>
<li>循环体指循环重复执行的功能代码。</li>
<li><strong>花括号{}不是必须的，当循环体部分只有一条语句时可以省略。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式①; 布尔表达式②; 步进表达式④)&#123;</span><br><span class="line">        循环体③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行流程<br>　　执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。<br>　　①负责完成循环变量初始化<br>　　②负责判断是否满足循环条件，不满足则跳出循环<br>　　③具体执行的语句<br>　　④循环后，循环条件所涉及变量的变化情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For_Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;<span class="number">3</span>;x++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x=&quot;</span>+x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215107319.png" class="" title="image-20221005215107319">



<p><strong>用for循环改写从1到100的所有奇数相加的和。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For_OddSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;1到100之间的奇数和为&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215151061.png" class="" title="image-20221005215151061">





<p><strong>注意：</strong></p>
<p>Java中的for：<br>for (int i &#x3D; 0;i &lt; 10;i++)<br>{ }<br><strong>注意，这里的i的作用域范围就是在for内部，出了for之外，看不到这个i。</strong>因为这里定义的i是在for的()中定义的i等同于如下</p>
<p>for(){</p>
<p>int i</p>
<p>}</p>
<p><strong>即等同于在for的{}大括号内部定义的i，属于局部变量。</strong></p>
<p><strong>{}表示代码块或者叫做语句块，属于局部范围，内部定义的变量属于局部变量。</strong></p>
<p>c中不是这样，c中这个i出了for仍然能够看到。</p>
<p>for 和 while 的小区别：<br>　　控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消失，能够提高内存的使用效率。<br>　　在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while。</p>
<h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>如果循环条件永远为真，那么这样的循环就是死循环，一般情况下都要在代码中避免死循环的出现。</p>
<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215255185.png" class="" title="image-20221005215255185">

<p>for的条件部分为空，默认就是true。</p>
<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215313201.png" class="" title="image-20221005215313201">

<p>for(;;){}即可构成死循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfinitiveForExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;停不下来。。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p><strong>问题描述：在控制台中用星号”*”输出如下样式的图形</strong></p>
<p>***</p>
<p>***</p>
<p>***</p>
<p>当没有学习循环语句时，可以使用打印语句实现，实现方式如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiplication_Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>学习了循环之后可以实现如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiplication_Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;***&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用嵌套循环可以实现如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Multiplication_Sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;=<span class="number">3</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>控制台打印九九乘法表</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiplicationTable1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.print(i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+i*j+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();<span class="comment">//换行</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005215702671.png" class="" title="image-20221005215702671">



<h3 id="循环的中断"><a href="#循环的中断" class="headerlink" title="循环的中断"></a>循环的中断</h3><p>在使用循环语句时，只有循环条件表达式的值为false时，才能结束循环。有时，<strong>想提前中断循环</strong>，要实现这一点，只需要在循环语句块中添加break或continue语句。</p>
<p><strong>break</strong></p>
<p><strong>使用场景：终止switch或者循环</strong></p>
<p>​        <strong>在选择结构switch语句中</strong><br>　　<strong>在循环语句中</strong><br>　　<strong>离开使用场景的存在是没有意义的</strong></p>
<p>在前面switch语句的介绍中已经接触过break语句，其功能是中断switch语句的执行。</p>
<p>同样，在循环语句中，break语句的作用也是结束循环语句的执行。</p>
<ul>
<li>break语句用于终止某个语句块的执行。用在循环语句体中，可以强行退出循环。</li>
<li>break语句可以出现在while、do…while、for、switch语句体中。</li>
<li>break label语句可以出现在任何语句体中。</li>
</ul>
<p><strong>注意，break是跳出离它最近的这个循环，继续执行循环体后面的语句。如果break用在了Switch中，然后Switch外层嵌套了循环，那么break只是跳出Switch，不会跳出外层的循环的。</strong></p>
<p><strong>如果break想要跳出不是离它最近的循环，例如，跳出外层循环或者更外层的循环，那么此时就需要使用label标签了。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">menu</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        if (b == true) &#123;</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1.查询余额，2.存款，3.取款，4.修改密码，5.退出&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">nub</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">switch</span> (nub) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        System.out.println(money);</span><br><span class="line">                        decide();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        money += setmoney(money);</span><br><span class="line">                        decide();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        money -= getmoney(money);</span><br><span class="line">                        decide();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> changePwd(password);</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前密码为&quot;</span> + str);</span><br><span class="line">                        decide();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                        System.out.println(<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">                        System.exit(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">&quot;非法操作&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>例如，这里的Switch外层套了while循环，Switch中使用了break，那么该break是跳出Switch，而不会跳出外层的while的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break_Sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i, sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">666</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;从1到&quot;</span> + i + <span class="string">&quot;的和为&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005220506855.png" class="" title="image-20221005220506855">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break_Sample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005220601014.png" class="" title="image-20221005220601014">





<p><strong>带标签的break</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Break_Sample3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        label1: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.print(j+<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span> label1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005220731939.png" class="" title="image-20221005220731939">





<p><strong>continue</strong></p>
<p>continue语句虽然也完成循环的终止，但与break语句的区别在于：continue语句只跳出本次循环，但还要继续执行下一次循环；break语句则完全跳出它所在或所标记的循环。</p>
<p><strong>continue是跳过本次循环，继续执行下一次循环。因此，continue是不能够用于Switch中的，因为Switch本身就不是循环，所以，没有办法跳过本次循环的。</strong></p>
<p><strong>显示20以内的奇数。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Continue_Sample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005220939216.png" class="" title="image-20221005220939216">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Continue_Sample2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">            	<span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码的执行结果为：</p>
<p>1</p>
<p>2</p>
<p>4</p>
<p>5</p>
<p><strong>带标签的continue</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Continue_Sample3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        label1: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                System.out.print(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span> label1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005221058880.png" class="" title="image-20221005221058880">



<p>这样在执行continue语句时，就不再是终止内部循环中的本次循环，而是直接终止外部循环的本次循环，执行i++语句，进入下一次外部循环。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="水仙花"><a href="#水仙花" class="headerlink" title="水仙花"></a>水仙花</h3><p>水仙花数指一个特殊的三位数，它的各位数字的立方和与其自身相等。请输出所有的水仙花数。</p>
<p>思路：关键是将三位数的个位、十位和百位数字分别拆分出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Narcissus</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>; i &lt; <span class="number">1000</span>; i++) &#123; <span class="comment">// 循环所有三位数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i % <span class="number">10</span>; <span class="comment">// 拆分出个位数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (i / <span class="number">10</span>) % <span class="number">10</span>; <span class="comment">// 拆分出十位数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> i / <span class="number">100</span>; <span class="comment">// 拆分出百位数字</span></span><br><span class="line">            <span class="comment">// 判断立方和是否等于自身</span></span><br><span class="line">            <span class="keyword">if</span> (a * a * a + b * b * b + c * c * c == i) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="求两个自然数的最大公约数"><a href="#求两个自然数的最大公约数" class="headerlink" title="求两个自然数的最大公约数"></a>求两个自然数的最大公约数</h3><p>最大公约数指两个数字公共的约数中最大的，例如数字3的约数有1、3，数字9的约数有1、3、9，则数字3和数字9的公共约数有1和3，其中3是最大的公约数。</p>
<p>思路：假设初始值从1开始逐步增1，每次把能同时使两个数整除的值都存储起来，那么最后一个存储起来的值就是最大的约数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonDivisor1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((m % i == <span class="number">0</span>) &amp;&amp; (n % i == <span class="number">0</span>)) &#123;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第二种编程思路：设定初始值为两个数字中最小的数字，逐步减1，那么第一次得到的能同时使两个数整除的值就是最大公约数。</p>
<p>求9和12的最大公约数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonDivisor2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n &gt; m ? m : n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> result; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n % i == <span class="number">0</span>) &amp;&amp; (m % i == <span class="number">0</span>)) &#123;</span><br><span class="line">                result = i;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打印图形"><a href="#打印图形" class="headerlink" title="打印图形"></a>打印图形</h3><img src="/2022/10/05/Java/JavaSE/05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/image-20221005221819644.png" class="" title="image-20221005221819644">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StarPrint</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">1</span>; row &lt;= <span class="number">5</span>; row++) &#123; <span class="comment">// 外层循环执行换行</span></span><br><span class="line">            <span class="comment">// 打印空格的数量为5减去所在行数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">0</span>; c1 &lt; <span class="number">5</span> - row; c1++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印星号的数量为所在行数的2倍减1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">0</span>; c2 &lt; <span class="number">2</span> * row - <span class="number">1</span>; c2++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 换行</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="质数判断"><a href="#质数判断" class="headerlink" title="质数判断"></a>质数判断</h3><p>质数是只能被1和自身整除的自然数，也称素数，质数中最小的为2。所有自然数都可以被自身和1整除。</p>
<p>思路：我们只需判断一个数能否被1和自身以外的数字整除即可，大于其本身的自然数除外。若数字为n，则只需判断从2到n-1之间的所有数字，即程序只需判断该数能否被区间[2,n-1]内的某个自然数整除即可，若在区间内存在能被整除的数则说明不是质数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exponent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">29</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//布尔类型，表示是否为质数，初始值为真</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//若能够整除则不是质数</span></span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                b = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//跳出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出结果，判断是否为质数</span></span><br><span class="line">        <span class="keyword">if</span> (b) &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot;是质数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(n + <span class="string">&quot;不是质数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>06-内存和数组</title>
    <url>/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="06-内存和数组"><a href="#06-内存和数组" class="headerlink" title="06-内存和数组"></a>06-内存和数组</h1><h2 id="Java内存结构"><a href="#Java内存结构" class="headerlink" title="Java内存结构"></a>Java内存结构</h2><p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程<br>序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。<br>Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p>
<p>Java运行程序，会从OS来申请内存的。并不是将整个内存都给Java来使用。</p>
<p>Java内存主要分为5部分，目的是更加方便的管理。</p>
<h2 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a>JVM内存划分</h2><img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006101709722.png" class="" title="image-20221006101709722">

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006101752076.png" class="" title="image-20221006101752076">

<p>注意，方法区中存储的都是方法的代码等死的信息的，真正方法的运行是在栈中运行的。</p>
<p>另外，凡是在堆中创建的东西，都是有默认值的。如上。</p>
<p>数组的静态初始化虽然没有写new，但是，实际底层仍然是通过new来创建的，因此，仍然是放在堆中的。</p>
<p>上面说的栈，也叫做方法栈或者叫做方法调用栈。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006105359824.png" class="" title="image-20221006105359824">



<p>说明，当我们定义的类Student中有成员变量，这个成员变量可以是基本类型，也可以是引用类型，那么如果是基本类型的话，那么成员变量分配的内存空间就是在堆区中给对象分配的内存空间中进行分配，如果成员变量是引用类型，那么在堆区中给对象分配的内存空间中存放的就是地址了，也就是指向，那么指向的对象就是在堆区中另外的一个空间，然后当前堆区中的这个对象中存放的就是引用变量，指向另外的这个对象。</p>
<p>注意，静态方法存放的位置仍然是方法区中的对应的类的字节码中的位置。</p>
<p>另外对于String类型，new的时候，就是堆区中创建一个对象了，不会共享字符串常量池中的内容。实际上分为两步，如果new的String的字符串在字符串常量池中没有，那么首先就是在堆区中创建这个对象，然后再将这个字符串存放到字符串常量池中一份。如果new的这个字符串在字符串常量池中已经有了，那么它只会在堆区中创建这个字符串对象，不会再往字符串常量池中去添加了，因为已经有了。</p>
<p>可以看到，数组也是引用类型，不管通过new的方式，还是简化的方式进行的数组定义，它都是在堆区中创建一个对象的。然后栈区中变量指向它。</p>
<p>字符串常量池，在新版本jdk中，它放在了堆区中了。在老版本的jdk中，它是存放在代码区（方法区）中的。</p>
<h2 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h2><p>数组概念：存储相同数据类型的多个元素的容器。</p>
<p>注意，多个元素的数据类型要相同。</p>
<p>注意，在java中数组也是一个对象。</p>
<h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><h3 id="方式一-动态初始化方式"><a href="#方式一-动态初始化方式" class="headerlink" title="方式一 动态初始化方式"></a>方式一 动态初始化方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组存储的数据类型[] 数组名字 = <span class="keyword">new</span> 数组存储的数据类型[长度];</span><br></pre></td></tr></table></figure>

<p>数组定义格式详解：<br>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。<br>[] : 表示数组。<br>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。<br>new：关键字，创建数组使用的关键字。<br>数组存储的数据类型： 创建的数组容器可以存储什么数据类型。<br>[长度]：数组的长度，表示数组容器中可以存储多少个元素。<br><strong>注意：数组有定长特性，长度一旦指定，不可更改。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//此种定义方式可读性更好，表明arr变量，它的类型为int[]，即整形[]，整形数组</span></span><br><span class="line"><span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];<span class="comment">//类似c中的写法</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，不能int[5] arr或者int arr[5]这样定义，错误的。</strong></p>
<p><strong>注意，int []是类型。数组的类型。注意，不要int [4]这样，因为int []是类型，而真正开辟多大内存空间是在new后面来指定的。</strong></p>
<h3 id="方式二-静态初始化方式"><a href="#方式二-静态初始化方式" class="headerlink" title="方式二 静态初始化方式"></a>方式二 静态初始化方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[]&#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意，int[] arr &#x3D; new int[4]{1,2,3,4};这样是错误的。</strong></p>
<p>这样是不对的，因为new int[] {}这样理解为调用int []类型的构造方法的意思。</p>
<p>另外，int [] b &#x3D;new int [2] {1,2,3,4}，这样在编译的时候编译器看不出错误的，只有在执行的时候，才会发现，因此，这种语法禁止。</p>
<h3 id="方式三-静态初始化方式-简化版"><a href="#方式三-静态初始化方式-简化版" class="headerlink" title="方式三 静态初始化方式-简化版"></a>方式三 静态初始化方式-简化版</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3.</span>..&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>数组有默认值，对于数字类型，默认值为0，对于字符型，默认值为‘\u0000’，对于布尔类型，默认值为false, 对于对象类型（引用类型），默认值为null</strong></p>
<p><strong>类的成员变量，如果定义的时候，没有赋值，那么它是有一个默认值的。当生成对象的时候，成员变量就会有一个默认值。</strong></p>
<p>数组也是对象，当int[] a &#x3D;new int[4]，这样就生成了一个int类型的数组对象，那么这个元素就可以看成是对象的成员变量，也有默认值的。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006164345181.png" class="" title="image-20221006164345181">





<h2 id="数组访问"><a href="#数组访问" class="headerlink" title="数组访问"></a>数组访问</h2><p><strong>索引</strong></p>
<p>索引： 每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引(index)，可以通过数组的索引访问到数组中的元素。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数组名[索引]</span><br></pre></td></tr></table></figure>



<p><strong>长度属性</strong></p>
<p>数组的长度属性： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的长度。</p>
<p>语句为： 数组名.length ，属性length的执行结果是数组的长度，<strong>int类型结果</strong>。由次可以推断出，数组的最大索引值为 数组名.length-1 。</p>
<p><strong>注意，数组长度属性是final的常量，不可修改的，只读的。</strong></p>
<p><strong>数组长度length属性是public final int的。</strong>Length属性是final的，意思就是常量。而且length属性是在数组生成的时候，构造方法的时候赋值的。是个常量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//打印数组的属性，输出结果是5</span></span><br><span class="line">    System.out.println(arr.length);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组名[索引]&#x3D;数值，为数组中的元素赋值</strong><br><strong>变量&#x3D;数组名[索引]，获取出数组中的元素</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//定义存储int类型数组，赋值元素1，2，3，4，5</span></span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//为0索引元素赋值为6</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//获取数组0索引上的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    <span class="comment">//直接输出数组0索引元素</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组内存结构图"><a href="#数组内存结构图" class="headerlink" title="数组内存结构图"></a>数组内存结构图</h2><p>数组声明后，Java虚拟机就会给数组分配存储空间</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006164132327.png" class="" title="image-20221006164132327">

<p>数组在声明后，但是没有创建前，并没有给它分配具体的内存空间，所以这个时候访问数组会出现NullPointerException异常。我们需要在访问数组前创建数组，确定数组的长度，以便能为数组分配内存空间。</p>
<p>可以看到，此时只是栈空间中有了变量，但是堆中并没有创建数组对象，因此，没有指向。</p>
<p><strong>数组是存储多个相同类型数据的对象。数组的所有元素保存在堆内存中。 创建一个数组就是在堆中创建一个数组对象。数组创建后所有元素立即拥有默认值。索引从0开始，连续分配</strong>。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006164534875.png" class="" title="image-20221006164534875">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr);<span class="comment">//[I@5f150435</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出的结果是[I@5f150435，这个是什么呢？是数组在内存中的地址。new出来的内容，都是在堆内存中存储的，而方法中的变量arr保存的是数组的地址。</p>
<p>输出arr[0]，就会输出arr保存的内存地址中数组中0索引上的元素。</p>
<p><strong>注意，如果数组是引用类型的数组，那么数组元素（堆中存放）中存放的是引用类型数据的内存地址。而该引用类型的实际数据仍然是在堆中的，数组中的元素指向它。</strong></p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006160427884.png" class="" title="image-20221006160427884">

<p>注意，在堆中的数据都是有出事默认值的。</p>
<p>定义两个数组内存结构图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">    System.out.println(arr2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006160641814.png" class="" title="image-20221006160641814">





<p>两个变量指向一个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 定义数组，存储3个元素</span></span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">//数组索引进行赋值</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//输出3个索引上的元素值</span></span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//定义数组变量arr2，将arr的地址赋值给arr2</span></span><br><span class="line">    <span class="type">int</span>[] arr2 = arr;</span><br><span class="line">    arr2[<span class="number">1</span>] = <span class="number">9</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006160741403.png" class="" title="image-20221006160741403">

<p>注意，int类型的数组的数组元素初始值默认都是0（因为在堆区中，所以都有默认值），然后再进行赋值，将初始值覆盖。</p>
<h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><p><strong>数组遍历： 就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是 0 到 lenght-1 ，可以作为循环的条件出现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>数组的遍历还可以使用for each循环（增强型for循环）来做。</strong></p>
<p><strong>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素 : 数组或集合)&#123;  </span><br><span class="line"><span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForEachExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strs = &#123;<span class="string">&quot;沉默王二&quot;</span>, <span class="string">&quot;一枚有趣的程序员&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">沉默王二</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>



<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="数组获取最大值元素"><a href="#数组获取最大值元素" class="headerlink" title="数组获取最大值元素"></a>数组获取最大值元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">5</span>, <span class="number">15</span>, <span class="number">2000</span>, <span class="number">10000</span>, <span class="number">100</span>, <span class="number">4000</span> &#125;;</span><br><span class="line">    <span class="comment">//定义变量，保存数组中0索引的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//遍历数组，取出每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="comment">//遍历到的元素和变量max比较</span></span><br><span class="line">      <span class="comment">//如果数组元素大于max</span></span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">        <span class="comment">//max记录住大值</span></span><br><span class="line">        max = arr[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组最大值是： &quot;</span> + max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      循环中定义变量min=0最小索引</span></span><br><span class="line"><span class="comment">      max=arr.length‐1最大索引</span></span><br><span class="line"><span class="comment">      min++,max‐‐</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐) &#123;</span><br><span class="line">      <span class="comment">//利用第三方变量完成数组中的元素交换</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[min];</span><br><span class="line">      arr[min] = arr[max];</span><br><span class="line">      arr[max] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转后，遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组最大值、最小值和平均值"><a href="#数组最大值、最小值和平均值" class="headerlink" title="数组最大值、最小值和平均值"></a>数组最大值、最小值和平均值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayMax</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">          <span class="type">int</span> a[] = &#123;<span class="number">1</span>,-<span class="number">12</span>,<span class="number">33</span>&#125;;</span><br><span class="line">          <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">          <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">          <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> a[<span class="number">0</span>];        </span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">              sum = sum+a[i];</span><br><span class="line">              <span class="keyword">if</span>(a[i]&gt;max)&#123;</span><br><span class="line">                 max = a[i];</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(a[i]&lt;min)&#123;</span><br><span class="line">              	min = a[i];</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">double</span> <span class="variable">ave</span> <span class="operator">=</span> (<span class="type">double</span>)sum/<span class="number">3</span>;</span><br><span class="line">           System.out.println(<span class="string">&quot;平均值&quot;</span>+ave);</span><br><span class="line">           System.out.println(<span class="string">&quot;最大值&quot;</span>+max);</span><br><span class="line">           System.out.println(<span class="string">&quot;最小值&quot;</span>+min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006164810467.png" class="" title="image-20221006164810467">



<h3 id="数组应用例题"><a href="#数组应用例题" class="headerlink" title="数组应用例题"></a>数组应用例题</h3><p>假设队列中共有500人，每次从1开始数，数到3的人出队，下一个人接着从1开始数，编写程序找到最后剩下的人是哪一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Count3Quit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="comment">// 用布尔值来标识每个人是否出队 出队为false，未出队为true 并将每个人的初始值都赋为true</span></span><br><span class="line">       <span class="type">boolean</span> a[] = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">500</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">           a[i] = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">/*leftNum:未出队的人数 countNum:取值为1、2、3， 每次从1开始数，数到3的人出队，下一个人接着从1开始数</span></span><br><span class="line"><span class="comment">    index：数数的人的编号，取值范围0~500</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">leftNum</span> <span class="operator">=</span> a.length;</span><br><span class="line">       <span class="type">int</span> <span class="variable">countNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 循环数数，直到只剩下一个人，即leftNum的值为1</span></span><br><span class="line">       <span class="keyword">while</span> (leftNum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (a[index] == <span class="literal">true</span>) &#123;</span><br><span class="line">              countNum++;</span><br><span class="line">              <span class="keyword">if</span> (countNum == <span class="number">3</span>) &#123;</span><br><span class="line">                  countNum = <span class="number">0</span>;</span><br><span class="line">                  a[index] = <span class="literal">false</span>;</span><br><span class="line">                  leftNum--;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           index++;</span><br><span class="line">           <span class="comment">// 如果数到第500个人，index回0，又从第1个人开始数</span></span><br><span class="line">           <span class="keyword">if</span> (index == a.length) &#123;</span><br><span class="line">              index = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//循环遍历每个数数的人，找到值为true的并输出</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (a[i] == <span class="literal">true</span>)</span><br><span class="line">              System.out.println(<span class="string">&quot;最后剩下的人是第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;的人&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006165039136.png" class="" title="image-20221006165039136">







<h2 id="数组相关异常"><a href="#数组相关异常" class="headerlink" title="数组相关异常"></a>数组相关异常</h2><h3 id="数组越界异常"><a href="#数组越界异常" class="headerlink" title="数组越界异常"></a>数组越界异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行后，将会抛出 ArrayIndexOutOfBoundsException 数组越界异常。</p>
<h3 id="数组空指针异常"><a href="#数组空指针异常" class="headerlink" title="数组空指针异常"></a>数组空指针异常</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    arr = <span class="literal">null</span>;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>运行的时候会抛出 NullPointerException 空指针异常。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006162933104.png" class="" title="image-20221006162933104">



<h2 id="数组作为方法参数和返回值"><a href="#数组作为方法参数和返回值" class="headerlink" title="数组作为方法参数和返回值"></a>数组作为方法参数和返回值</h2><h3 id="数组作为方法参数"><a href="#数组作为方法参数" class="headerlink" title="数组作为方法参数"></a>数组作为方法参数</h3><p>数组作为方法参数传递，传递的参数是数组内存的地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">//调用方法，传递数组</span></span><br><span class="line">    printArray(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建方法，方法接收数组类型的参数</span></span><br><span class="line"><span class="comment">    进行数组的遍历</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006163106571.png" class="" title="image-20221006163106571">



<h3 id="数组作为方法返回值"><a href="#数组作为方法返回值" class="headerlink" title="数组作为方法返回值"></a>数组作为方法返回值</h3><p>数组作为方法的返回值，返回的是数组的内存地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//调用方法，接收数组的返回值</span></span><br><span class="line">    <span class="comment">//接收到的是数组的内存地址</span></span><br><span class="line">    <span class="type">int</span>[] arr = getArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建方法，返回值是数组类型</span></span><br><span class="line"><span class="comment">    return返回数组的地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getArray() &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">//返回数组的地址，返回到调用者</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006163240822.png" class="" title="image-20221006163240822">



<h3 id="方法传递参数时参数类型区别"><a href="#方法传递参数时参数类型区别" class="headerlink" title="方法传递参数时参数类型区别"></a>方法传递参数时参数类型区别</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    change(a, b);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    a = a + b;</span><br><span class="line">    b = b + a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值，实际上传递的仍然是变量的值，只是这个值是地址而已。因此，在java中实际上只有一种传值方式，就是传值，只是这个值可以是普通的基本数据类型的值，也可以是引用类型变量的值（地址值）。</p>
<h2 id="数组排序与查找"><a href="#数组排序与查找" class="headerlink" title="数组排序与查找"></a>数组排序与查找</h2><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p><strong>冒泡排序（BubbleSort）</strong>的基本概念是：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。冒泡排序流程至此第一趟结束，将最大的数放到了最后。</p>
<p>在第二趟：仍从第一对数开始比较（因为可能由于第2个数和第3个数的交换，使得第1个数不再小于第2个数），将小数放前，大数放后，一直比较到倒数第二个数（倒数第一的位置上已经是最大的），第二趟结束，在倒数第二的位置上得到一个新的最大数（其实在整个数列中是第二大的数）。如此下去，重复以上过程，直至最终完成排序。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006165740950.png" class="" title="image-20221006165740950">

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006165801694.png" class="" title="image-20221006165801694">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array_BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  趟i:  1,2,3,... arr.length-1</span></span><br><span class="line"><span class="comment">		 *  </span></span><br><span class="line"><span class="comment">		 *  每趟次数 j：   i=1  j=5(0,1,2,3,4)</span></span><br><span class="line"><span class="comment">		 *           i=2  j=4(0,1,2,3)</span></span><br><span class="line"><span class="comment">		 *           i=3  j=3</span></span><br><span class="line"><span class="comment">		 *           </span></span><br><span class="line"><span class="comment">		 *                j=arr.length-i-1</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)<span class="comment">//趟</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-i;j++)<span class="comment">//次</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//交换位置</span></span><br><span class="line">					<span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">					arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="comment">//打印数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组元素查找"><a href="#数组元素查找" class="headerlink" title="数组元素查找"></a>数组元素查找</h3><p>二分查找的前提是需要查找的<strong>数组必须是已排序的</strong>，这里实现默认前提为升序。</p>
<p>查找时将数组分为三部分，依次是<strong>中值（所谓的中值就是数组中间位置的那个值）前，中值，中值后</strong>；将要查找的值和数组中的值进行比较，若小于中值则在中值前面找，若大于中值则在中值后面找，等于中值时直接返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                   <span class="type">int</span>[] sort = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">// 需要查找的值</span></span><br><span class="line">                   <span class="type">int</span> <span class="variable">locale</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// 记录 查找位置的变量</span></span><br><span class="line">                   <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> sort.length - <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">while</span> (high &gt;= low) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> (key &lt; sort[mid])</span><br><span class="line">                                     high = mid - <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (key == sort[mid]) &#123;</span><br><span class="line">                                     locale = mid;</span><br><span class="line">                                     <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span></span><br><span class="line">                                     low = mid + <span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (locale == -<span class="number">1</span>)</span><br><span class="line">                            System.out.println(<span class="string">&quot;数组中不存在元素&quot;</span> + key);</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;元素&quot;</span> + key + <span class="string">&quot;在数组中的下标是&quot;</span> + locale);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006170757245.png" class="" title="image-20221006170757245">





<h2 id="数组操作（使用工具类）"><a href="#数组操作（使用工具类）" class="headerlink" title="数组操作（使用工具类）"></a>数组操作（使用工具类）</h2><h3 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h3><p>使用System.arraycopy。</p>
<p> System.arraycopy(source,srcPos,dest,destPos,length)</p>
<p>复制source数组中从下标srcPos开始的length个元素到目标数组dest，并从目标数组的下标为destPos的位置开始储存 ，其中各个参数的含义如下：</p>
<p>@source： 源数组  </p>
<p>@srcPos： 源数组中的起始位置 </p>
<p>@dest： 目标数组 </p>
<p>@destPos：目标数组中的起始位置 </p>
<p>@length： 要复制的数组元素的个数</p>
<p><strong>复制数组{1,2,3,4,5}中从下标0开始的5个元素到目标数组{6,7,8,9,10,11,12,13,14,15}，并从目标数组的下标为0的位置开始储存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array_copy</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">                   <span class="type">int</span> aa[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">                   <span class="type">int</span> bb[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span> &#125;;</span><br><span class="line">                   System.arraycopy(aa, <span class="number">0</span>, bb, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; aa.length; i++) &#123;</span><br><span class="line">                            System.out.print(aa[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println();</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bb.length; j++) &#123;</span><br><span class="line">                            System.out.print(bb[j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006171052217.png" class="" title="image-20221006171052217">





<h3 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h3><p>Arrays.sort(数组名)为数组排序的操作。但这个方法在 java.util 这个包里面,所以在用到的时候需要先将它导入。<br>Arrays.sort方法有两种常用方式，具体参数如下：<br>Arrays.sort(arr_name)<br>Arrays.sort(arr_name,fromIndex,toIndex)</p>
<p>arr_name：数组名称<br>fromIndex：排序的起始下标<br>toIndex：排序的终止下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArraySort_sample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span>[ ] point = &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        Arrays.sort(point);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;point.length;i++)&#123;</span><br><span class="line">            System.out.print(point[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006171303036.png" class="" title="image-20221006171303036">





<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>如果一维数组中的每一个元素也是一个数组，那么就是二维数组。以此类推，还可以有多维数组。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006172904195.png" class="" title="image-20221006172904195">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//给二维数组赋值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num[i].length;j++)&#123;</span><br><span class="line">        num[i][j] = i+j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num[i].length;j++)&#123;</span><br><span class="line">        System.out.print(num[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意，二维数组在内存中存储的时候是线性存储的，不是表的形式的。因为内存本身就是线性的。<strong>内存一个字节（8bit）就是一个单元</strong>，然后一个单元一个单元挨着的，因此是线性的。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006173144733.png" class="" title="image-20221006173144733">



<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006173649284.png" class="" title="image-20221006173649284">

<p>注意，数组名代表了数组首地址，因此，一维数组，那么数组名就是数组首地址，也就是arr[0]的地址。</p>
<p>二维数组，就是数组的数组，也就是每个元素本身又是一个一维数组。</p>
<p>如上，arr二维数组，首先看成是一维数组，元素为arr[0]，arr[1]，arr[2]，然后每个元素arr[0]，它本身又是一个一维数组，因此，arr[0]就表示了这个一维数组了，它就是这个一维数组的数组名了，表示首地址，因此，arr[0]就是一维数组的首地址，也就是arr[0][0]的地址，这里将arr[0]看成是一个整体即容易理解。</p>
<p>因此，arr表示整体二维数组首地址，维度是整个二维数组长度。而arr[0]是一维数组的首地址，维度是一维数组的长度。arr和arr[0]的值都是arr[0][0]元素的地址。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006174322577.png" class="" title="image-20221006174322577">



<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006174504273.png" class="" title="image-20221006174504273">

<p>实际内存中是线性存储的。</p>
<p><strong>注意，java中可以定义列数不等的二维数组。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>&#125;, &#123;<span class="number">9</span>&#125;&#125;; <span class="comment">//注意，此时不能指定任何维度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];<span class="comment">//注意，可以这样定义，此时不能使用&#123;&#125;来给定初值，需要通过循环依次给每个元素赋值，此时列数没有指定，那么可以定义列数不等的二维数组了。</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		    <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>&#125;&#125;; </span><br><span class="line">		    System.out.println(arr);</span><br><span class="line">		    System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line">		    System.out.println(arr[<span class="number">1</span>]); </span><br><span class="line">		    System.out.println(arr[<span class="number">2</span>]); </span><br><span class="line">		    System.out.println(arr[<span class="number">3</span>]); </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[I@6815ee24</span><br><span class="line">[I@77c5b2de</span><br><span class="line">[I@54624a40</span><br><span class="line">[I@f8db08</span><br><span class="line">[I@51f3eab7</span><br></pre></td></tr></table></figure>

<p>@:分隔符<br>6815ee24：十六进制内存地址<br>I：int 数组中存储的数据类型<br>[[： 几个中括号就代表几维数组</p>
<p><strong>这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。</strong></p>
<p>通过实验可以看到，java中二维数组不是线性存储的。而是以对象方式存储的。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006180131239.png" class="" title="image-20221006180131239">

<p>即如图，rating引用变量指向了一个一维数组对象，然后一维数组中每个元素又是一个引用变量指向了另一个一维数组对象。</p>
<p>C++中二维数组是连续存放的，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_arr</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> array[<span class="number">2</span>][<span class="number">3</span>] = &#123; </span><br><span class="line">  &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, </span><br><span class="line">  &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; </span><br><span class="line">    &#125;; </span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; endl; </span><br><span class="line">    cout &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; &amp;array[<span class="number">1</span>][<span class="number">2</span>] &lt;&lt; endl; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">test_arr</span>(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffee4065820 0x7ffee4065824 0x7ffee4065828 </span><br><span class="line">0x7ffee406582c 0x7ffee4065830 0x7ffee4065834 </span><br></pre></td></tr></table></figure>

<p>注意地址为16进制，可以看出二维数组地址是连续一条线的。</p>
<p>一些录友可能看不懂内存地址，我就简单介绍一下， 0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相信数组元素地址差4个字节。</p>
<p>0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 &#x3D; c，c就是12。</p>
<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006180435570.png" class="" title="image-20221006180435570">

<p>可以看出在C++中二维数组在地址空间上是连续的。</p>
<p>像Java，Python是没有指针的，同时也不对程序员暴漏其元素的地址，寻址操作完全交给虚拟机。</p>
<p>不同编程语言的数据结构在地址中的分布方式是不一样的，C++中我们是可以直接获取元素的地址，通过实验，我们也证实了二维数组的元素确实是相邻的。</p>
<p>在其他语言中，并没有指针，也获取不到每个元素的地址，以Java为例，通过实验可以推测可能Java里的二维数组是不相邻的。</p>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><h3 id="查找二维整型数组中的最大数及其位置。"><a href="#查找二维整型数组中的最大数及其位置。" class="headerlink" title="查找二维整型数组中的最大数及其位置。"></a>查找二维整型数组中的最大数及其位置。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MulArrayMax2</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">                   <span class="type">int</span> array[][] = &#123; &#123; <span class="number">23</span>, <span class="number">2</span>, <span class="number">64</span>, <span class="number">16</span> &#125;, &#123; <span class="number">35</span>, <span class="number">56</span>, <span class="number">97</span>, <span class="number">28</span> &#125;,&#123; <span class="number">29</span>, <span class="number">10</span>, <span class="number">81</span>, <span class="number">12</span> &#125; &#125;;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                   <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">                                     <span class="keyword">if</span> (array[i][j] &gt; max) &#123;</span><br><span class="line">                                               max = array[i][j];</span><br><span class="line">                                               x = i + <span class="number">1</span>;</span><br><span class="line">                                               y = j + <span class="number">1</span>;</span><br><span class="line">                                    &#125;   </span><br><span class="line">                            &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println(<span class="string">&quot;该二维数组中最大值是:&quot;</span> + max);</span><br><span class="line">                   System.out.println(<span class="string">&quot;位置是第&quot;</span> + x + <span class="string">&quot;行，第&quot;</span> + y + <span class="string">&quot;列&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/06/Java/JavaSE/06-%E5%86%85%E5%AD%98%E5%92%8C%E6%95%B0%E7%BB%84/image-20221006181230809.png" class="" title="image-20221006181230809">





<h3 id="求最高分和学号。"><a href="#求最高分和学号。" class="headerlink" title="求最高分和学号。"></a>求最高分和学号。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 求最高分及对应的学号</span></span><br><span class="line">		<span class="type">int</span>[][] scores= &#123;&#123;<span class="number">10</span>,<span class="number">88</span>&#125;,&#123;<span class="number">20</span>,<span class="number">98</span>&#125;,&#123;<span class="number">30</span>,<span class="number">89</span>&#125;,&#123;<span class="number">40</span>,<span class="number">66</span>&#125;,&#123;<span class="number">50</span>,<span class="number">77</span>&#125;&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> scores[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> scores[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;scores.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(scores[i][<span class="number">1</span>]&gt;max)</span><br><span class="line">        	&#123;</span><br><span class="line">        		max=scores[i][<span class="number">1</span>];</span><br><span class="line">        		no=scores[i][<span class="number">0</span>];      		</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(max);</span><br><span class="line">        System.out.println(no);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>08-类、对象、封装、匿名对象</title>
    <url>/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="08-类、对象、封装、匿名对象"><a href="#08-类、对象、封装、匿名对象" class="headerlink" title="08-类、对象、封装、匿名对象"></a>08-类、对象、封装、匿名对象</h1><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p><strong>类：</strong>是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该<br>类事物。</p>
<p>现实中，描述一类事物：</p>
<p>属性：就是该事物的状态信息。</p>
<p>行为：就是该事物能够做什么。</p>
<p>举例：小猫。</p>
<p>属性：名字、体重、年龄、颜色。 行为：走、跑、叫。</p>
<p><strong>对象：</strong>是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性<br>和行为。对象即是某类事物的具体表现。</p>
<p>举例：一只小猫。</p>
<p>属性：tom、5kg、2 years、yellow。 行为：溜墙根走、蹦跶的跑、喵喵叫。</p>
<p><strong>类与对象的关系</strong></p>
<p>类是对一类事物的描述，是抽象的。</p>
<p>对象是一类事物的实例，是具体的。</p>
<p>类是对象的模板，对象是类的实体。</p>
<p><strong>事物与类的对比</strong></p>
<p>现实世界的一类事物：</p>
<p>属性：事物的状态信息。 </p>
<p>行为：事物能够做什么。</p>
<p>Java中用class描述事物也是如此：</p>
<p>成员变量：对应事物的属性</p>
<p>成员方法：对应事物的行为</p>
<p>java面向对象的语言</p>
<p>对象：真实存在唯一的事物。</p>
<p>类： 实际就是对某种类型事物的共性属性与行为的抽取。  抽象的概念….   车</p>
<p>我们从小的时候就不断的接触很多的对象，我们的大脑就会把这些具备相同属性与行为的事物进行分类。</p>
<p>在现实生活中就存在对象与类这两种事物。计算机是服务于人类，为了让计算机更加接近我们的生活，这时候就出现了面向对象的计算机语言。</p>
<p><strong>面向过程（C）                  面向对象（java）</strong></p>
<p>现实生活中 : 对象———&gt;类</p>
<p>在java中： 类————&gt;对象</p>
<p>面向对象的计算机语言核心思想： 找适合的对象做适合的事情。</p>
<p>如何找适合的对象：</p>
<pre><code>1. sun已经定义好了很多的类，我们只需要认识这些类，我们就可以通过这些类创建对象使用。 
1. 自定义类，通过自定义类来创建对象使用。
</code></pre>
<p><strong>类和对象的关系</strong></p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007231021744.png" class="" title="image-20221007231021744">





<p><strong>面向对象与面向过程</strong></p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007231047646.png" class="" title="image-20221007231047646">



<h2 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h2><p>在Java里的类分为两种：系统类和自定义类。</p>
<p>系统类就是Java自带的标准类，安装JDK后，在lib目录下，就保存了一些基本的类库，还有一些可以从网上下载。比如前面接触过的</p>
<p>System，String，BufferReader等，都是系统类。</p>
<p>自定义类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">public</span>][<span class="keyword">abstract</span>|<span class="keyword">final</span>]class 类名[extends父类][implements接口列表]</span><br><span class="line">&#123;  </span><br><span class="line">      属性声明及初始化；</span><br><span class="line">      方法声明及方法体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class之前出现了多个修饰符，这里的修饰符的作用是用来限定类的使用方式。其中：</p>
<p>public：表明此类为公有类</p>
<p>abstract：指明此类为抽象类</p>
<p>final：指明此类为终结类</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">自定义类创建对象的三步骤：</span><br><span class="line">	1. 自定义类。</span><br><span class="line">			格式：</span><br><span class="line">				class 类名&#123;</span><br><span class="line">					</span><br><span class="line">					事物的公共属性使用成员变量描述。</span><br><span class="line">					</span><br><span class="line">					事物的公共行为使用函数描述。</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">	2. 通过自定义类创建对象。</span><br><span class="line">			格式： </span><br><span class="line">				类名 变量名 =  new 类名();</span><br><span class="line">			</span><br><span class="line">	3. 访问(设置)对象的属性或者调用对象的功能。</span><br><span class="line">		1.访问对象属性的格式：</span><br><span class="line">			对象.属性名.</span><br><span class="line">		2.设置对象的属性：</span><br><span class="line">			对象.属性名 = 数据。</span><br><span class="line">		3. 调用对象的功能</span><br><span class="line">			对象.函数名();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//成员方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义类：就是定义类的成员，包括成员变量和成员方法。</p>
<p>成员变量：和以前定义变量几乎是一样的。只不过位置发生了改变。<strong>在类中，方法外。</strong></p>
<p>成员方法：和以前定义方法几乎是一样的。只不过把static去掉，static的作用在面向对象后面再详细说明。</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008112725794.png" class="" title="image-20221008112725794">





<p><strong>例子</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//事物的公共属性使用成员变量描述。</span></span><br><span class="line">	String	name; <span class="comment">//名字的属性</span></span><br><span class="line"></span><br><span class="line">	String	color; <span class="comment">//颜色属性</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> wheel;	<span class="comment">//轮子数</span></span><br><span class="line">					</span><br><span class="line">	<span class="comment">//事物的公共行为使用函数描述。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;飞快的跑起来啦...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo1</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//使用了Car类声明了一c变量， c变量指向了一个车对象。</span></span><br><span class="line"><span class="comment">		Car	c = new Car(); </span></span><br><span class="line"><span class="comment">		//设置车对象的属性值。</span></span><br><span class="line"><span class="comment">		c.name = &quot;BMW&quot;;</span></span><br><span class="line"><span class="comment">		c.color = &quot;白色&quot;;</span></span><br><span class="line"><span class="comment">		c.wheel = 4;</span></span><br><span class="line"><span class="comment">		//访问车对象的属性值</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;名字：&quot;+ c.name+&quot; 颜色:&quot;+ c.color+&quot; 轮子数：&quot;+c.wheel);</span></span><br><span class="line"><span class="comment">		c.run();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Car</span>	<span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(); </span><br><span class="line">		c1.name = <span class="string">&quot;宝马&quot;</span>;</span><br><span class="line">		<span class="type">Car</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">		c2.name = <span class="string">&quot;大众&quot;</span>;</span><br><span class="line">		c1 = c2; </span><br><span class="line">		System.out.println(<span class="string">&quot;名字：&quot;</span>+ c1.name);  <span class="comment">//大众  大众 \大众</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007230723802.png" class="" title="image-20221007230723802">





<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007230846662.png" class="" title="image-20221007230846662">



<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007230908919.png" class="" title="image-20221007230908919">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求： 使用java描述一个车与修车厂两个事物， 车具备的公共属性:轮子数、 名字、 颜色 ，还</span></span><br><span class="line"><span class="comment">具备跑的功能行为。跑之前要检测轮子是否少于了4个，如果少于了4个，那么要送到修车厂修理，</span></span><br><span class="line"><span class="comment">修车厂修理之后，车的轮子数要补回来4个。 然后车就继续的跑起来。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修车厂： 具备公共属性： 名字、 地址、 电话。</span></span><br><span class="line"><span class="comment">		 公共的行为： 修车。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">初学者的经典错误：</span></span><br><span class="line"><span class="comment">	1. 变量在同一个作用域(大括号)上是可以直接访问的。</span></span><br><span class="line"><span class="comment">	2. 如果一个类要访问另外一个类变量时，那么这时候就只能通过创建对象进行访问。（仅对于目前正确）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//车类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//事物的公共属性使用成员变量描述	</span></span><br><span class="line">	String name ; <span class="comment">// 名字</span></span><br><span class="line"></span><br><span class="line">	String color; <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> wheel; <span class="comment">//轮子数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//事物的公共行为使用函数描述</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(wheel&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">			System.out.println(name+wheel+<span class="string">&quot;个轮子飞快跑起来..&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(name+<span class="string">&quot;不够4个轮子了，赶快去修理&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修车厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CarFactory</span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name;<span class="comment">//名字</span></span><br><span class="line">	</span><br><span class="line">	String address ;	<span class="comment">//地址</span></span><br><span class="line">	</span><br><span class="line">	String tel;	<span class="comment">//电话</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//修车公共行为 ------ 返回值类型、 未知的参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repair</span><span class="params">(Car c)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(c.wheel&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;告诉你，费了很大力气修好了，给钱&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			c.wheel = <span class="number">4</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;修好了，给钱!!&quot;</span>);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//0x98</span></span><br><span class="line"><span class="comment">		Car c = new Car();</span></span><br><span class="line"><span class="comment">		//给车对象赋予属性值</span></span><br><span class="line"><span class="comment">		c.name = &quot;陆丰&quot;;</span></span><br><span class="line"><span class="comment">		c.color = &quot;黑色&quot;;</span></span><br><span class="line"><span class="comment">		c.wheel = 4;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		for(int i = 0 ; i&lt;100 ; i++)&#123;</span></span><br><span class="line"><span class="comment">			c.run();</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		c.wheel = 3;</span></span><br><span class="line"><span class="comment">		c.run();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//创建修车厂对象</span></span><br><span class="line"><span class="comment">		CarFactory f = new CarFactory();</span></span><br><span class="line"><span class="comment">		//给修车厂赋予属性值</span></span><br><span class="line"><span class="comment">		f.name = &quot;集群宝修车厂&quot;;</span></span><br><span class="line"><span class="comment">		f.address = &quot;韵泰商业广场一楼&quot;;</span></span><br><span class="line"><span class="comment">		f.tel = &quot;020-1234567&quot;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		//调用修车的修车</span></span><br><span class="line"><span class="comment">		f.repair(c);//0x98</span></span><br><span class="line"><span class="comment">		//</span></span><br><span class="line"><span class="comment">		c.run();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//需求： 调用一次repair方法。  前提： 该对象调用完一个方法之后，这个对象就不再使用了。</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>提示：类实际上是一种数据类型，叫做对象类型。类是Java中最小的单元。一切操作都需要定义在类中。</strong></p>
<h2 id="对象（实例）的使用"><a href="#对象（实例）的使用" class="headerlink" title="对象（实例）的使用"></a>对象（实例）的使用</h2><p>类是创建对象的模板，对象是类的实例</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008112848885.png" class="" title="image-20221008112848885">

<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008112919675-1665199761324-1.png" class="" title="image-20221008112919675">



<p>创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure>

<p>使用对象访问类中的成员:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象名.成员变量；</span><br><span class="line">对象名.成员方法()；</span><br></pre></td></tr></table></figure>



<p>定义一个类后，就可以定义对象了，首先要声明对象，<strong>声明对象</strong>的语法结构如下</p>
<p>类名 对象名;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee  e1;</span><br></pre></td></tr></table></figure>

<p><strong>对象的声明并没有创建对象，这只是声明了一个引用变量。并没有真正的去创建对象呢。</strong></p>
<p><strong>注意，该引用变量也是在栈区的，并且此时是null（栈区没有初始化，是随机值，是不能直接使用的）。</strong></p>
<p><strong>当然如果它本身又是另外一个类的成员变量，那么它就是在堆区中了。并且初始值是null。</strong></p>
<p>但是创建一个基本数据类型的变量如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  i ;</span><br></pre></td></tr></table></figure>

<p><strong>这条语句创建了一个变量并为该变量i分配了适当的内存空间。</strong>i变量是在栈区中的。如果是成员变量，那么就在堆区中。</p>
<ol>
<li><p>创建对象 要为对象分配内存空间，还需要创建对象，这时就要使用new关键字，创建对象的语法结构如下：</p>
<p>对象名 &#x3D; new 构造方法名(参数列表); 例如： e1&#x3D; new Employee(); 或者 e2&#x3D;new Employee(“小明”,29,3000);</p>
</li>
<li><p>声明并创建对象 对象的声明和创建可以一步完成</p>
</li>
</ol>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008173623028.png" class="" title="image-20221008173623028">



<ul>
<li><ul>
<li>栈stack：栈的存取速度比堆快，效率高。在栈内保存基本数据类型的局部变量和对象的引用值（地址值）。</li>
<li>堆heap：堆可以保存那些对空间要求较大的变量。如对象的属性和数组的元素。在堆内存中开辟空间，只能通过内存分配操作符号new，凡是出现关键字new的地方必定分配了一个堆内存。</li>
<li>我们在实例化一个对象时，同时操作了栈内存和堆内存。在栈内保存对象的首地址，即引用；在堆内存中保存了对象的属性。对对象的所有操作只能通过引用完成，一旦引用变量出栈就会被释放，没有任何引用指向该对象，对象就变成垃圾失效。</li>
</ul>
</li>
</ul>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008174027445.png" class="" title="image-20221008174027445">

<p>8种基本类型之外，都是引用类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01_Student</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建对象格式：类名 对象名 = new 类名();</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;s:&quot;</span>+s); <span class="comment">//cn.itcast.Student@100363</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//直接输出成员变量值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span>+s.name); <span class="comment">//null</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年龄：&quot;</span>+s.age); <span class="comment">//0</span></span><br><span class="line">    System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//给成员变量赋值</span></span><br><span class="line">    s.name = <span class="string">&quot;赵丽颖&quot;</span>;</span><br><span class="line">    s.age = <span class="number">18</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//再次输出成员变量的值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;姓名：&quot;</span>+s.name); <span class="comment">//赵丽颖</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年龄：&quot;</span>+s.age); <span class="comment">//18</span></span><br><span class="line">    System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用成员方法</span></span><br><span class="line">    s.study(); <span class="comment">// &quot;好好学习，天天向上&quot;</span></span><br><span class="line">    s.eat(); <span class="comment">// &quot;学习饿了要吃饭&quot;</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>成员变量默认值</strong></p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007231616432.png" class="" title="image-20221007231616432">

<p><strong>定义成员变量，如果没有给定初始值，那么编译器将会赋予默认值。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义手机类：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">  <span class="comment">// 成员变量</span></span><br><span class="line">  String brand; <span class="comment">//品牌</span></span><br><span class="line">  <span class="type">int</span> price; <span class="comment">//价格</span></span><br><span class="line">  String color; <span class="comment">//颜色</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 成员方法</span></span><br><span class="line">  <span class="comment">//打电话</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;给&quot;</span>+name+<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//发短信</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;群发短信&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">定义测试类：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02Phone</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="type">Phone</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//输出成员变量值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;品牌：&quot;</span>+p.brand);<span class="comment">//null</span></span><br><span class="line">    System.out.println(<span class="string">&quot;价格：&quot;</span>+p.price);<span class="comment">//0</span></span><br><span class="line">    System.out.println(<span class="string">&quot;颜色：&quot;</span>+p.color);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line">    <span class="comment">//给成员变量赋值</span></span><br><span class="line">    p.brand = <span class="string">&quot;锤子&quot;</span>;</span><br><span class="line">    p.price = <span class="number">2999</span>;</span><br><span class="line">    p.color = <span class="string">&quot;棕色&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//再次输出成员变量值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;品牌：&quot;</span>+p.brand);<span class="comment">//锤子</span></span><br><span class="line">    System.out.println(<span class="string">&quot;价格：&quot;</span>+p.price);<span class="comment">//2999</span></span><br><span class="line">    System.out.println(<span class="string">&quot;颜色：&quot;</span>+p.color);<span class="comment">//棕色</span></span><br><span class="line">    System.out.println(<span class="string">&quot;‐‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用成员方法</span></span><br><span class="line">    p.call(<span class="string">&quot;紫霞&quot;</span>);</span><br><span class="line">    p.sendMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一个对象调用一个成员方法的内存结构图"><a href="#一个对象调用一个成员方法的内存结构图" class="headerlink" title="一个对象调用一个成员方法的内存结构图"></a>一个对象调用一个成员方法的内存结构图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221007231930014.png" class="" title="image-20221007231930014">

<p><strong>注意，Java中的成员方法是多个对象共用的</strong>，可以理解成类似C++中的成员方法，编译之后，成为全局的方法，xx对象.yy(a,b,c)，这样调用的时候，转换为yy(xx对象,,a,b,c)，即将当前对象作为第一个隐含参数传入给yy方法内部的this引用变量，this的类型就是当前对象，xx对象的类型。因此，这个成员方法yy实际上编译之后就变成了一个在代码区中的一个全局方法了（所属类的内部的一个全局方法了），这个方法yy所属类的任何一个对象都可以调用它。</p>
<p><strong>说明：</strong></p>
<p>方法区中存放了.class文件的相关代码信息，注意，只是死的代码信息而已，真正方法的运行是要在栈中进行的。</p>
<p>首先运行，java DemoPhoneOne，JVM会找到DemoPhoneOne这个名字的class文件，即DemoPhoneOne.class，然后将其加载入代码区（方法区）中，然后解开，找到里面的类DemoPhoneOne，然后从static main作为入口运行main方法，此时main方法进入栈底部。</p>
<p><strong>Phone one，此时会在main方法调用栈中创建引用变量。此时该引用变量的值为null。</strong></p>
<p>new Phone()，创建对象，此时会在堆中创建该对象的内存空间，那么如何知道Phone这个类中有什么内容呢？需要到方法区中查看到该Phone类信息，从而知道创建的对象中都有哪些内容。因此，此时首先就在堆区中根据成员变量的类型以及个数，为对象分配对应的内存空间（注意，堆中的对象只有成员变量的部分，而不包含成员方法的）。对象空间分配之后，在堆中Phone的对象空间中创建了成员变量，并且赋予默认值，分别为，String brand为null，double price为0.0，String color为null。注意，这些都是在构造方法之前做的事，此时还没有调用构造方法呢。</p>
<p><strong>关于构造代码块，构造方法，以及显示初始化成员变量，它们的执行顺序，下节说明。</strong></p>
<p>接下来就是成员方法，对于成员方法来说，堆中Phone的对象空间中只存储了该成员方法在方法区中的地址值。因此，指向了方法区中的方法代码的地址。</p>
<p>对象构造完毕，返回对象在堆中的地址，赋值给one引用变量。</p>
<p>到此，对象构造出来。</p>
<p>接下来，3次out，输出默认值。</p>
<p>接下来，3次分别给成员变量赋值，同理，将方法区中Demo01PhoneOne.class中的main中的代码依次拿到栈中main的方法调用栈中来执行。通过one依次找到了堆中的对象，然后定位到对象中的成员变量，然后将成员变量赋值。</p>
<p>接下来，3次out，输出成员变量值。</p>
<p>接下来，one.call方法的调用，通过栈中的one找到堆中的对象，然后定位到堆中对象的存储的成员方法的地址值，然后定位到方法区中Phone.class中的的call方法代码，然后将其代码依次拿到栈中来运行，即进栈操作。注意，此时调用call方法，实际会转换为call(one)这样调用，将对象one作为第一个隐含参数传给call方法内部的this引用变量。此时栈中call在main的上方，此时开始运行call方法。当call方法运行结束之后，栈中call占据内存空间即释放销毁，因此，call的局部变量空间就会释放掉。重新回到栈中main方法中接着运行。</p>
<p><strong>注意，实际上这里是根据one变量的类型从而知道去代码区中那个类的字节码中找对应的要调用的那个全局call方法的。</strong></p>
<p><strong>对于多态的情况，也是如此，指向某个对象，那么就是运行期间知道该对象的对应的类型，从而找代码区中该类型字节码中那个要调用的全局方法的。</strong></p>
<p>接下来，one.sendMessage方法的调用，同理操作。</p>
<p>最后，当main方法运行结束之后，栈中，main方法占据的内存空间也会释放销毁。</p>
<p><strong>注意，所有的方法的运行，都是在栈中运行的，也叫做方法调用栈。</strong></p>
<p>方法区中存放的都是.class字节码中类的相关信息以及方法的相关信息，都是死的信息，运行不发生在方法区中。</p>
<p>在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量one指向堆内存中的空间，寻找方法信息，去执行该方法。</p>
<h3 id="两个对象使用同一个方法的内存结构图"><a href="#两个对象使用同一个方法的内存结构图" class="headerlink" title="两个对象使用同一个方法的内存结构图"></a>两个对象使用同一个方法的内存结构图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008092935662.png" class="" title="image-20221008092935662">



<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008093023599.png" class="" title="image-20221008093023599">

<p>实际上调用方法的时候，p.sendMessage()，首先是根据p引用变量的类型，知道它是Phone类型，因此，就到方法区的对应的Phone的class部分进行搜寻，找到了sendMessage方法，然后进行调用，sendMessage(p)，将p作为第一个隐藏参数传入。</p>
<p><strong>因此，成员方法，对于该类的所有对象来说，它就是一个全局的方法了。</strong></p>
<p>对象调用方法时，根据对象中方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。</p>
<h3 id="两个引用指向同一个对象的内存结构图"><a href="#两个引用指向同一个对象的内存结构图" class="headerlink" title="两个引用指向同一个对象的内存结构图"></a>两个引用指向同一个对象的内存结构图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008093953689.png" class="" title="image-20221008093953689">



<h3 id="使用对象类型作为方法的参数的内存结构图"><a href="#使用对象类型作为方法的参数的内存结构图" class="headerlink" title="使用对象类型作为方法的参数的内存结构图"></a>使用对象类型作为方法的参数的内存结构图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008094039732.png" class="" title="image-20221008094039732">



<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008094238926.png" class="" title="image-20221008094238926">

<p><strong>引用类型作为参数，传递的值实际上是地址值。</strong></p>
<h3 id="使用对象类型作为方法的返回值的内存图"><a href="#使用对象类型作为方法的返回值的内存图" class="headerlink" title="使用对象类型作为方法的返回值的内存图"></a>使用对象类型作为方法的返回值的内存图</h3><img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008094359863.png" class="" title="image-20221008094359863">



<h2 id="成员变量和局部变量区别"><a href="#成员变量和局部变量区别" class="headerlink" title="成员变量和局部变量区别"></a>成员变量和局部变量区别</h2><p>局部变量和成员变量</p>
<ol>
<li>定义的位置不一样【重点】<br>局部变量：在方法的内部<br>成员变量：在方法的外部，类内部，直接写在类当中</li>
<li>作用范围（作用域）不一样【重点】<br>局部变量：只有方法当中才可以使用，出了方法就不能再用<br>成员变量：整个类内部全都可以使用。类比C语言中函数和全局变量的关系</li>
<li>默认值不一样【重点】<br>局部变量：没有默认值，如果要想使用，必须手动进行赋值。如果不指定初始值，直接使用，会报错。<br>成员变量：如果没有赋值，会有默认值，规则和数组一样</li>
</ol>
<p>​		<strong>成员变量是有默认的初始值。</strong></p>
<p>​				数据类型     默认的初始值</p>
<p>​				int                 0</p>
<p>​				float              0.0f</p>
<p>​				double          0.0</p>
<p>​				boolean        false</p>
<p>​				char               ‘ ‘</p>
<p>​				String（引用数据类型） null</p>
<p>​		 <strong>局部变量是没有默认的初始值的，必须要先初始化才能使用。</strong></p>
<ol start="4">
<li>内存的位置不一样（了解）</li>
</ol>
<p>​		局部变量：位于栈内存，即位于方法调用栈中，即调用某个方法的时候，局部变量就位于这个方法所处的那个栈内存段中。</p>
<p>​		成员变量：位于堆内存</p>
<ol start="5">
<li>生命周期不一样（了解）</li>
</ol>
<p>​		局部变量：随着方法进栈而诞生，随着方法出栈而消失。局部变量在调用了对应的方法时执行到了创建该变量的语句时存在，局部变</p>
<p>​		量一旦出了自己的作用域那么马上从内存中消失。</p>
<p>​		成员变量：随着对象创建而诞生，随着对象被垃圾回收而消失</p>
<p>​		<strong>局部变量的生命周期是从进入到某一个方法体或者代码块的时候生命周期就开始了，但是它的作用域是从定义它的位置开始到方法		体或者代码块结束位置。</strong></p>
<p>成员变量整个类内部都可以使用，是说针对于某一个对象而言，例如，Person类的对象p1，那么成员变量就是该对象内部的，那对应的所有成员方法（实例方法，也叫作绑定到对象的方法）全部都可以使用它。而对于另外一个对象p2，那么就是p2这个对象中的成员变量，对于该类的所有成员方法都可以使用。因此，是分不同对象而言的。注意，这里说的这些成员方法（实例方法，也叫作绑定到对象的方法）都是同一个类的各个对象共用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01VariableDifference</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">(<span class="type">int</span> param)</span> &#123; <span class="comment">// 方法的参数就是局部变量</span></span><br><span class="line">        <span class="comment">// 参数在方法调用的时候，必然会被赋值的。所以这里直接输出局部变量不报错。</span></span><br><span class="line">        System.out.println(param);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> age; <span class="comment">// 局部变量</span></span><br><span class="line"><span class="comment">//        System.out.println(age); // 没赋值不能用，编译会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(num); // 错误写法！num作用域为methodA中，跨作用域访问，错误</span></span><br><span class="line">        System.out.println(name);<span class="comment">//成员变量，在类内部通用，谁都能访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008101506978.png" class="" title="image-20221008101506978">

<p>在类中的位置不同 重点</p>
<p>成员变量：类中，方法外</p>
<p>局部变量：方法中或者方法声明上(形式参数)</p>
<p>作用范围不一样 重点</p>
<p>成员变量：类中</p>
<p>局部变量：方法中</p>
<p>初始化值的不同 重点</p>
<p>成员变量：有默认值</p>
<p>局部变量：没有默认值。必须先定义，赋值，最后使用</p>
<p>在内存中的位置不同 了解</p>
<p>成员变量：堆内存</p>
<p>局部变量：栈内存</p>
<p>生命周期不同 了解</p>
<p>成员变量：随着对象的创建而存在，随着对象的消失而消失</p>
<p>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</p>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>匿名对象：没有引用类型变量指向的对象称作为匿名对象。</p>
<p>需求： 使用 java类描述一个学生类。</p>
<p>匿名对象要注意的事项：</p>
<ol>
<li>我们一般不会给匿名对象赋予属性值，因为永远无法获取到。</li>
<li>两个匿名对象永远都不可能是同一个对象。</li>
</ol>
<p>匿名对象好处：简化书写。</p>
<p>匿名对象的应用场景：</p>
<ol>
<li>如果一个对象需要调用一个方法一次的时候，而调用完这个方法之后，该对象就不再使用了，这时候可以使用<br> 匿名对象。</li>
<li>可以作为实参调用一个函数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line"></span><br><span class="line">	String name; <span class="comment">//名字</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;好好学习，为将来称为高帅富做准备!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">			<span class="comment">//创建一个学生对象</span></span><br><span class="line">		<span class="comment">//Student s = new Student();</span></span><br><span class="line">		<span class="comment">//new Student().name = &quot;狗娃&quot;; //匿名对象 </span></span><br><span class="line">		<span class="comment">//System.out.println(new Student().name); //null</span></span><br><span class="line">		System.out.println(<span class="keyword">new</span> <span class="title class_">Student</span>() == <span class="keyword">new</span> <span class="title class_">Student</span>()) ; <span class="comment">//false // &quot;==&quot; 用于引用类型变量时，比较的是内存地址。判断两个 对象是否为同一个对象.</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//需求： 调用Student的study方法。</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		s.study();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Student</span>().study();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用匿名对象的情况，如果对一个对象只需要进行一次方法调用，Java的垃圾回收机制是自动的，它保证程序健壮的主要手段，同时也避免了回收内存带来的代码繁琐。</p>
<p>垃圾回收机制实际上是JVM内部运行的一个优先级比较低的后台线程，这种多线程的模式使得java 具有更好的性能，完全不用程序员参与。垃圾回收机制仅仅作用于堆内存，于栈内存无关。对于程序员来说，<strong>对象何时变成垃圾呢？</strong></p>
<p><strong>对象的引用被赋值为null；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>( ); </span><br><span class="line">p = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><strong>一次性使用的匿名对象;</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>( ).sayHello( );</span><br></pre></td></tr></table></figure>

<p><strong>超出生命周期的；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">int</span> <span class="variable">I</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>( );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量p 被实例化100次，每结束一次循环，变量p就超出生命周期（也除了它的作用域了），对象变为垃圾，垃圾回收机制如下图所示</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008174908276.png" class="" title="image-20221008174908276">

<p>注意，在垃圾回收器回收对象占据的内存的时候，首先会调用对象的finalize()方法，进行一些资源的释放操作，例如，打开的文件进行关闭，占用的网络资源的释放。调用了finalize()方法之后，回收器才会回收对象占用的内存。</p>
<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>Java中主要有3种类型的变量：<br>● 局部变量：定义在方法体中的变量；或是方法的形参。</p>
<p>● 实例成员变量：即类的属性，也是类内的全局变量。</p>
<p>● 静态成员变量：在类中声明为static 的属性。</p>
<p><strong>变量作用域，作用域是指变量在程序中的可使用范围</strong></p>
<p>各种类别变量的作用域</p>
<p>● 类变量（static静态成员变量）：用static修饰的属性，它们在类被载入时创建，只要类存在，static变量就存在</p>
<p>● 实例变量：类体中声明的属性为全局变量，全局变量在类的对象的整个生命周期中都有效。</p>
<p>● 局部变量：方法体中声明的变量，方法中的参数，或代码块中声明的变量，都是局部变量，局部变量只在方法调用的过程（加载到方法调用栈中的栈内存段上）中有效，方法调用结束后失效。代码块中的局部变量，作用范围就是该代码块，出了代码块之后就失效了。</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008181237395.png" class="" title="image-20221008181237395">

<p>实例变量（类内部的全局变量）与局部变量。</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008181415774.png" class="" title="image-20221008181415774">

<p>局部变量作用域。</p>
<p>for循环头中定义的循环变量i，其作用域是整个for循环，而在循环内定义的局部变量a、b和c，它们的作用域都是<strong>从定义的地方开始，到包含它的块结束</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;局部变量 x=&quot;</span> + x);</span><br><span class="line">        System.out.println(<span class="string">&quot;全局变量 y=&quot;</span> + y);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        e.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例变量只能声明一次，但是在方法内不同的嵌套块中，可以多次声明名称相同的变量。 如果局部变量和一个实例变量同名，那么在局部变量的作用域内实例变量被隐藏。</p>
<img src="/2022/10/08/Java/JavaSE/08-%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/image-20221008181724950.png" class="" title="image-20221008181724950">













<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>面向对象三大特征：</p>
<ol>
<li>封装</li>
<li>继承</li>
<li>多态。</li>
</ol>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的<br>方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。</p>
<p><strong>原则</strong><br>将属性隐藏起来，若需要访问某个属性或者设置某个属性，提供公共方法对其访问和设置。</p>
<p><strong>封装:</strong></p>
<p><strong>权限修饰符：权限修饰符就是控制成员可见范围的。</strong></p>
<p>public :  公共的。 public修饰的成员变量或者成员方法任何人都可以直接访问。</p>
<p>private ： 私有的， private修饰的成员变量或者成员方法<strong>只能在本类中</strong>进行直接访问和使用。</p>
<p>封装的步骤：</p>
<ol>
<li>使用private修饰需要被封装的属性。</li>
<li>提供一个公共的方法设置或者获取该私有的成员属性。对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。<br> 命名规范：<br> set属性名();<br> get属性名();</li>
</ol>
<p>疑问： 封装一定要提供get或者set方法吗？<br>        不一定， 根据需求而定的。</p>
<p>规范 ： 在现实开发中一般实体类的所有成员属性（成员变量）都要封装起来。即封装为javabean。</p>
<p>实体类：实体类就是用于描述一类 事物的就称作为实体类。</p>
<p>封装的好处：</p>
<ol>
<li>提高数据的安全性。</li>
<li>操作简单。 </li>
<li>隐藏了实现。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>	String name; <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>	String sex; <span class="comment">//性别</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>	<span class="type">int</span> salary; <span class="comment">//薪水</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义一个公共的方法设置sex属性</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String s)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.equals(<span class="string">&quot;男&quot;</span>)||s.equals(<span class="string">&quot;女&quot;</span>))&#123; <span class="comment">//注意： 如果比较两个字符串的内容是否一致，不要使用==比较， 使用equals方法。</span></span><br><span class="line">			sex = s;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//默认是男</span></span><br><span class="line">			sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个公共的方法获取sex属性</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sex;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//聊天</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">talk</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;聊得非常开心&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo5</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Member</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Member</span>();</span><br><span class="line">		m.name=<span class="string">&quot;狗娃&quot;</span>;</span><br><span class="line">		m.setSex(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">		m.salary  = <span class="number">800</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+ m.name+<span class="string">&quot; 性别：&quot;</span>+ m.getSex()+<span class="string">&quot; 薪水：&quot;</span>+ m.salary);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h3><p><strong>private的含义</strong></p>
<ol>
<li>private是一个权限修饰符，代表最小权限。</li>
<li>可以修饰成员变量和成员方法。</li>
<li>被private修饰后的成员变量和成员方法，只在本类中才能访问。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">面向对象三大特征：封装、继承、多态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装性在Java当中的体现：</span></span><br><span class="line"><span class="comment">1. 方法就是一种封装</span></span><br><span class="line"><span class="comment">2. 关键字private也是一种封装</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装就是将一些细节信息隐藏起来，对于外界不可见。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Method</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">5</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">100</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(array);</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值：&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给我一个数组，我还给你一个最大值</span></span><br><span class="line">    <span class="comment">//方法就是一种封装</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。</span></span><br><span class="line"><span class="comment">解决方案：用private关键字将需要保护的成员变量进行修饰。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一旦使用了private进行修饰，那么本类当中仍然可以随意访问。</span></span><br><span class="line"><span class="comment">但是！超出了本类范围之外就不能再直接访问了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">间接访问private成员变量，就是定义一对儿Getter/Setter方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">必须叫setXxx或者是getXxx命名规则。</span></span><br><span class="line"><span class="comment">对于Getter来说，不能有参数，返回值类型和成员变量对应；</span></span><br><span class="line"><span class="comment">对于Setter来说，不能有返回值，参数类型和成员变量对应。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个成员方法，专门用于向age设置数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">100</span> &amp;&amp; num &gt;= <span class="number">9</span>) &#123; <span class="comment">// 如果是合理情况</span></span><br><span class="line">            age = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数据不合理！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个成员方法，专门私语获取age的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.show();</span><br><span class="line"></span><br><span class="line">        person.name = <span class="string">&quot;赵丽颖&quot;</span>;</span><br><span class="line"><span class="comment">//        person.age = -20; // 直接访问private内容，错误写法！</span></span><br><span class="line">        person.setAge(<span class="number">20</span>);</span><br><span class="line">        person.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于基本类型当中的boolean值，Getter方法一定要写成isXxx的形式，而setXxx规则不变。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> male; <span class="comment">// 是不是爷们儿</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMale</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">        male = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> male;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        name = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        age = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        stu.setName(<span class="string">&quot;鹿晗&quot;</span>);</span><br><span class="line">        stu.setAge(<span class="number">20</span>);</span><br><span class="line">        stu.setMale(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + stu.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄：&quot;</span> + stu.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;是不是爷们儿：&quot;</span> + stu.isMale());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 使用java类描述一个计算器类，计算器具备操作数1， 操作数2 、操作符三个公共 的属性</span></span><br><span class="line"><span class="comment">，还具备计算的功能行为。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要求： 不能直接对操作数1，操作数2，运算符这些属性进行直接 的赋值，要封装起来。 (+ - * /  )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">根据需求提供get或者set方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	需要提供set方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num1; <span class="comment">//操作数1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num2;  <span class="comment">//操作数2</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span>	<span class="type">char</span> option ; <span class="comment">//运算符</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供公共的方法设置属性值....					</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initCalculator</span><span class="params">(<span class="type">int</span> n1 , <span class="type">int</span> n2 , <span class="type">char</span> o)</span>&#123;</span><br><span class="line">		num1 = n1;</span><br><span class="line">		num2 = n2;</span><br><span class="line">		<span class="keyword">if</span>(o==<span class="string">&#x27;+&#x27;</span>||o==<span class="string">&#x27;-&#x27;</span>||o==<span class="string">&#x27;*&#x27;</span>||o==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">			option = o;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			option = <span class="string">&#x27;+&#x27;</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算的功能</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(option)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做加法运算,结果是：&quot;</span>+(num1+num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做减法运算,结果是：&quot;</span>+(num1-num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做乘法运算,结果是：&quot;</span>+(num1*num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做除法运算,结果是：&quot;</span>+(num1/num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo6</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建了一个计算器对象</span></span><br><span class="line">		<span class="type">Calculator</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">		<span class="comment">//设置属性值</span></span><br><span class="line">		c.initCalculator(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">		<span class="comment">//调用计算器的计算功能</span></span><br><span class="line">		c.calculate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>09-构造函数&amp;构造代码块&amp;static&amp;this</title>
    <url>/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&amp;%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&amp;static&amp;this/</url>
    <content><![CDATA[<h1 id="09-构造函数-amp-构造代码块-amp-static-amp-this"><a href="#09-构造函数-amp-构造代码块-amp-static-amp-this" class="headerlink" title="09-构造函数&amp;构造代码块&amp;static&amp;this"></a>09-构造函数&amp;构造代码块&amp;static&amp;this</h1><h2 id="上节内容复习"><a href="#上节内容复习" class="headerlink" title="上节内容复习"></a>上节内容复习</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对象：真实存在的唯一的事物。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">类： 同一种类型的事物公共属性与公共行为的抽取。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">java面向对象语言： </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">核心思想： 找适合的对象做适合的事情.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">找对象的方式：</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	方式一： sun已经定义好了很多了类，我们只需要认识这些类即可创建对象使用。</span></span><br><span class="line"><span class="comment">	方式二： 我们需要自定义类，通过自定义类创建对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在整理笔记的过程中对自己有疑问的概念使用代码验证或者推翻它。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">自定义类三步骤：</span></span><br><span class="line"><span class="comment">	1. 自定义一个类。</span></span><br><span class="line"><span class="comment">		  class 类&#123;</span></span><br><span class="line"><span class="comment">			事物 的公共属性 使用成员变量描述。</span></span><br><span class="line"><span class="comment">			事物的公共行为  使用函数描述。</span></span><br><span class="line"><span class="comment">		  &#125;</span></span><br><span class="line"><span class="comment">	2. 可以通过类创建对象。</span></span><br><span class="line"><span class="comment">	3. 访问(设置)对象的属性或者调用对象的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员变量与局部变量 的区别：</span></span><br><span class="line"><span class="comment">	1. 自定义的位置区别：</span></span><br><span class="line"><span class="comment">			1. 成员变量是定义在方法之外，类之内的变量。是类内部的全局变量。 </span></span><br><span class="line"><span class="comment">			2. 局部变量是声明在方法之内的变量。</span></span><br><span class="line"><span class="comment">	2. 作用上的区别： </span></span><br><span class="line"><span class="comment">			1. 成员变量的作用描述一类事物的属性。</span></span><br><span class="line"><span class="comment">			2. 局部变量的作用是提供一个变量给方法内部使用的。</span></span><br><span class="line"><span class="comment">	3. 生命周期的区别；</span></span><br><span class="line"><span class="comment">			1. 成员变量随着对象的创建而存在，随着对象的消失而消失。</span></span><br><span class="line"><span class="comment">			2. 局部变量是调用到了对应的方法执行 到了创建该变量的语句时存在，一旦出了自己的作用域马上从内存中消失。</span></span><br><span class="line"><span class="comment">	4. 初始值的区别：</span></span><br><span class="line"><span class="comment">			1. 成员变量是有默认的初始值的。</span></span><br><span class="line"><span class="comment">			2. 局部变量是没有默认的初始值的，必须要先初始化才能使用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">匿名对象： 没有引用类型变量指向的对象就称作为匿名对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名对象要注意的细节：</span></span><br><span class="line"><span class="comment">		1. 一般不会给匿名对象的属性赋值，因为永远都没法获取到。</span></span><br><span class="line"><span class="comment">		2. 两个匿名对象永远都不可能是同一个对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名对象好处：简化书写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">匿名对象的应用场景：</span></span><br><span class="line"><span class="comment">	1. 如果调用一个对象的方法一次时，然后这个对象就不再使用，那么这时候可以使用匿名对象。</span></span><br><span class="line"><span class="comment">	2. 可以作为实参调用一个函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装的步骤：</span></span><br><span class="line"><span class="comment">	1. 使用private修饰需要被封装的属性.</span></span><br><span class="line"><span class="comment">	2. 根据需要提供get或者set方法设置以及获取属性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">封装的好处：</span></span><br><span class="line"><span class="comment">	1. 提高了数据的安全性。</span></span><br><span class="line"><span class="comment">	2. 操作简单。</span></span><br><span class="line"><span class="comment">	3. 隐藏了实现。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：一般实体类的属性我们都会封装起来。	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>java是 面向对象的语言： “万物皆对象”: 任何事物都可以使用类进行描述。</p>
<p>需求： 使用java类描述 一个婴儿.</p>
<p>在现实生活中有两种婴儿， 一种婴儿一出生就具备了名字(白户)，还有一种婴儿就是 出生之后才有名字 的(黑户)。</p>
<p><strong>构造函数：</strong></p>
<p><strong>构造函数的作用： 给对应的对象进行初始化。</strong></p>
<p><strong>构造函数的定义的格式：</strong></p>
<pre><code>修饰符  函数名(形式参数)&#123;
    函数体...
&#125;
</code></pre>
<p><strong>构造函数要注意的细节：</strong></p>
<ol>
<li>构造函数 是没有返回值类型的。构造函数没有返回值。不能写void，否则变成了一个普通成员函数了。构造方法不能return一个具体的返回值，但是return;这样写是可以的。</li>
<li>构造函数的函数名必须要与类名一致。</li>
<li>构造函数并不是由我们手动调用的，而是在创建对应的对象时，jvm就会主动调用到对应的构造函数。</li>
<li>如果一个类没有显式的写上一个构造方法时，那么java编译器会为该类添加一个默认的无参的空函数体的构造函数的。</li>
<li>如果一个类已经显式的写上一个构造方法时,那么java编译器则不会再为该类添加 一个默认无参 的构造方法。</li>
<li>构造函数是可以在一个类中以函数重载的形式存在多个 的。构造函数可以重载。</li>
</ol>
<p><strong>提示：</strong>无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效，即不再提供默认无参构造方法。</p>
<p>疑问：创建对象时，jvm就会调用到对应的构造方法，那么我们以前没有学构造方法，那么以前创建对象时，jvm是否也会调用构造方法呢？如果有？构造方法从何而来呢？</p>
<p>会调用， java编译器在编译的时候给加上去的。</p>
<p>jdk提供了一个java开发工具(javap.exe)给我们进行反编译的。javap，字节码反编译工具。</p>
<p><strong>javap 反编译工具的使用格式：</strong></p>
<p><strong>javap -c -l -private 类名</strong></p>
<p>注意，javap加载的是类，不是class字节码文件。因此，后面跟的是类名，区分大小写的。</p>
<p><strong>疑问： java编译器添加 的无参构造方法的权限修饰符是 什么？</strong></p>
<p><strong>与类的权限修饰是一致的。</strong></p>
<p><strong>构造函数与普通 函数的区别：</strong>	</p>
<ol>
<li>返回值类型的区别：</li>
<li>构造函数是没有返回值类型 的。</li>
<li>普通函数是有返回值类型的，即使函数没有返回值，返回值类型也要写上void。</li>
<li>函数名的区别：</li>
<li>构造函数的函数名必须要与类名一致。</li>
<li>普通函数的函数名只要符合标识符的命名规则即可。</li>
<li>调用方式的区别：</li>
<li>构造函数是 在创建对象的时候由jvm自动进行调用的。构造函数只会被调用一次的。</li>
<li>普通函数是由我们使用对象调用的，一个对象可以调用多次普通 的函数。</li>
<li>作用上的区别：</li>
<li>构造函数 的作用用于初始化一个对象。</li>
<li>普通函数是用于描述一类事物的公共行为的。</li>
<li>修饰符不同，和普通方法一样，构造方法可以有任何访问的修饰：public，protected，private或者没有修饰。不同于普通方法的是，<strong>构造方法不能有以下非访问性质的修饰</strong>：abstract，final， native，static或者synchronized。</li>
<li>返回值不同，返回类型也是非常重要的。普通方法能返回任何类型的值或者无返回值（void），构造方法没有返回值，也不需要void。</li>
<li>命名不同，构造方法使用和类相同的名字，而普通方法则不同。按照习惯，普通方法通常用小写字母开始，而构造方法通常用大写字母开始。<strong>构造方法通常是一个名词，因为它和类名相同</strong>；<strong>而普通方法通常更接近动词，因为它说明一个操作</strong></li>
</ol>
<p>注意，引用在Java中就是地址的意思。</p>
<p>在类内的方法（构造方法和普通成员方法）中，访问本类的属性和其它成员方法就可以直接访问了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223157368.png" class="" title="image-20221008223157368">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223214714.png" class="" title="image-20221008223214714">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223321136.png" class="" title="image-20221008223321136">

<p>成员变量默认值。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223351038.png" class="" title="image-20221008223351038">

<p>成员变量显示初始化。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223431202.png" class="" title="image-20221008223431202">

<p>此时可以看到，同一个类的不同对象，成员变量值都是一样的了。没有做到个性化。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223541630.png" class="" title="image-20221008223541630">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223620361.png" class="" title="image-20221008223620361">

<p><strong>构造方法不能够这样手动直接调用的，是jvm中创建对象的时候自动调用的。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223715627.png" class="" title="image-20221008223715627">

<p>构造函数是创建对象的时候自动调用的。此时没有创建对象。</p>
<p>54行的b1是在栈中创建了一个引用变量，此时还没有创建对象呢。只有new了才会创建对象。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223827957.png" class="" title="image-20221008223827957">

<p>可以看到，new的时候，是真正的在堆中创建对象的，并且调用了构造函数了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223915045.png" class="" title="image-20221008223915045">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008223950508.png" class="" title="image-20221008223950508">

<p>通过构造函数对成员变量进行初始化。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224100271.png" class="" title="image-20221008224100271">

<p>默认提供的无参构造方法是java编译器编译的时候默认提供上去的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Calculator.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num1; <span class="comment">//操作数1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num2;  <span class="comment">//操作数2</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span>	<span class="type">char</span> option ; <span class="comment">//运算符</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提供公共的方法设置属性值....					</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initCalculator</span><span class="params">(<span class="type">int</span> n1 , <span class="type">int</span> n2 , <span class="type">char</span> o)</span>&#123;</span><br><span class="line">		num1 = n1;</span><br><span class="line">		num2 = n2;</span><br><span class="line">		<span class="keyword">if</span>(o==<span class="string">&#x27;+&#x27;</span>||o==<span class="string">&#x27;-&#x27;</span>||o==<span class="string">&#x27;*&#x27;</span>||o==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">			option = o;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			option = <span class="string">&#x27;+&#x27;</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算的功能</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(option)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做加法运算,结果是：&quot;</span>+(num1+num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做减法运算,结果是：&quot;</span>+(num1-num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做乘法运算,结果是：&quot;</span>+(num1*num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;做除法运算,结果是：&quot;</span>+(num1/num2));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个类没有构造方法。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224331797.png" class="" title="image-20221008224331797">

<p>重点关注这3个参数。</p>
<p>jdk提供了一个java开发工具(javap.exe)给我们进行反编译的。</p>
<p>javap 反编译工具的使用格式：</p>
<p>javap -c -l -private 类名</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224459119.png" class="" title="image-20221008224459119">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224526476.png" class="" title="image-20221008224526476">

<p><strong>因此，默认无参构造方法是java编译器提供的。而不是jvm虚拟机提供的。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224659284.png" class="" title="image-20221008224659284">

<p>我们提供一个构造方法。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224717257.png" class="" title="image-20221008224717257">

<p><strong>此时编译器不会再提供默认的无参默认的那个构造方法了。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224826164.png" class="" title="image-20221008224826164">

<p>javac编译器默认提供的那个无参构造方法的访问权限修饰符是什么？</p>
<p>public，private，还是没有呢？</p>
<p><strong>这3个选择都是错的。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224926856.png" class="" title="image-20221008224926856">

<p><strong>现在该类没有构造方法。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008224950903.png" class="" title="image-20221008224950903">

<p>此时编译器提供的默认无参构造方法没有访问权限修饰符。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225032500.png" class="" title="image-20221008225032500">

<p>给类增加权限修饰符。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225112268.png" class="" title="image-20221008225112268">

<p>此时构造方法的权限修饰符就是public，说明它是和类的权限修饰符保持一致的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225135481.png" class="" title="image-20221008225135481">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225227432.png" class="" title="image-20221008225227432">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225246262.png" class="" title="image-20221008225246262">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225305526.png" class="" title="image-20221008225305526">

<p><strong>因为没有提供无参的构造方法。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225338504.png" class="" title="image-20221008225338504">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225352655.png" class="" title="image-20221008225352655">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008225444067.png" class="" title="image-20221008225444067">

<p><strong>构造函数没有返回值类型的，如果人为指定了返回值类型，那么该函数就不是构造函数了，就变成了普通的函数了。</strong></p>
<p><strong>用到的示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//婴儿类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//身份证</span></span><br><span class="line"> </span><br><span class="line">	String  name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Baby</span><span class="params">(<span class="type">int</span> i , String n)</span>&#123;</span><br><span class="line">		id  = i;</span><br><span class="line">		name = n;</span><br><span class="line">		System.out.println(<span class="string">&quot;baby的属性初始化完毕！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//无参 的构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Baby</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;无参的构造函数被调用了..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//哭</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;哇哇哭...&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="comment">//创建一个baby对象</span></span><br><span class="line">		<span class="type">Baby</span> <span class="variable">b1</span> <span class="operator">=</span> 	<span class="keyword">new</span> <span class="title class_">Baby</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>); <span class="comment">//婴儿诞生   白户</span></span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ b1.id +<span class="string">&quot; 姓名：&quot;</span>+ b1.name);</span><br><span class="line">		b1.cry();</span><br><span class="line">		b1.cry();</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		//黑户</span></span><br><span class="line"><span class="comment">		Baby b2 = new Baby();</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		b2.id = 112;</span></span><br><span class="line"><span class="comment">		b2.name = &quot;狗剩&quot;;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;编号：&quot;+ b2.id +&quot; 姓名：&quot;+ b2.name);</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008230939363.png" class="" title="image-20221008230939363">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008230957952.png" class="" title="image-20221008230957952">

<p>此时没有构造方法，同时成员变量也没有采用显示初始化。</p>
<p>可以看到，成员变量使用了默认值了都。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231101214.png" class="" title="image-20221008231101214">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231122789.png" class="" title="image-20221008231122789">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231142357.png" class="" title="image-20221008231142357">

<p><strong>注意，没有使用到包的时候，构造方法前面的public，不写也没问题。</strong></p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo3.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">描述一个员工类，员工具备 的属性：id\ name \ age 。</span></span><br><span class="line"><span class="comment">具备的公共行为： 工作。 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要求：一旦创建一个员工对象 的时候，那么该员工对象就要对应 的属性值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> id;  <span class="comment">//编号</span></span><br><span class="line"></span><br><span class="line">	String name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> age; <span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> a, String b , <span class="type">int</span> c)</span>&#123;</span><br><span class="line">		id =a;</span><br><span class="line">		name = b;</span><br><span class="line">		age = c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;好好工作，努力挣钱!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//创建一个员工对象</span></span><br><span class="line">		<span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">Employee</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>,<span class="number">20</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ e.id+<span class="string">&quot; 名字：&quot;</span>+e.name +<span class="string">&quot; 年龄：&quot;</span>+ e.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231444545.png" class="" title="image-20221008231444545">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231501001.png" class="" title="image-20221008231501001">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231525761.png" class="" title="image-20221008231525761">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231545281.png" class="" title="image-20221008231545281">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231607939.png" class="" title="image-20221008231607939">

<p>出生就能够哭。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231705762.png" class="" title="image-20221008231705762">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231722681.png" class="" title="image-20221008231722681">

<p>无参构造方法中没有调用cry，因此，b2出生没哭。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008231745562.png" class="" title="image-20221008231745562">

<p><strong>可以看到，12行和17行属于重复代码了，不好。</strong></p>
<p><strong>此时使用构造代码块来解决这个问题。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造代码块：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造代码块的作用：给所有对象进行统一的初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造函数的作用： 给对应的特定的一个对象进行初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">两者的区别。构造函数是给对应的某一个对象初始化。而构造代码块是给所有的对象进行统一初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造代码块的格式：</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		构造代码块</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意： 构造代码块的大括号必须位于成员位置上。即和成员变量，成员方法都是并列的。</span></span><br><span class="line"><span class="comment">注意，构造代码块大括号必须位于成员位置上，也就是说，类内部，方法外部，意思就是说，和成员变量，成员方法是同一级别的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">代码块的类别：</span></span><br><span class="line"><span class="comment">	1. 构造代码块。</span></span><br><span class="line"><span class="comment">	2. 局部代码块.   大括号位于方法之内。  作用：缩短局部变量的生命周期，节省一点点内存。同时也是缩小了局部变量的作用域。</span></span><br><span class="line"><span class="comment">	3. 静态代码块  static </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232149828.png" class="" title="image-20221008232149828">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232445354.png" class="" title="image-20221008232445354">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232534379.png" class="" title="image-20221008232534379">

<p><strong>可以看到，构造代码块也是在创建对象的时候执行的。55行没有创建对象的，只是定义了一个引用变量而已。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232610763.png" class="" title="image-20221008232610763">

<p>可以看到，构造代码块也执行了。</p>
<p><strong>只要创建对象，那么构造代码块就会被执行的。跟构造函数的参数啥的没关系。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232656746.png" class="" title="image-20221008232656746">

<p><strong>这里说明一点，构造函数中调用普通成员函数cry()，实际就是this.cry()这样调用的。</strong></p>
<p><strong>也就是new的时候，首先根据方法区中class字节码中类的信息，知道了成员变量类型了，然后对对象在堆中根据成员变量类型来进行分配空间，然后我们在编译的时候，会对类体进行重新整理，将成员变量的声明通通提到类的最前面，然后将成员变量的显示初始化和构造代码块的初始化，通通放入到构造函数中进行，并且放在构造函数中最前面来执行，同时，显示初始化和构造代码块在构造函数中最前面的顺序，就依赖于成员变量显示初始化和构造代码块初始化在类体中书写的先后顺序了，谁在前，那么谁就在构造函数中的前面。待成员变量显示初始化和构造代码块初始化都完事了，才会执行构造函数本身的初始化操作。</strong></p>
<p><strong>当构造函数执行完毕之后，堆中这个对象才是真正的创建完毕了，将对象的引用返回给栈中的引用变量。</strong></p>
<p><strong>注意，在构造函数中调用普通成员函数，因为new对象的时候，首先就在堆中给对象分配内存空间了，对象已经存在了，在构造函数执行的时候，当前的这个对象已经有了，因此，执行构造函数的时候，实际上也是将当前对象作为第一个隐含参数传入给构造函数中的this了。因此，构造函数中调用cry，实际上就是this.cry()调用。在构造函数中给成员变量赋值，实际上也是this.xxx&#x3D;xxx，因为这个this就是指向当前的堆中分配了空间的那个对象了。调用cry的时候，就是this.cry()，实际上同理也是将当前对象作为第一个隐含参数传入，即为cry(this,xx,yy)这样的，传给了cry中的this了。因此，在cry中访问成员变量，也是this.xxx这样的了。</strong></p>
<p><strong>从另外一个角度理解，就是类中的成员方法和成员变量之间是可以互相随意访问的。类似C语言中的各个函数和全局变量的关系。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008232713324.png" class="" title="image-20221008232713324">

<p><strong>将cry移动到构造代码块中调用。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008235846034.png" class="" title="image-20221008235846034">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221008235923889.png" class="" title="image-20221008235923889">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000011237.png" class="" title="image-20221009000011237">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000032887.png" class="" title="image-20221009000032887">

<p>可以看到加上了局部代码块也没什么区别。</p>
<p>实际上，局部代码块，基本上没什么太大的作用。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000058898.png" class="" title="image-20221009000058898">

<p>局部代码块的唯一的一点作用。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000210096.png" class="" title="image-20221009000210096">

<p>此时的b1变量，和右边的new出来的对象的作用范围就是到69行，出了69行就消失了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000301737.png" class="" title="image-20221009000301737">

<p>此时b1和new出来的对象在出了61行就是垃圾对象和变量了，会被回收和释放。</p>
<p>因此，局部代码块用途不大，因为现在内存都足够。</p>
<p>构造代码块是有用的。</p>
<p>静态代码块，在学习static的时候，说明。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo4.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//身份证</span></span><br><span class="line"> </span><br><span class="line">	String  name;  <span class="comment">//名字</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造代码块...</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;构造代码块的代码执行了......&quot;);</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带参构造函数</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Baby</span><span class="params">(<span class="type">int</span> i , String n)</span>&#123;</span><br><span class="line">		id  = i;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//无参构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Baby</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;哇哇哭...&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Baby</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Baby</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>);  <span class="comment">//  狗娃 狗剩 铁蛋</span></span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ b1.id + <span class="string">&quot; 名字：&quot;</span>+b1.name);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;编号：&quot;+ b1.id + &quot; 名字：&quot;+b1.name);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		new Baby(110,&quot;狗娃&quot;);</span></span><br><span class="line"><span class="comment">		new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p><strong>构造代码块和成员变量显示初始化，在编译之后，会对类进行重新整理。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000656083.png" class="" title="image-20221009000656083">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000742938.png" class="" title="image-20221009000742938">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000813411.png" class="" title="image-20221009000813411">

<p>换个位置。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000826271.png" class="" title="image-20221009000826271">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000846322.png" class="" title="image-20221009000846322">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000854980.png" class="" title="image-20221009000854980">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000918305.png" class="" title="image-20221009000918305">

<p>将构造方法中的注释。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000929774.png" class="" title="image-20221009000929774">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000950990.png" class="" title="image-20221009000950990">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009000958040.png" class="" title="image-20221009000958040">



<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造 代码块要注意的事项：</span></span><br><span class="line"><span class="comment">	1. java编译器编译一个java源文件的时候，会把成员变量的声明语句提前至一个类的最前端。</span></span><br><span class="line"><span class="comment">	2. 成员变量的初始化工作其实都是在构造函数中执行的。</span></span><br><span class="line"><span class="comment">	3. 一旦经过java编译器编译后，那么构造代码块的代码块就会被移动构造函数中执行，是在构造函数中的代码之前执行的，构造函数的中代码是最后执行 的。</span></span><br><span class="line"><span class="comment">	4. 成员变量的显示初始化与构造代码块 的代码是按照当前代码的书写顺序执行的。成员变量显示初始化，也是放在构造函数中进行的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo5</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo5</span><span class="params">()</span>&#123;   <span class="comment">//构造函数</span></span><br><span class="line">		i = <span class="number">300000000</span>;	</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//构造代码块   //构造代码块的初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		i = <span class="number">200000000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100000000</span>;	 <span class="comment">//成员变量的显初始化</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Demo5</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo5</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;i = &quot;</span>+d.i); <span class="comment">//    双、吴、刘 ：2000   ：</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093400820.png" class="" title="image-20221009093400820">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093409512.png" class="" title="image-20221009093409512">

<p>构造方法放在前面也没有问题，照样不报错的。</p>
<p>因此，虽然有多次不同地方赋值了，但是最后的执行的，还是构造函数。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093439163.png" class="" title="image-20221009093439163">

<p>反编译。</p>
<p>反编译的结果，可以看到，编译的时候对书写的代码进行了调整了。</p>
<p>将int i声明放在了类体的最前面了。因此，符合先定义后使用，所以，6行这里在9行前面使用，就不会报错。</p>
<p>另外，9行这里是声明时候就赋值了，而编译之后，可以看到，是先声明了，没有立即给i赋值。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093652122.png" class="" title="image-20221009093652122">

<p>可以看到，将赋值的操作通通放到了构造函数中去执行了。成员变量显示初始化也放在了构造函数中了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009093731081.png" class="" title="image-20221009093731081">

<p>并且，可以看到，构造代码块内容也放到了构造函数中执行了，并且是在构造函数中的内容的前面。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094137208.png" class="" title="image-20221009094137208">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094155915.png" class="" title="image-20221009094155915">

<p>颠倒顺序。</p>
<p>可以看到，编译器将声明放到了类的最前面，然后所有的赋值都是在构造方法中进行的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094228285.png" class="" title="image-20221009094228285">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> id; <span class="comment">//身份证</span></span><br><span class="line"> </span><br><span class="line">	String  name;  <span class="comment">//名字</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造代码块...</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;构造代码块的代码执行了......&quot;);</span></span><br><span class="line">		cry();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//带参构造函数</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Baby</span><span class="params">(<span class="type">int</span> i , String n)</span>&#123;</span><br><span class="line">		id  = i;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//无参构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Baby</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;哇哇哭...&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Baby</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Baby</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>);  <span class="comment">//  狗娃 狗剩 铁蛋</span></span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ b1.id + <span class="string">&quot; 名字：&quot;</span>+b1.name);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;编号：&quot;+ b1.id + &quot; 名字：&quot;+b1.name);</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		new Baby(110,&quot;狗娃&quot;);</span></span><br><span class="line"><span class="comment">		new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">		new Baby();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094315613.png" class="" title="image-20221009094315613">

<p>此时是null。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094335545.png" class="" title="image-20221009094335545">

<p><strong>会将构造代码块中的cry()调用，拿到构造方法中的代码的前面了。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009094448748.png" class="" title="image-20221009094448748">

<p>实际上编译之后，就是这样的了。</p>
<p><strong>而此时name还没有值呢，而成员变量String name;也没有赋值，所以就是null的。</strong></p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo04：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造代码块：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造代码块的作用：给对象进行统一的初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造函数的作用： 给对应的对象进行初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">构造代码块的格式：</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   &#123;</span></span><br><span class="line"><span class="comment">      构造代码块</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意： 构造代码块的大括号必须位于成员 位置上。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">代码块的类别：</span></span><br><span class="line"><span class="comment">   1. 构造代码块。</span></span><br><span class="line"><span class="comment">   2. 局部代码块.   大括号位于方法之内。  作用：缩短局部 变量 的生命周期，节省一点点内存。</span></span><br><span class="line"><span class="comment">   3. 静态代码块  static </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baby</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id; <span class="comment">//身份证</span></span><br><span class="line"></span><br><span class="line">    String  name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造代码块...</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;构造代码块的代码执行了......&quot;);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">Baby</span><span class="params">(<span class="type">int</span> i , String n)</span>&#123;</span><br><span class="line">        id  = i;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Baby</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;哇哇哭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Baby</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Baby</span>(<span class="number">110</span>,<span class="string">&quot;狗娃&quot;</span>);  <span class="comment">//  狗娃 狗剩 铁蛋</span></span><br><span class="line">        System.out.println(<span class="string">&quot;编号：&quot;</span>+ b1.id + <span class="string">&quot; 名字：&quot;</span>+b1.name);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      System.out.println(&quot;编号：&quot;+ b1.id + &quot; 名字：&quot;+b1.name);</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">      new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">      new Baby();</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      new Baby(110,&quot;狗娃&quot;);</span></span><br><span class="line"><span class="comment">      new Baby(112,&quot;狗剩&quot;);</span></span><br><span class="line"><span class="comment">      new Baby();</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Demo05：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">构造 代码块要注意的事项：</span></span><br><span class="line"><span class="comment">   1. java编译器编译一个java源文件的时候，会把成员变量的声明语句提前至一个类的最前端。</span></span><br><span class="line"><span class="comment">   2. 成员变量的初始化工作其实都在在构造函数中执行的。</span></span><br><span class="line"><span class="comment">   3. 一旦经过java编译器编译后，那么构造代码块的代码块就会被移动构造函数中执行，是在构造函数中的代码之前执行的，构造函数的中代码是最后执行 的。</span></span><br><span class="line"><span class="comment">   4. 成员变量的显示初始化与构造代码块 的代码是按照当前代码的顺序执行的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo5</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo5</span><span class="params">()</span>&#123;   <span class="comment">//构造函数</span></span><br><span class="line">        i = <span class="number">300000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造代码块   //构造代码块的初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">200000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100000000</span>;  <span class="comment">//成员变量的显初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Demo5</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo5</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span>+d.i); <span class="comment">//    双、吴、刘 ：2000   ：</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p><strong>标准代码——JavaBean</strong></p>
<p>JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，<strong>要求类必须是具体的和公共（public）的，并且必须具有无参数的构造方法</strong>，提供用来操作成员变量的 set 和 get 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;<span class="comment">//必须是public的</span></span><br><span class="line">  <span class="comment">//成员变量</span></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="comment">//无参构造方法【必须】</span></span><br><span class="line">  <span class="comment">//有参构造方法【建议】</span></span><br><span class="line">  <span class="comment">//成员方法    </span></span><br><span class="line">  <span class="comment">//getXxx()</span></span><br><span class="line">  <span class="comment">//setXxx()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个标准的类(JavaBean)通常要拥有下面四个组成部分：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 所有的成员变量都要使用private关键字修饰</span></span><br><span class="line"><span class="comment">2. 为每一个成员变量编写一对儿Getter/Setter方法</span></span><br><span class="line"><span class="comment">3. 编写一个无参数的构造方法</span></span><br><span class="line"><span class="comment">4. 编写一个全参数的构造方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这样标准的类也叫做Java Bean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        stu1.setName(<span class="string">&quot;迪丽热巴&quot;</span>);</span><br><span class="line">        stu1.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + stu1.getName() + <span class="string">&quot;，年龄：&quot;</span> + stu1.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;古力娜扎&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + stu2.getName() + <span class="string">&quot;，年龄：&quot;</span> + stu2.getAge());</span><br><span class="line">        stu2.setAge(<span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + stu2.getName() + <span class="string">&quot;，年龄：&quot;</span> + stu2.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="this关键字第一种用法（指向当前调用者对象）"><a href="#this关键字第一种用法（指向当前调用者对象）" class="headerlink" title="this关键字第一种用法（指向当前调用者对象）"></a>this关键字第一种用法（指向当前调用者对象）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 使用java类描述一个动物。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">问题：存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是就近原则的机制访问的。)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字代表了所属函数的调用者对象。即谁调用了成员方法，那么谁就是那个this，也就是当前对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字作用：两个作用</span></span><br><span class="line"><span class="comment">	1. 如果存在同名成员变量与局部变量时，在方法内部默认是访问局部变量的数据（就近原则），可以通过this关键字指定访问成员变量的数据。</span></span><br><span class="line"><span class="comment">	2. 在一个构造函数中可以调用另外一个构造函数初始化对象。即通过类似this()方式，同时该语句必须是构造函数的第一条语句，它前面不能有任何其他的语句，否则报错。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字要注意事项：</span></span><br><span class="line"><span class="comment">	1. 存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是“就近原则”的机制访问的。)</span></span><br><span class="line"><span class="comment">	2. 如果在一个成员方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的 前面添加this关键字。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p><strong>this的含义</strong></p>
<p><strong>this代表所在类的当前对象的引用（地址值），即对象自己的引用。</strong></p>
<p><strong>记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</strong></p>
<p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。<br>如果需要访问本类当中的成员变量，需要使用格式：<br>this.成员变量名<br>“通过谁调用的方法，谁就是this。”</p>
<p>提示：方法中只有一个变量名时，默认也是使用 this 修饰，可以省略不写。例如，方法中只有一个变量，即直接引用成员变量。注意，是直接使用这个变量，而不是新定义一个变量，直接使用这个变量，那么就是前面加上了this的，使用的就是成员变量，如果新定义了一个同名变量，那么就是局部变量了。</p>
<p><strong>this的两个作用：</strong></p>
<p>1、this表示当前对象，谁调用了方法，那么谁就是this。</p>
<p>2、this简化构造方法的调用。例如，this()或者this(1,2)。</p>
<p>实际上在实例方法形参中隐含的有一个变量this，就是用来接收调用这个实例方法的时候的对象的，然后this就指向了这个对象，实例方法中调用的成员变量，就是this去调用，然后this指向了哪个对象，那么就调用了哪个对象中的成员变量了。</p>
<p>这里类似python中的绑定方法，绑定给对象的方法，会自动将当前对象作为第一个参数传入给self。</p>
<p><strong>成员方法也可以叫做实例方法。</strong></p>
<p><strong>成员变量，也可以叫做实例数据成员变量。</strong></p>
<p>注意，this(1,1)，简化对类中其它构造函数的调用，这个this语句必须是这个当前的构造函数中的第一条语句。否则报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">100000</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Test02</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.i=<span class="number">200</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Test02</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>();</span><br><span class="line">		<span class="built_in">this</span>.i=i;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		i=<span class="number">30000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当存在this()方式调用其它构造函数的时候，查看编译之后，如何对成员变量显示初始化和构造代码块进行重整。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009113443277.png" class="" title="image-20221009113443277">

<p>可以看到，调用this()的时候，它必须是构造函数的第一条语句，因此，重整的时候，就不会在Test02(int)构造方法中添加了，只会在Test02()构造方法中添加成员变量显示初始化和构造代码块了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114045590.png" class="" title="image-20221009114045590">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114101087.png" class="" title="image-20221009114101087">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114110656.png" class="" title="image-20221009114110656">

<p>就近原则，现在在eat方法的方法调用栈中有name，因此，直接就拿到这个name了。如果在eat方法自己的方法调用栈中没有name，那么才会再去到堆内存的对象空间中去找name了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114749957.png" class="" title="image-20221009114749957">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114821015.png" class="" title="image-20221009114821015">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114827957.png" class="" title="image-20221009114827957">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114852767.png" class="" title="image-20221009114852767">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114905586.png" class="" title="image-20221009114905586">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009114912860.png" class="" title="image-20221009114912860">

<p>可以看到，地址一样的。</p>
<p><strong>谁调用了函数，那么this就是谁。也就是哪个对象调用了函数，那么函数中的this就是哪个对象。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115556575.png" class="" title="image-20221009115556575">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115605514.png" class="" title="image-20221009115605514">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115612541.png" class="" title="image-20221009115612541">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115628783.png" class="" title="image-20221009115628783">

<p><strong>栈内存也称为方法栈。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115722878.png" class="" title="image-20221009115722878">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115730293.png" class="" title="image-20221009115730293">

<p><strong>现在内存中有两个对象，两份堆中的name的，那么为何34行输出的是猫的，而不是狗的呢？</strong></p>
<p><strong>如果在一个方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的 前面添加this关键字。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009115827918.png" class="" title="image-20221009115827918">

<p><strong>因此，37行的name，编译之后，等价于是this.name了。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009151854088.png" class="" title="image-20221009151854088">

<p><strong>如果是这样，方法中有局部变量和成员变量同名的时候，那么编译之后，37行就不会有this.name这样的了。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009151937976.png" class="" title="image-20221009151937976">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009151945059.png" class="" title="image-20221009151945059">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152252882.png" class="" title="image-20221009152252882">

<p>因此，在Student方法内部使用的id和name，9行，10行左边的id和name都是局部变量id和name了，也就是形参定义的。就相当于是形参局部变量自己给自己赋值了。</p>
<p>相当于是如下这样</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152341917.png" class="" title="image-20221009152341917">





<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152410391.png" class="" title="image-20221009152410391">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152428080.png" class="" title="image-20221009152428080">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009152448872.png" class="" title="image-20221009152448872">



<p><strong>案例代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo6.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 使用java类描述一个动物。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">问题：存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是就近原则的机制访问的。)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字代表了所属函数的调用者对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字作用：</span></span><br><span class="line"><span class="comment">	1. 如果存在同名成员变量与局部变量时，在方法内部默认是访问局部变量的数据，可以通过this关键字指定访问成员变量的数据。</span></span><br><span class="line"><span class="comment">	2. 在一个构造函数中可以调用另外一个构造函数初始化对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字要注意事项：</span></span><br><span class="line"><span class="comment">	1. 存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是“就近原则”的机制访问的。)</span></span><br><span class="line"><span class="comment">	2. 如果在一个方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的 前面添加this关键字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name ;  <span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">	String color;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String n , String c)</span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		color = c;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//this关键字代表了所属函数的调用者对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;this:&quot;+ this);</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;老鼠&quot;</span>; <span class="comment">//局部变量</span></span><br><span class="line">		System.out.println(name+<span class="string">&quot;在吃...&quot;</span>); <span class="comment">//需求： 就要目前的name是成员变量的name.</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo6</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;狗&quot;</span>,<span class="string">&quot;白色&quot;</span>);  <span class="comment">//现在在内存中存在两份name数据。</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;猫&quot;</span>,<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">		cat.eat();</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="this关键字第二种用法（调用本类其它构造方法）"><a href="#this关键字第二种用法（调用本类其它构造方法）" class="headerlink" title="this关键字第二种用法（调用本类其它构造方法）"></a>this关键字第二种用法（调用本类其它构造方法）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;  <span class="comment">//身份证</span></span><br><span class="line"></span><br><span class="line">	String name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//目前情况：存在同名的成员变量与局部变量，在方法内部默认是使用局部变量的。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id,String name)</span>&#123;  <span class="comment">//一个函数的形式参数也是属于局部变量。</span></span><br><span class="line">		<span class="built_in">this</span>(name); <span class="comment">//调用了本类的一个参数的构造方法</span></span><br><span class="line">		<span class="comment">//this(); //调用了本类无参的 构造方法。与上面的this(name)不能同时出现，因为都必须是第一条语句，就矛盾了。</span></span><br><span class="line">		<span class="built_in">this</span>.id = id; <span class="comment">// this.id = id 局部变量的id给成员变量的id赋值</span></span><br><span class="line">		System.out.println(<span class="string">&quot;两个参数的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;无参的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		System.out.println(<span class="string">&quot;一个参数的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo7</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">110</span>,<span class="string">&quot;铁蛋&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ s.id +<span class="string">&quot; 名字：&quot;</span> + s.name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		Student s2 = new Student(&quot;金胖子&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;名字：&quot; + s2.name);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165221048.png" class="" title="image-20221009165221048">

<p>代码冗余。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165248764.png" class="" title="image-20221009165248764">

<p>这样是不行的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165409600.png" class="" title="image-20221009165409600">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165430128.png" class="" title="image-20221009165430128">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165437098.png" class="" title="image-20221009165437098">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165449324.png" class="" title="image-20221009165449324">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009165455342.png" class="" title="image-20221009165455342">



<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo6.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 使用java类描述一个动物。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">问题：存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是就近原则的机制访问的。)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字代表了所属函数的调用者对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字作用：</span></span><br><span class="line"><span class="comment">	1. 如果存在同名成员变量与局部变量时，在方法内部默认是访问局部变量的数据，可以通过this关键字指定访问成员变量的数据。</span></span><br><span class="line"><span class="comment">	2. 在一个构造函数中可以调用另外一个构造函数初始化对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">this关键字要注意事项：</span></span><br><span class="line"><span class="comment">	1. 存在同名的成员变量与局部变量时，在方法的内部访问的是局部变量(java 采取的是“就近原则”的机制访问的。)</span></span><br><span class="line"><span class="comment">	2. 如果在一个方法中访问了一个变量，该变量只存在成员变量的情况下，那么java编译器会在该变量的 前面添加this关键字。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name ;  <span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">	String color;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String n , String c)</span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		color = c;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//this关键字代表了所属函数的调用者对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;this:&quot;+ this);</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;老鼠&quot;</span>; <span class="comment">//局部变量</span></span><br><span class="line">		System.out.println(name+<span class="string">&quot;在吃...&quot;</span>); <span class="comment">//需求： 就要目前的name是成员变量的name.</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo6</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;狗&quot;</span>,<span class="string">&quot;白色&quot;</span>);  <span class="comment">//现在在内存中存在两份name数据。</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;猫&quot;</span>,<span class="string">&quot;黑色&quot;</span>);</span><br><span class="line">		cat.eat();</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Demo7.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this关键字调用其他的构造函数要注意的事项：</span></span><br><span class="line"><span class="comment">	1. this关键字调用其他的构造函数时，this关键字必须要位于构造函数中 的第一个语句。</span></span><br><span class="line"><span class="comment">	2. this关键字在构造函数中不能出现相互调用 的情况，因为是一个死循环。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id;  <span class="comment">//身份证</span></span><br><span class="line"></span><br><span class="line">	String name;  <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//目前情况：存在同名 的成员 变量与局部变量，在方法内部默认是使用局部变量的。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id,String name)</span>&#123;  <span class="comment">//一个函数的形式参数也是属于局部变量。</span></span><br><span class="line">		<span class="built_in">this</span>(name); <span class="comment">//调用了本类的一个参数的构造方法</span></span><br><span class="line">		<span class="comment">//this(); //调用了本类无参的 构造方法。</span></span><br><span class="line">		<span class="built_in">this</span>.id = id; <span class="comment">// this.id = id 局部变量的id给成员变量的id赋值</span></span><br><span class="line">		System.out.println(<span class="string">&quot;两个参数的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;无参的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		System.out.println(<span class="string">&quot;一个参数的构造方法被调用了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo7</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">110</span>,<span class="string">&quot;铁蛋&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;编号：&quot;</span>+ s.id +<span class="string">&quot; 名字：&quot;</span> + s.name);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">		Student s2 = new Student(&quot;金胖子&quot;);</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;名字：&quot; + s2.name);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>练习：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="type">int</span> id;<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 方法中的变量与属性重名</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		id++;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在一个构造方法中，调用其他重载的构造方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>(name);</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 把this作为一个局部变量，它的值是当前对象的引用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Dog <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">		id++;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;it is &quot;</span> + name + <span class="string">&quot; number &quot;</span> + id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">wangcai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Cai Wang&quot;</span>);</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">wangwang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Wang Wang&quot;</span>);</span><br><span class="line">		wangcai.print();</span><br><span class="line">		wangwang.print();</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">wangcai1</span> <span class="operator">=</span> wangcai.clone();<span class="comment">//和wangcai指向了同一个对象了</span></span><br><span class="line">		wangcai1.print();</span><br><span class="line">		wangwang.clone().clone().print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">it is Cai Wang number <span class="number">1</span></span><br><span class="line">it is Wang Wang number <span class="number">1</span></span><br><span class="line">it is Cai Wang number <span class="number">2</span></span><br><span class="line">it is Wang Wang number <span class="number">3</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="static静态成员变量"><a href="#static静态成员变量" class="headerlink" title="static静态成员变量"></a>static静态成员变量</h2><p><strong>静态变量（类变量）</strong><br>static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属<br>于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</p>
<p><strong>定义和使用格式</strong><br><strong>类变量</strong><br><strong>当 static 修饰成员变量时，该变量称为类变量</strong>。该类的每个对象都共享同一个类变量的值。任何对象都可以更改<br>该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。<br><strong>类变量：使用 static关键字修饰的成员变量。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id; <span class="comment">// 学号</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">static</span> String room; <span class="comment">// 所在教室</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">idCounter</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 学号计数器，每当new了一个新对象的时候，计数器++</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.id = ++idCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01StaticField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;黄蓉&quot;</span>, <span class="number">16</span>);</span><br><span class="line">        two.room = <span class="string">&quot;101教室&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + two.getName()</span><br><span class="line">                + <span class="string">&quot;，年龄：&quot;</span> + two.getAge() + <span class="string">&quot;，教室：&quot;</span> + two.room</span><br><span class="line">                + <span class="string">&quot;，学号：&quot;</span> + two.getId());</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭靖&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + one.getName()</span><br><span class="line">                + <span class="string">&quot;，年龄：&quot;</span> + one.getAge() + <span class="string">&quot;，教室：&quot;</span> + one.room</span><br><span class="line">                + <span class="string">&quot;，学号：&quot;</span> + one.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo9.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static(静态)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求：描述一下学生类。  都是中国人....</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">目前存在的问题： 所有的学生都是中国 的，有n个学生就会有n份中国的 数据存内存中，这样子</span></span><br><span class="line"><span class="comment">会浪费内存。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">目前方案： 把“中国”这个数据移动 到数据共享区中，共享这个数据给所有的Student对象使用即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">问题2： 如何才能把这个数据移动 到数据共享区中共享呢？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解决方案： 只需要使用static修饰该数据即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">静态的成员变量只会在数据共享区中维护一份，而非静态成员变量的数据会在每个对象中都维护一份的。。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用了static修饰country，那么这时候country就是一个共享的数据。</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>	<span class="type">String</span>  <span class="variable">country</span>  <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;	<span class="comment">//国籍</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo9</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;陈七&quot;</span>);</span><br><span class="line"></span><br><span class="line">		s1.country = <span class="string">&quot;小日本&quot;</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+s1.name+<span class="string">&quot; 国籍：&quot;</span>+ s1.country); <span class="comment">//  中国   </span></span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+s2.name+<span class="string">&quot; 国籍：&quot;</span>+ s2.country); <span class="comment">// 小日本</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172533239.png" class="" title="image-20221009172533239">

<p>现在country是成员变量，那么每创建一个对象，对象的堆内存中都会有一个成员变量country的，并且值都是一样的，冗余了。</p>
<p>使用static静态成员变量。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172633328.png" class="" title="image-20221009172633328">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172707352.png" class="" title="image-20221009172707352">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172724350.png" class="" title="image-20221009172724350">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172817051.png" class="" title="image-20221009172817051">



<p><strong>静态的成员变量只会在数据共享区（方法区）中维护一份，而非静态成员变量的数据会在每个对象中都维护一份的。。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172913661.png" class="" title="image-20221009172913661">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172922014.png" class="" title="image-20221009172922014">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009172955579.png" class="" title="image-20221009172955579">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo10.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">static(静态\修饰符)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	1. static修饰成员变量 ：如果有数据需要被共享给所有对象使用时，那么就可以使用static修饰。</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		静态成员变量的访问方式：</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">				方式1： 可以使用对象进行访问。</span></span><br><span class="line"><span class="comment">					格式： 对象.变量名。</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">				方式二： 可以使用类名进行访问。</span></span><br><span class="line"><span class="comment">					格式： 类名.变量名;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">			注意： </span></span><br><span class="line"><span class="comment">				1. 非静态的成员变量只能使用对象进行访问，不能使用类名进行访问。</span></span><br><span class="line"><span class="comment">				2. 千万不要为了方便访问数据而使用static修饰成员变量，只有成员变量的数据是真正需要被共享的时候</span></span><br><span class="line"><span class="comment">				才使用static修饰。</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		static修饰成员变量的应用场景： 如果一个数据需要被所有对象共享使用的时候，这时候即可好实用static修饰。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	2. static修饰成员函数:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>	String name;  <span class="comment">//非静态成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>	<span class="type">String</span>  <span class="variable">country</span>  <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;	  <span class="comment">//静态的成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;狗娃&quot;</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;狗剩&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//System.out.println(&quot;国籍：&quot;+ Student.country);</span></span><br><span class="line">		System.out.println(<span class="string">&quot;名字：&quot;</span>+ s1.name);</span><br><span class="line">		System.out.println(<span class="string">&quot;名字：&quot;</span>+ s2.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>静态成员变量的访问方式：</strong></p>
<p>​              <strong>方式1： 可以使用对象进行访问。</strong></p>
<p>​                  格式： 对象.变量名。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009173248959.png" class="" title="image-20221009173248959">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009173304330.png" class="" title="image-20221009173304330">



<p>​				<strong>方式二： 可以使用类名进行访问。</strong></p>
<p>​                  	格式： 类名.变量名;</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009173354111.png" class="" title="image-20221009173354111">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009173403493.png" class="" title="image-20221009173403493">



<p>注意，static成员（成员变量和成员方法）是属于类的，而不是属于某个对象的。</p>
<p>通过对象去访问static成员实际上仍然是根据对象找到对应的方法区中的类型信息，然后通过类去访问的static成员的。</p>
<p><strong>注意：</strong> </p>
<p>​              <strong>1. 非静态的成员变量只能使用对象进行访问，不能使用类名进行访问否则编译报错。</strong></p>
<p>​              <strong>2. 千万不要为了方便访问数据而使用static修饰成员变量，只有成员变量的数据是真正需要被共享的时候</strong></p>
<p>​              <strong>才使用static修饰。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174243163.png" class="" title="image-20221009174243163">

<p>对普通成员变量，也增加上static了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174332807.png" class="" title="image-20221009174332807">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174340841.png" class="" title="image-20221009174340841">

<p>可以看到，全是同名的了。这就是成员变量使用了static修饰导致的。</p>
<h2 id="static修饰成员变量的应用"><a href="#static修饰成员变量的应用" class="headerlink" title="static修饰成员变量的应用"></a>static修饰成员变量的应用</h2><img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174547961.png" class="" title="image-20221009174547961">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174607476.png" class="" title="image-20221009174607476">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174632110.png" class="" title="image-20221009174632110">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174645210.png" class="" title="image-20221009174645210">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174721287.png" class="" title="image-20221009174721287">



<p>这样为了统计创建的对象个数，不管调用的哪个构造方法，里面都需要写count++，代码冗余了。</p>
<p>因此，将其放到构造代码块。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009174745812.png" class="" title="image-20221009174745812">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求： 统计一个类被使用了多少次创建对象，该类对外显示被创建的次数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//非静态的成员变量。</span></span><br><span class="line">	<span class="keyword">static</span>	<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">//计数器</span></span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造代码块</span></span><br><span class="line">	&#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">()</span>&#123;  <span class="comment">//每创建一个对象的时候都会执行这里 的代码</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCount</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;创建了&quot;</span>+ count+<span class="string">&quot;个对象&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo11</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Emp</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">		<span class="type">Emp</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">		<span class="type">Emp</span> <span class="variable">e3</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">		e3.showCount();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="static静态成员方法"><a href="#static静态成员方法" class="headerlink" title="static静态成员方法"></a>static静态成员方法</h2><p><strong>静态方法（类方法）</strong></p>
<p>当 static 修饰成员方法时，该方法称为<strong>类方法</strong> 。静态方法在声明中有 static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。</p>
<p><strong>类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">static</span> 返回值类型 方法名 (参数列表)&#123; </span><br><span class="line">    <span class="comment">// 执行语句 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态方法调用的注意事项：</strong></p>
<p>静态方法可以直接访问类变量（static静态变量）和静态方法。</p>
<p>静态方法不能直接访问普通成员变量或普通成员方法。反之，普通成员方法可以直接访问类变量或静态方法。</p>
<p>静态方法中，不能使用this，super关键字。</p>
<p><strong>静态方法只能访问静态成员。</strong>即静态的只能访问静态的，非静态的可以任意访问。</p>
<p>被static修饰的成员可以并且建议通过类名直接访问。<strong>虽然也可以通过对象名访问静态成员</strong>，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问类变量</span></span><br><span class="line">类名.类变量名；</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用静态方法</span></span><br><span class="line">类名.静态方法名(参数)； </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num; <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> numStatic; <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个成员方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 成员方法可以访问成员变量</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="comment">// 成员方法可以访问静态变量</span></span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodStatic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个静态方法。&quot;</span>);</span><br><span class="line">        <span class="comment">// 静态方法可以访问静态变量</span></span><br><span class="line">        System.out.println(numStatic);</span><br><span class="line">        <span class="comment">// 静态不能直接访问非静态【重点】</span></span><br><span class="line"><span class="comment">//        System.out.println(num); // 错误写法！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法中不能使用this关键字。</span></span><br><span class="line"><span class="comment">//        System.out.println(this); // 错误写法！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</span></span><br><span class="line"><span class="comment">如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。</span></span><br><span class="line"><span class="comment">静态变量：类名称.静态变量</span></span><br><span class="line"><span class="comment">静态方法：类名称.静态方法()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">1. 静态不能直接访问非静态。</span></span><br><span class="line"><span class="comment">原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。</span></span><br><span class="line"><span class="comment">“先人不知道后人，但是后人知道先人。”</span></span><br><span class="line"><span class="comment">2. 静态方法当中不能用this。</span></span><br><span class="line"><span class="comment">原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。也就是说，要有这个对象才行，而静态内容初始化的时候，对象还不存在呢。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02StaticMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 首先创建对象</span></span><br><span class="line">        <span class="comment">// 然后才能使用没有static关键字的内容</span></span><br><span class="line">        obj.method();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。</span></span><br><span class="line">        obj.methodStatic(); <span class="comment">// 正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”</span></span><br><span class="line">        MyClass.methodStatic(); <span class="comment">// 正确，推荐</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于本类当中的静态方法，可以省略类名称</span></span><br><span class="line">        myMethod();<span class="comment">//与下面等价</span></span><br><span class="line">        Demo02StaticMethod.myMethod(); <span class="comment">// 完全等效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;自己的方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非静态方法，称为实例方法。也叫做对象方法。</p>
<p>非静态变量，称为实例变量。也叫做对象属性。</p>
<p>静态方法，在类加载的时候，就给这个静态方法分配了代码空间了，那么这个时候，还没有产生对象呢，那么此时在静态方法中访问实例变量或者实例方法是不行的，因为，实例变量和实例方法是需要先new出一个对象之后，在堆中才会有对应的对象存在的，才能够去使用对象的实例变量和实例方法。因此，静态方法中调用非静态成员变量，就是非法操作。</p>
<p>在类加载的时候，意思是说当第一次使用到类的时候，才会对其进行加载，懒惰模式，例如，Student stu;当定义引用变量的时候，那么此时JVM就会将Student类对应的字节码文件加载到方法区中了，此时就加载Student类了，注意，此时没有对象呢。因此，不需要new，只有定义引用变量的操作，那么就会将类进行加载了。此时静态变量，静态代码块，静态方法，都会被加载了。注意，类加载之后，就会一直存在于方法区中的，生命周期直到程序结束。</p>
<p>类变量，类方法，当类加载的时候，它们就已经具有了内存空间了。而非静态方法，要想能够被调用，必须要首先有对象产生，而这个时候，静态成员变量和静态成员方法已经具有了内存空间，因此，就可以调用了。</p>
<p>静态不能够访问非静态。只能访问静态。</p>
<p>非静态可以访问静态，以及非静态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">注意，main方法也是静态方法，在c/c++中也有main方法，但是它不是属于某个类的，它是一个全局的main方法，</span><br><span class="line">因此，当执行程序的时候，c++编译器很容易就能够找到这个main方法。</span><br><span class="line">而java程序的执行时，它都是以类作为程序的组织单元，当执行的时候，不知道这个main方法在哪个类中，也不知道是否要产生一个这个类的对象，</span><br><span class="line">因此，为了解决程序的运行问题，将这个main定义为<span class="keyword">static</span>，这样当执行java代码的时候，输入java Point的时候，那么首先就是找到对应的Point.class字节码文件，然后将其加载到内存中方法区中，然后解开，然后找到类Point，然后就会在这个类中去调用这个静态的main方法，加载到方法调用栈上去执行了，而不需要产生Point这个类的对象。</span><br><span class="line">当加载Point这个类的时候（即java Point的时候，就会加载该类），这个main方法就被加载了（因此是先加载的类，然后才会执行main），</span><br><span class="line">作为java程序的入口函数。而如果不是<span class="keyword">static</span>的main，那么就需要首先产生一个Point的对象，才能够调用这个main。这样程序没法运行了。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对于静态变量，由于它是属于类的，因此，所有的类对象，都是共享同一个静态变量的。静态方法也是同理，所有对象都共享同一个静态方法。</span><br><span class="line">对于非静态方法，它实际上在内存中也只是存在一份拷贝，但是仍然要区分静态方法和非静态方法。虽然都存放在方法区的字节码位置上，但是仍然要区分开。</span><br><span class="line">静态变量，通常可以用来做统计计数。因为多个对象用的是同一个变量。</span><br></pre></td></tr></table></figure>



<h2 id="static内存原理图"><a href="#static内存原理图" class="headerlink" title="static内存原理图"></a>static内存原理图</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03StaticStudent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先设置一下教室，这是静态的东西，应该通过类名称进行调用</span></span><br><span class="line">        Student.room = <span class="string">&quot;101教室&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;郭靖&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;one的姓名：&quot;</span> + one.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;one的年龄：&quot;</span> + one.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;one的教室：&quot;</span> + Student.room);</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;黄蓉&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;two的姓名：&quot;</span> + two.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;two的年龄：&quot;</span> + two.getAge());</span><br><span class="line">        System.out.println(<span class="string">&quot;two的教室：&quot;</span> + Student.room);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009214657924.png" class="" title="image-20221009214657924">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009214722518.png" class="" title="image-20221009214722518">



<p><strong>static 修饰的内容：</strong><br><strong>是随着类的加载而加载的，且只加载一次。</strong></p>
<p>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</p>
<p>它优先于对象存在，所以，可以被所有对象共享。</p>
<p>注意，静态区是存放在方法区中的。</p>
<p>注意，即使使用对象.静态变量，这样访问，实际上编译之后，也是将其翻译成了通过类去找静态变量的。因此，也是直接到方法区中的类的class文件中找到static内容的地址，然后根据地址找到静态区中的值。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009215144863.png" class="" title="image-20221009215144863">

<hr>
<h2 id="static静态代码块"><a href="#static静态代码块" class="headerlink" title="static静态代码块"></a>static静态代码块</h2><p><strong>静态代码块：定义在成员位置，使用static修饰的代码块{ }。</strong></p>
<p><strong>位置：类中，方法外。</strong></p>
<p><strong>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 执行语句 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：给类变量进行初始化赋值。</p>
<p>static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。下面说的两个工具类，就体现static 方法的便利。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态代码块的格式是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public class 类名称 &#123;</span></span><br><span class="line"><span class="comment">    static &#123;</span></span><br><span class="line"><span class="comment">        // 静态代码块的内容</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特点：当第一次用到本类时，静态代码块执行唯一的一次。</span></span><br><span class="line"><span class="comment">静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">静态代码块的典型用途：</span></span><br><span class="line"><span class="comment">用来一次性地对静态成员变量进行赋值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04Static</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//如果这里根本就没有写Person类，那么右键运行，Person类是不会被加载的，那么里面的static代码块也不会被执行的。</span></span><br><span class="line">		<span class="comment">//static代码块以及静态的变量，静态的方法，都是在类被加载的时候，只被执行一次，也就是只会加载一次，后续使用这个类的全程中不会再次执行的。</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		输出结果：</span></span><br><span class="line"><span class="comment">			静态代码块执行！</span></span><br><span class="line"><span class="comment">			构造方法执行！</span></span><br><span class="line"><span class="comment">			构造方法执行！</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		i=<span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009220716026.png" class="" title="image-20221009220716026">

<p>可以看到，编译之后，对代码进行了重整，将静态的i声明放在了类体最前面。然后将静态变量显示初始化和静态代码块中的初始化，通通放到了静态代码块中来做了，按照书写顺序从上到下执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		i=<span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009220933717.png" class="" title="image-20221009220933717">

<p>可以看到，在静态代码块中使用的i是在后面声明定义的，没有报错，原因就是编译之后，对代码重整了，将i的声明放到了最前面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		i=<span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		f=<span class="number">36.7f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">float</span> f=<span class="number">23.5f</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代码块，静态变量显示初始化，构造代码块，实例变量显示初始化。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009221525565.png" class="" title="image-20221009221525565">

<p>可以看到将静态变量声明放在了最前面，然后才是实例变量的声明。</p>
<p>静态变量显示初始化和静态代码块初始化，最后通通放在了静态代码块中了，且按照书写顺序从上到下。</p>
<p>实例变量显示初始化和构造代码块初始化，最后通通放在了构造函数中了，且按照书写顺序从上到下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		i=<span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> f=<span class="number">23.5f</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		f=<span class="number">36.7f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//float f=23.5f;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009221831743.png" class="" title="image-20221009221831743">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>（静态、修饰符）</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>修饰成员变量时：<span class="keyword">static</span>修饰成员变量时,那么该成员变量的数据就是一个共享的数据.</span><br><span class="line">	</span><br><span class="line">		静态成员变量的访问方式：</span><br><span class="line">			</span><br><span class="line">				方式一： 使用对象进行访问。</span><br><span class="line">						对象.属性名</span><br><span class="line">				方式二：可以使用类名进行访问。</span><br><span class="line">						类名.属性名</span><br><span class="line">		注意：</span><br><span class="line">			<span class="number">1.</span> 非静态成员变量不能类名直接访问，只能使用对象进行访问。</span><br><span class="line">			<span class="number">2.</span> 千万不要为了方便访问成员变量而使用<span class="keyword">static</span>修饰，一定要是该数据是共享数据 时才使用<span class="keyword">static</span>修饰。</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>修饰方法（静态的成员方法）:</span><br><span class="line">		</span><br><span class="line">		访问方式：</span><br><span class="line">			</span><br><span class="line">			方式一：可以使用对象进行访问。</span><br><span class="line">					对象.静态的函数名();</span><br><span class="line"></span><br><span class="line">			方式二：可以使用类名进行访问。</span><br><span class="line">					类名.静态函数名字。</span><br><span class="line">		</span><br><span class="line">		推荐使用是类名直接访问静态的成员。不推荐使用对象来访问，因为使用对象访问静态的成员，首先还需要创建出一个对象来，浪费了内存了。因此，直接通过类名访问，节省内存。</span><br><span class="line">注意，这里面所说的成员，就包括了成员变量与成员方法了，下面也同理。</span><br><span class="line"></span><br><span class="line">静态函数要注意的事项：</span><br><span class="line">	<span class="number">1.</span> 静态函数是可以调用类名或者对象进行调用的，而非静态函数只能使用对象进行调用。</span><br><span class="line">	<span class="number">2.</span> 静态的函数可以直接访问静态的成员，但是不能直接访问非静态的成员。	</span><br><span class="line">		原因：静态函数是可以使用类名直接调用的，这时候可能还没有存在对象，</span><br><span class="line">		而非静态的 成员数据是随着对象 的存在而存在的。</span><br><span class="line"></span><br><span class="line">	<span class="number">3.</span> 非静态的函数是可以直接访问静态与非静态的成员。</span><br><span class="line">		原因：非静态函数只能由对象调用，当对象存在的时候，静态数据老早就已经存在了，而非静态数据也随着对象的创建而存在了。</span><br><span class="line"></span><br><span class="line">	<span class="number">4.</span> 静态函数不能出现<span class="built_in">this</span>或者<span class="built_in">super</span>关键字。非静态的函数中可以有<span class="built_in">this</span>和<span class="built_in">super</span>关键字。</span><br><span class="line">		原因：因为静态的函数是可以使用类名调用的，一旦使用类名调用这时候不存在对象，而<span class="built_in">this</span></span><br><span class="line">		关键字是代表了一个函数 的调用者对象，这时候产生了冲突。</span><br><span class="line"></span><br><span class="line">静态的数据的生命周期：静态的成员变量数据是优先于对象存在的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222603907.png" class="" title="image-20221009222603907">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222612438.png" class="" title="image-20221009222612438">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222622461.png" class="" title="image-20221009222622461">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222629942.png" class="" title="image-20221009222629942">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222645436.png" class="" title="image-20221009222645436">

<p>构造代码块与普通的成员变量，都是在创建对象的时候，就会被执行了。</p>
<p>而加上了static，如下</p>
<p>Static {</p>
<p>}</p>
<p>Static String name;</p>
<p>这样就是在类加载的时候，就会被执行了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222801481.png" class="" title="image-20221009222801481">

<p><strong>对于static成员变量和static代码块，是按照从上到下的顺序来执行的。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222830815.png" class="" title="image-20221009222830815">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222835840.png" class="" title="image-20221009222835840">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009222958985.png" class="" title="image-20221009222958985">

<p>可以看到，static代码块和static成员变量是按照从上到下顺序执行的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009223015917.png" class="" title="image-20221009223015917">



<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009223055377.png" class="" title="image-20221009223055377">

<p>可以看到，这里6行报错，7行正确。原因是编译之后，代码重整，会将10行的作为声明，static int i;提到最前面。然后在static代码块中进行统一初始化都是没有问题的，但是不能直接使用静态变量i，使用的话，就都会报错。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009224703914.png" class="" title="image-20221009224703914">

<p><strong>如图，只要在静态代码块中使用了i就会报错，但是统一初始化就没有问题。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225013336.png" class="" title="image-20221009225013336">

<p>如图，b的作用域就是在static静态代码块中了。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225201311.png" class="" title="image-20221009225201311">

<p>静态代码块中不能再使用static关键字了。只能使用final关键字。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225328188.png" class="" title="image-20221009225328188">

<p>静态代码块中使用final没问题，但是后续只能使用它，不能再对其修改了。因此，如果不使用final，那么在静态代码块作用域内就可以修改b了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">静态的成员变量与非静态的成员变量的区别：</span><br><span class="line">	<span class="number">1.</span> 作用上的区别：</span><br><span class="line">		<span class="number">1.</span> 静态的成员变量的作用共享一个 数据给所有的对象使用。</span><br><span class="line">		<span class="number">2.</span> 非 静态的成员变量的作用是描述一类事物的公共属性。</span><br><span class="line">	<span class="number">2.</span> 数量与存储位置上的区别：</span><br><span class="line">		<span class="number">1.</span> 静态成员变量是存储方法 区内存中，而且只会存在一份数据。</span><br><span class="line">		<span class="number">2.</span> 非静态的成员变量是存储在堆内存中，有n个对象就有n份数据。</span><br><span class="line">	<span class="number">3.</span> 生命周期的区别：</span><br><span class="line">		<span class="number">1.</span> 静态的成员变量数据是随着类的加载而存在，随着类文件的消失而消失，一般都是程序执行结束之后，加载的类文件才会卸载掉。</span><br><span class="line">		<span class="number">2.</span>非静态的成员数据是随着对象的创建而存在，随着 对象被垃圾回收器回收而消失。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span>什么时候修饰一个函数？</span><br><span class="line">	如果一个函数没有直接访问到非静态的成员时，那么就可以使用<span class="keyword">static</span>修饰了。 一般用于工具类型的方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>静态函数不能访问非静态的成员？注意，这里没说是直接访问。</p>
<p>​     静态函数只要存在有对象，那么也可以访问非 静态的数据。只是不能<strong>直接</strong>访问而已。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225659495.png" class="" title="image-20221009225659495">

<p>注意，这个this代表的是，调用sleep函数的那个对象，而不是s这个对象的。</p>
<p><strong>Static静态函数中，不能使用this和super。</strong></p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225851529.png" class="" title="image-20221009225851529">

<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009225858996.png" class="" title="image-20221009225858996">

<p>当执行这个，就要执行Demo2类的代码了，此时就要执行Demo2类中的main方法了。此时jvm就会将Demo2.class文件加载到内存中，加载到方法区中，此时还不会加载Student.class，因为还没有执行到Student语句呢，还没要使用Student这个类，jvm采用的是懒惰型加载，只有用到了某个类的时候，才会进行加载。当加载了Demo2.class文件到内存的方法区之后，就会将这个文件解剖，看里面有哪些成员，发现只有一个main方法，此时就看到了main方法的字节码了，就放在方法区中那个位置了，然后要执行main方法，由于这个main方法在方法区中，只是一个字节码而已，也就是代码而已，没有执行的呢，因此，此时main要执行，jvm就将方法区中的main方法的代码，加载到栈内存中，此时jvm会在栈内存中开辟一个空间，给这个main方法来用，此时main在栈中开始执行，执行的第一条语句就是Student那个语句，此时就要用到Student了，此时，jvm就将Student.class加载到方法区中，然后解剖这个class文件，看里面有哪些成员方法，有哪些成员变量，此时就看到Student.class文件中，有sleep()，study()方法，还发现里面有一个静态的成员变量country，然后会将这个静态的成员变量country，放到方法区中的静态数据共享区中，也就是静态的成员变量都放到了静态数据共享区中了。因此，静态变量，静态方法，是在class文件加载到内存中的时候，就已经有了。但是此时对象还没有呢，name成员变量也就没有呢。</p>
<p>然后要执行sleep()方法，那么就将sleep()代码加载到栈内存中，开始执行sleep()方法。</p>
<p>然后执行main中的Student s &#x3D; new Student(“狗娃”)，此时需要new Student，那么此时不会重新加载这个Student.class了，因为类文件加载过一次之后，在这个程序跑完之前，这个类文件是不会被卸载掉的了，因此，会使用之前加载过的这个Student.class了，来在堆内存中创建对象，然后才有实例变量name。</p>
<p>注意，类文件xx.class只要被jvm加载了，那么就只有等到整个程序执行结束了之后，才会卸载了，整个过程中，是不会卸载掉这个class文件的。</p>
<p>注意，一个方法执行完毕之后，那么这个方法在栈内存中所占用的空间就会马上被释放掉。因此，sleep()执行完毕之后，那么在栈内存中的空间就会马上释放掉。</p>
<p>注意，方法区中的Demo2.class字节码，以及里面的main方法字节码，是一直会加载在方法区中的，直到整个程序执行完毕，才会释放的。生命周期是加载到内存中之后直到整个程序执行完毕。</p>
<p>静态成员是在类加载的时候，执行，因此，它只被执行一次的。</p>
<p>注意，静态方法与非静态方法的字节码文件是同时存在内存中的。 只是静态的成员变量数据是优先于对象存在而已。</p>
<p>因为方法，都是字节码，都是在方法区中的。</p>
<img src="/2022/10/09/Java/JavaSE/09-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0&%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97&static&this/image-20221009230322413.png" class="" title="image-20221009230322413">

<p>方法区中的存放的都是字节码而已，就是代码而已，没有被执行的，死的。因此，只要class文件加载了，那么不管是静态方法还是非静态方法，它们的代码就都在方法区中了。而只有执行了这个方法，也就是调用了这个方法的时候，这个方法的代码（字节码）才会放到栈内存中去执行了。</p>
<p> 因此，对于非静态方法来说，它也是优先于对象而存在的，因为加载了class文件，那么非静态方法就在方法区中了。</p>
<p> <strong>This，代表调用者，也就是调用某个函数的那个对象。</strong></p>
<p> 对于非静态方法来说，调用它只能通过对象，那么此时对象就已经存在了，那么此时静态的成员变量老早就有了，同时实例变量也随着对象的创建而存在了的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name; <span class="comment">//名字</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span>	<span class="type">String</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>; <span class="comment">//国籍</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态代码块 ：静态代码块是在Student.class文件加载到内存的时候就马上执行的。</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;静态代码块执行了...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//非静态的成员函数</span></span><br><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;好好学习&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//静态函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;  <span class="comment">//静态方法与非静态方法的字节码文件是同时存在内存中 的。 只是静态的成员变量数据是优先于对象存在而已。</span></span><br><span class="line">		Student s= <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;铁蛋&quot;</span>);</span><br><span class="line">		System.out.println(s.name+<span class="string">&quot;呼呼大睡...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo2</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		Student.sleep();</span><br><span class="line">	<span class="comment">//	Student s = new Student(&quot;狗娃&quot;);</span></span><br><span class="line">	<span class="comment">//  s.sleep();//通过对象能够访问静态方法。</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>10-main方法&amp;工具类</title>
    <url>/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&amp;%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="10-main方法-amp-工具类"><a href="#10-main方法-amp-工具类" class="headerlink" title="10-main方法&amp;工具类"></a>10-main方法&amp;工具类</h1><h2 id="static成员变量默认值（补充）"><a href="#static成员变量默认值（补充）" class="headerlink" title="static成员变量默认值（补充）"></a>static成员变量默认值（补充）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		<span class="comment">//final int b=200;</span></span><br><span class="line">		<span class="comment">//System.out.println(i);</span></span><br><span class="line">		<span class="comment">//i=20;</span></span><br><span class="line">		System.out.println(<span class="string">&quot;static代码块执行&quot;</span>);</span><br><span class="line">		<span class="comment">//b=300;</span></span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//static int i=10;</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">float</span> f=<span class="number">23.5f</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		f=<span class="number">36.7f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//float f=23.5f;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	public void display()&#123;</span></span><br><span class="line"><span class="comment">//		System.out.println(b);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">		System.out.println(Person.i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>0</p>
<p><strong>因此，对于静态成员变量也是有默认值的。</strong></p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010100801599.png" class="" title="image-20221010100801599">

<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010100855545.png" class="" title="image-20221010100855545">

<p>上节已经说过，对于静态成员变量，如果在static代码块后面声明定义的，那么编译之后代码会重整，将static int i;这种声明提到类体最前面，然后静态代码块中只能对静态成员变量进行统一的初始化操作，即会将13行的初始化操作放入到static代码块中，但是在静态代码块中不能够直接使用这个静态成员变量，否则就会报错。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010101228790.png" class="" title="image-20221010101228790">

<p>充分说明static代码块中只能对static成员变量进行统一初始化，不能直接使用（当static成员变量定义在了static代码块后面的时候）。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010101406272.png" class="" title="image-20221010101406272">

<p>static成员变量，定义在static代码块前面的情况下就不会有这些问题。</p>
<hr>
<h2 id="main入口方法"><a href="#main入口方法" class="headerlink" title="main入口方法"></a>main入口方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main函数的详解：</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	public ： 公共的。 权限是最大，在任何情况下都可以访问。 不能使用private  </span></span><br><span class="line"><span class="comment">		原因： 为了保证让jvm在任何情况下都可以访问到main方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	static:  静态。静态可以让jvm调用main函数的时候更加的方便。不需要通过对象调用。</span></span><br><span class="line"><span class="comment">		不使用static的麻烦：</span></span><br><span class="line"><span class="comment">1.	需要创建对象调用。</span></span><br><span class="line"><span class="comment">2.	Jvm不知道如何创建对象，因为创建对象有些是需要参数的，参数传递什么东西呢？因为，我们没有办法人为指定参数，JVM不知道参数传什么。</span></span><br><span class="line"><span class="comment">	void:  没有返回值。 因为返回的数据是 给 jvm，而jvm使用这个数据是没有意义的。所以就不要了。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	main: 函数名。   注意： main并不是关键字,只不过是jvm能识别的一个特殊的函数名而已。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	arguments ：担心某些程序在启动需要参数。即某些程序可能启动的时候需要传入一些参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo4</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;数组的长度：&quot;</span>+ args.length);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;args.length ; i++)&#123;</span><br><span class="line">			System.out.print(args[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Args这个参数是只有运行程序那个时候，一次让用户输入的信息的，而且没有提示信息的。</p>
<p>而使用Scanner的话，可以程序过程中，任何时候，让用户输入数据的，而且还可以给用户提示输入什么信息。</p>
<p>因此，Scanner更加灵活的，args让用户输入信息这个现在很少有人用了。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010095122718.png" class="" title="image-20221010095122718">

<p>这个是jvm的启动文件，因此，jvm也是一个程序的。</p>
<p>因此，为了main能够让jvm这个程序调用到，也就是jvm在任何情况下都能够访问到这个main函数，因此，需要将main设置为public的。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010095328635.png" class="" title="image-20221010095328635">

<p>如果是private的话，那么出了这个类，外部就无法访问这个main了。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010095355172.png" class="" title="image-20221010095355172">

<p>如果只是使用无参的构造方法来创建对象，那么jvm是可以做到的。</p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010100330937.png" class="" title="image-20221010100330937">

<p>而如果这个类没有无参的构造方法，只有有参的构造方法，那么jvm不知道传递什么参数给这个构造方法的，因此，就没法创建对象了，也就没法调用main方法了。</p>
<p>因此，jvm为了避免这种情况，就定义main方法必须是static的了。</p>
<hr>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="自定义工具类"><a href="#自定义工具类" class="headerlink" title="自定义工具类"></a>自定义工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求：编写一个数组的工具类。</span></span><br><span class="line"><span class="comment">	Arrays.toString（）   [1,2,3,4];</span></span><br><span class="line"><span class="comment">	sort()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数组工具类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayTool</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span>  <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  i &lt; arr.length ; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (i==<span class="number">0</span>)&#123;</span><br><span class="line">				result+=<span class="string">&quot;[&quot;</span>+arr[i]+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==(arr.length-<span class="number">1</span>))&#123;</span><br><span class="line">				result+= arr[i]+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				result+=arr[i]+<span class="string">&quot;,&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span> ; j&lt;arr.length ; j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">					arr[i] = arr[j];</span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo3</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123;<span class="number">12</span>,<span class="number">1</span>,<span class="number">456</span>,<span class="number">165</span>&#125;;</span><br><span class="line">		<span class="comment">//ArrayTool tool = new ArrayTool();</span></span><br><span class="line"></span><br><span class="line">		ArrayTool.sort(arr);</span><br><span class="line">		<span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> ArrayTool.toString(arr);</span><br><span class="line">		System.out.println(<span class="string">&quot;数组的元素：&quot;</span>+ info);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上就是<span class="keyword">static</span>修饰方法的应用场景，用于工具类。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Arrays工具类"><a href="#Arrays工具类" class="headerlink" title="Arrays工具类"></a>Arrays工具类</h3><p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static String toString(数组)：将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3...]）</span></span><br><span class="line"><span class="comment">public static void sort(数组)：按照默认升序（从小到大）对数组的元素进行排序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">备注：</span></span><br><span class="line"><span class="comment">1. 如果是数值，sort默认按照升序从小到大</span></span><br><span class="line"><span class="comment">2. 如果是字符串，sort默认按照字母升序</span></span><br><span class="line"><span class="comment">3. 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（后续章节介绍）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Arrays</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] intArray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        <span class="comment">// 将int[]数组按照默认格式变成字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">intStr</span> <span class="operator">=</span> Arrays.toString(intArray);</span><br><span class="line">        System.out.println(intStr); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] array1 = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        Arrays.sort(array1);</span><br><span class="line">        System.out.println(Arrays.toString(array1)); <span class="comment">// [1, 2, 3, 6, 10]</span></span><br><span class="line"></span><br><span class="line">        String[] array2 = &#123;<span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(array2);</span><br><span class="line">        System.out.println(Arrays.toString(array2)); <span class="comment">// [aaa, bbb, ccc]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">请使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02ArraysPractise</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;asv76agfqwdfvasdfvjh&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如何进行升序排列：sort</span></span><br><span class="line">        <span class="comment">// 必须是一个数组，才能用Arrays.sort方法</span></span><br><span class="line">        <span class="comment">// String --&gt; 数组，用toCharArray</span></span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars); <span class="comment">// 对字符数组进行升序排列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chars.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(chars[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Math工具类"><a href="#Math工具类" class="headerlink" title="Math工具类"></a>Math工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public static double abs(double num)：获取绝对值。有多种重载。</span></span><br><span class="line"><span class="comment">public static double ceil(double num)：向上取整。</span></span><br><span class="line"><span class="comment">public static double floor(double num)：向下取整。</span></span><br><span class="line"><span class="comment">public static long round(double num)：四舍五入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Math.PI代表近似的圆周率常量（double）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Math</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取绝对值</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">3.14</span>)); <span class="comment">// 3.14</span></span><br><span class="line">        System.out.println(Math.abs(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">2.5</span>)); <span class="comment">// 2.5</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.9</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.1</span>)); <span class="comment">// 4.0</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.0</span>)); <span class="comment">// 3.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下取整，抹零</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">30.1</span>)); <span class="comment">// 30.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">30.9</span>)); <span class="comment">// 30.0</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">31.0</span>)); <span class="comment">// 31.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Math.round(<span class="number">20.4</span>)); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">10.5</span>)); <span class="comment">// 11</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//[0.0,1.0)之间的伪随机double值</span></span><br><span class="line">        <span class="comment">//random()   产生一个随机数. 大于等于 0.0 且小于 1.0 的伪随机 double 值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;随机数：&quot;</span>+Math.random());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010160013469.png" class="" title="image-20221010160013469">

<p><strong>获取到的是[0.0,1.0)之间的伪随机double值。</strong></p>
<img src="/2022/10/10/Java/JavaSE/10-main%E6%96%B9%E6%B3%95&%E5%B7%A5%E5%85%B7%E7%B1%BB/image-20221010160026036.png" class="" title="image-20221010160026036">

<p>这个random方法不是很好用，例如，如果获取0-10之间的随机数，那么它还得乘以10，然后取整才行。</p>
<p>Ceil是天花板的意思，所以是向上取整。</p>
<p>获取随机数，我们一般使用Random这个类来获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">计算在-10.8到5.9之间，绝对值大于6或者小于2.1的整数有多少个？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">1. 既然已经确定了范围，for循环</span></span><br><span class="line"><span class="comment">2. 起点位置-10.8应该转换成为-10，两种办法：</span></span><br><span class="line"><span class="comment">    2.1 可以使用Math.ceil方法，向上（向正方向）取整</span></span><br><span class="line"><span class="comment">    2.2 强转成为int，自动舍弃所有小数位</span></span><br><span class="line"><span class="comment">3. 每一个数字都是整数，所以步进表达式应该是num++，这样每次都是+1的。</span></span><br><span class="line"><span class="comment">4. 如何拿到绝对值：Math.abs方法。</span></span><br><span class="line"><span class="comment">5. 一旦发现了一个数字，需要让计数器++进行统计。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">备注：如果使用Math.ceil方法，-10.8可以变成-10.0。注意double也是可以进行++的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04MathPractise</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 符合要求的数量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> -<span class="number">10.8</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">5.9</span>;</span><br><span class="line">        <span class="comment">// 这样处理，变量i就是区间之内所有的整数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) min; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">abs</span> <span class="operator">=</span> Math.abs(i); <span class="comment">// 绝对值</span></span><br><span class="line">            <span class="keyword">if</span> (abs &gt; <span class="number">6</span> || abs &lt; <span class="number">2.1</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;总共有：&quot;</span> + count); <span class="comment">// 9</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>11-常用API之Scanner&amp;Random</title>
    <url>/2022/10/10/Java/JavaSE/11-%E5%B8%B8%E7%94%A8API%E4%B9%8BScanner&amp;Random/</url>
    <content><![CDATA[<h1 id="11-常用API之Scanner-amp-Random-amp-ArrayList"><a href="#11-常用API之Scanner-amp-Random-amp-ArrayList" class="headerlink" title="11-常用API之Scanner&amp;Random&amp;ArrayList"></a>11-常用API之Scanner&amp;Random&amp;ArrayList</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。</p>
<p><strong>API使用步骤</strong></p>
<ol>
<li>打开帮助文档。</li>
<li>点击显示，找到索引，看到输入框。</li>
<li>你要找谁？在输入框里输入，然后回车。</li>
<li>看包。<strong>java.lang下的类不需要导包，自动导入的，其他需要。</strong></li>
<li>看类的解释和说明。</li>
<li>学习构造方法。</li>
<li>使用成员方法。</li>
</ol>
<h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><p><strong>Scanner类：一个可以解析基本类型和字符串的简单文本扫描器。</strong> 例如，以下代码使用户能够从 System.in 中读取一个数。</p>
<p>提示：System.in 系统输入指的是通过键盘录入数据。</p>
<p><strong>Scanner使用步骤</strong></p>
<p><strong>查看类</strong></p>
<p>java.util.Scanner ：该类需要import导入后使用。</p>
<p><strong>查看构造方法</strong></p>
<p>public Scanner(InputStream source) : 构造一个新的 Scanner ，它生成的值是从指定的输入流扫描的。</p>
<p><strong>查看成员方法</strong></p>
<p>public int nextInt() ：将输入信息的下一个标记扫描为一个 int 值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 1. 导包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Scanner类的功能：可以实现键盘输入数据，到程序当中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">引用类型的一般使用步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 导包</span></span><br><span class="line"><span class="comment">import 包路径.类名称;</span></span><br><span class="line"><span class="comment">如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写。</span></span><br><span class="line"><span class="comment">只有java.lang包下的内容不需要导包（自动导入的），其他的包都需要import语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 创建</span></span><br><span class="line"><span class="comment">类名称 对象名 = new 类名称();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 使用</span></span><br><span class="line"><span class="comment">对象名.成员方法名()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">获取键盘输入的一个int数字：int num = sc.nextInt();//当执行到nextInt的时候，程序会阻塞在这里，等待用户输入</span></span><br><span class="line"><span class="comment">获取键盘输入的一个字符串：String str = sc.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Scanner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 创建</span></span><br><span class="line">        <span class="comment">// 备注：System.in代表从键盘进行输入，表示标准输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//将Scanner对象和标准输入对象关联</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取键盘输入的int数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();<span class="comment">//程序执行到这里会阻塞，等待用户输入内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入的int数字是：&quot;</span> + num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取键盘输入的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的字符串是：&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>练习</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">键盘输入两个int数字，并且求出和值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 既然需要键盘输入，那么就用Scanner</span></span><br><span class="line"><span class="comment">2. Scanner的三个步骤：导包、创建、使用</span></span><br><span class="line"><span class="comment">3. 需要的是两个数字，所以要调用两次nextInt方法</span></span><br><span class="line"><span class="comment">4. 得到了两个数字，就需要加在一起。</span></span><br><span class="line"><span class="comment">5. 将结果打印输出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02ScannerSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">键盘输入三个int数字，然后求出其中的最大值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 既然是键盘输入，肯定需要用到Scanner</span></span><br><span class="line"><span class="comment">2. Scanner三个步骤：导包、创建、使用nextInt()方法</span></span><br><span class="line"><span class="comment">3. 既然是三个数字，那么调用三次nextInt()方法，得到三个int变量</span></span><br><span class="line"><span class="comment">4. 无法同时判断三个数字谁最大，应该转换成为两个步骤：</span></span><br><span class="line"><span class="comment">    4.1 首先判断前两个当中谁最大，拿到前两个的最大值</span></span><br><span class="line"><span class="comment">    4.2 拿着前两个中的最大值，再和第三个数字比较，得到三个数字当中的最大值</span></span><br><span class="line"><span class="comment">5. 打印最终结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03ScannerMax</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第三个数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先得到前两个数字当中的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a &gt; b ? a : b;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> temp &gt; c ? temp : c;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值是：&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用匿名对象方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Anonymous</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通使用方式</span></span><br><span class="line"><span class="comment">//        Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        int num = sc.nextInt();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名对象的方式</span></span><br><span class="line"><span class="comment">//        int num = new Scanner(System.in).nextInt();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;输入的是：&quot; + num);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用一般写法传入参数</span></span><br><span class="line"><span class="comment">//        Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        methodParam(sc);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用匿名对象来进行传参</span></span><br><span class="line"><span class="comment">//        methodParam(new Scanner(System.in));</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> methodReturn();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的是：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">methodParam</span><span class="params">(Scanner sc)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的是：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Scanner <span class="title function_">methodReturn</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        Scanner sc = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//        return sc;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//使用匿名对象作为方法的返回值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><p>Random类：生成伪随机数。</p>
<p><strong>Random使用步骤：</strong></p>
<p><strong>查看类</strong></p>
<p>java.util.Random ：该类需要 import导入使后使用。</p>
<p><strong>查看构造方法</strong></p>
<p>public Random() ：创建一个新的随机数生成器。</p>
<p><strong>查看成员方法</strong></p>
<p>public int nextInt(int n) ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的int 值。<strong>左闭右开的。</strong></p>
<p><strong>提示：</strong>创建一个 Random 对象，每次调用 nextInt() 方法，都会生成一个随机数。</p>
<img src="/2022/10/10/Java/JavaSE/11-%E5%B8%B8%E7%94%A8API%E4%B9%8BScanner&Random/image-20221010160621306.png" class="" title="image-20221010160621306">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Random类用来生成随机数字。使用起来也是三个步骤：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 导包</span></span><br><span class="line"><span class="comment">import java.util.Random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 创建</span></span><br><span class="line"><span class="comment">Random r = new Random(); // 小括号当中留空即可</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 使用</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（范围是int类型的所有范围，有正负两类数字）：int num = r.nextInt()</span></span><br><span class="line"><span class="comment">获取一个随机的int数字（参数代表了范围，左闭右开区间）：int num = r.nextInt(3)</span></span><br><span class="line"><span class="comment">实际上代表的含义是：[0,3)，也就是0~2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Random</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;随机数是：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">//生成100个0到10之间的随机数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02Random</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>); <span class="comment">// 范围实际上是0~9</span></span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目要求：</span></span><br><span class="line"><span class="comment">根据int变量n的值，来获取随机数字，范围是[1,n]，可以取到1也可以取到n。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 定义一个int变量n，随意赋值</span></span><br><span class="line"><span class="comment">2. 要使用Random：三个步骤，导包、创建、使用</span></span><br><span class="line"><span class="comment">3. 如果写10，那么就是0~9，然而想要的是1~10，可以发现：整体+1即可。</span></span><br><span class="line"><span class="comment">4. 打印随机数字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03Random</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 本来范围是[0,n)，整体+1之后变成了[1,n+1)，也就是[1,n]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> r.nextInt(n) + <span class="number">1</span>;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">用代码模拟猜数字的小游戏。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">1. 首先需要产生一个随机数字，并且一旦产生不再变化。用Random的nextInt方法</span></span><br><span class="line"><span class="comment">2. 需要键盘输入，所以用到了Scanner</span></span><br><span class="line"><span class="comment">3. 获取键盘输入的数字，用Scanner当中的nextInt方法</span></span><br><span class="line"><span class="comment">4. 已经得到了两个数字，判断（if）一下：</span></span><br><span class="line"><span class="comment">    如果太大了，提示太大，并且重试；</span></span><br><span class="line"><span class="comment">    如果太小了，提示太小，并且重试；</span></span><br><span class="line"><span class="comment">    如果猜中了，游戏结束。</span></span><br><span class="line"><span class="comment">5. 重试就是再来一次，循环次数不确定，用while(true)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04RandomGame</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">randomNum</span> <span class="operator">=</span> r.nextInt(<span class="number">100</span>) + <span class="number">1</span>; <span class="comment">// [1,100]</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你猜测的数字：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">guessNum</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// 键盘输入猜测的数字</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (guessNum &gt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;太大了，请重试。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guessNum &lt; randomNum) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;太小了，请重试。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;恭喜你，猜中啦！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果猜中，不再重试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;游戏结束。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提示：while中的定义的guessNum是一个局部变量，出了while之后，就无法使用了，看不到。</strong></p>
<h3 id="验证码案例"><a href="#验证码案例" class="headerlink" title="验证码案例"></a>验证码案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.other;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">随机数类</span></span><br><span class="line"><span class="comment">Random</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需求： 编写一个函数随机产生四位的验证码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo5</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		Random random = new Random();</span></span><br><span class="line"><span class="comment">		int randomNum = random.nextInt(10)+1; //产生 的 随机数就是1-10之间</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;随机数：&quot;+ randomNum);</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="type">char</span>[] arr = &#123;<span class="string">&#x27;中&#x27;</span>,<span class="string">&#x27;国&#x27;</span>,<span class="string">&#x27;传&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">		<span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">		<span class="comment">//需要四个随机数，通过随机数获取字符数组中的字符，</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span>  <span class="operator">=</span> <span class="number">0</span> ; i&lt; <span class="number">4</span> ; i++)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> random.nextInt(arr.length);  <span class="comment">//产生的 随机数必须是数组的索引值范围之内的。</span></span><br><span class="line">			sb.append(arr[index]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;验证码：&quot;</span>+ sb);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/10/10/Java/JavaSE/11-%E5%B8%B8%E7%94%A8API%E4%B9%8BScanner&Random/image-20221010160933262.png" class="" title="image-20221010160933262">

<p>这就是验证码生成的方式。</p>
<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>13-再谈继承与多态</title>
    <url>/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="13-再谈继承与多态"><a href="#13-再谈继承与多态" class="headerlink" title="13-再谈继承与多态"></a>13-再谈继承与多态</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo6.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在现实生活中事物与事物之间是存在关系.</span></span><br><span class="line"><span class="comment">	球员----&gt;球队  整体与部分关系   has a 关系  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	学生-----&gt;人    继承的关系      is a 关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//球员类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Player</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> num; <span class="comment">//编码</span></span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Player</span><span class="params">(<span class="type">int</span> num , String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.num = num;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;开跑...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//球队类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Team</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;  <span class="comment">//球队的名字</span></span><br><span class="line"></span><br><span class="line">	Player p1;  <span class="comment">//球员1</span></span><br><span class="line"> </span><br><span class="line">	Player p2;   <span class="comment">//球员2</span></span><br><span class="line"></span><br><span class="line">	Player p3;  <span class="comment">//球员3</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Team</span><span class="params">(String name,Player p1,Player p2,Player p3)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.p1 = p1;</span><br><span class="line">		<span class="built_in">this</span>.p2 = p2;</span><br><span class="line">		<span class="built_in">this</span>.p3 = p3;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//开始比赛</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startGame</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;开赛啦！！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo6</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Player</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="number">12</span>,<span class="string">&quot;梅西&quot;</span>);</span><br><span class="line">		<span class="type">Player</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="number">7</span>,<span class="string">&quot;C罗&quot;</span>);</span><br><span class="line">		<span class="type">Player</span> <span class="variable">p3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="number">11</span>,<span class="string">&quot;内马尔&quot;</span>);</span><br><span class="line">		<span class="comment">//球队</span></span><br><span class="line">		<span class="type">Team</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Team</span>(<span class="string">&quot;恒大&quot;</span>,p1,p2,p3);</span><br><span class="line">		t.startGame();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;名字：&quot;</span>+ t.p2.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo7.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目前存在的问题：</span></span><br><span class="line"><span class="comment">	1. 无法描述清楚这两个类之间的继承关系。</span></span><br><span class="line"><span class="comment">	2. 存在着重复代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">面向对象的三大特征：</span></span><br><span class="line"><span class="comment">	1. 封装</span></span><br><span class="line"><span class="comment">	2. 继承</span></span><br><span class="line"><span class="comment">	3. 多态.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承：继承是通过关键字extends体现的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承的格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	class 类名1 extends 类名2&#123;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">继承要注意的事项：</span></span><br><span class="line"><span class="comment">	1. 千万不要为了减少重复代码而去继承，只有真正存在着继承关系的时候才去继承。</span></span><br><span class="line"><span class="comment">	2. 父类私有的成员不能被继承。</span></span><br><span class="line"><span class="comment">	3. 父类的构造函数不能被继承。</span></span><br><span class="line"><span class="comment">	4. 创建子类对象时默认会先调用父类无参的构造函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//人类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>	<span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">Person</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Person类的构造方法被调用了....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;在吃饭...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;  <span class="comment">// Student 就称作为Person类的子类， Person类就称作为Student的父类(超类、基类)</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num; <span class="comment">//学号</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Student类的构造方法被调用了....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;good good study , day day up&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo7</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		s.name = &quot;狗娃&quot;;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;名字：&quot;+ s.name);</span></span><br><span class="line"><span class="comment">		s.eat();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，private成员和构造函数，都不能够被继承的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo8.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">疑问： 为什么要调用父类的构造方法啊？这样子做的意义在那？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	调用父类 的构造方法是可以初始化从父类继承下去的属性的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu类d带参的构造方法...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu类无参的构造方法...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name); <span class="comment">//指定调用父类一个参数的构造函数。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;x1 = &quot;</span>+ x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo8</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>(<span class="string">&quot;大头儿子&quot;</span>); </span><br><span class="line">		System.out.println(<span class="string">&quot;name= &quot;</span>+z.name);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo9.java</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字代表了父类空间的引用。代表的是子类对象中父类部分的引用，也代表了对代码区中父类字节码部分的引用，因为要调父类的方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字的 作用：super的两个作用</span></span><br><span class="line"><span class="comment">	1. 子父类存在着同名的成员时，在子类中默认是访问子类的成员，可以通过super关键字指定访问父类的成员。</span></span><br><span class="line"><span class="comment">	2. 创建子类对象时，默认会先调用父类无参的构造方法，可以通过super关键字指定调用父类的构造方法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字调用父类构造方法要注意的事项：</span></span><br><span class="line"><span class="comment">	1. 如果在子类的构造方法上没有指定调用父类的构造方法，那么java编译器会在子类的构造方法上面第一条语句默认加上super()语句。表示对父类无参构造方法的调用。</span></span><br><span class="line"><span class="comment">	2. super关键字调用父类的构造函数时，该语句必须要是子类构造函数中的第一个语句。</span></span><br><span class="line"><span class="comment">	3. super与this关键字不能同时出现在同一个构造函数中调用其他的构造函数。因为两个语句都需要第一个语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">super关键字与this关键字的区别：</span></span><br><span class="line"><span class="comment">	1. 代表的事物不一致。</span></span><br><span class="line"><span class="comment">			1. super关键字代表的是父类空间的引用。	</span></span><br><span class="line"><span class="comment">			2. this关键字代表的是所属函数的调用者对象。</span></span><br><span class="line"><span class="comment">	2. 使用前提不一致。</span></span><br><span class="line"><span class="comment">			1. super关键字必须要有继承关系才能使用。</span></span><br><span class="line"><span class="comment">			2. this关键字不需要存在继承关系也可使用。</span></span><br><span class="line"><span class="comment">	3. 调用构造函数的区别：</span></span><br><span class="line"><span class="comment">			1. super关键字是调用父类的构造函数。</span></span><br><span class="line"><span class="comment">			2. this关键字是调用本类的构造函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">		</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu类无参的构造方法..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		System.out.println(<span class="string">&quot;Fu类带参的构造方法..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;小头爸爸吃番薯..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">20</span>; </span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name,<span class="type">int</span> num)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name); <span class="comment">//指定调用了父类带参的 构造方法...</span></span><br><span class="line">		<span class="built_in">this</span>(); <span class="comment">// 调用本类无参构造方法.. 会报错，this()和super()这种形式在构造方法中不能同时出现</span></span><br><span class="line">		<span class="comment">//super(); //指定调用了父类无参构造方法。。。</span></span><br><span class="line">		System.out.println(<span class="string">&quot;Zi类带参的构造方法..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Zi类无参的构造方法..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;x = &quot;</span> +<span class="built_in">super</span>.x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;大头儿子吃龙虾..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo9</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>(<span class="string">&quot;狗娃&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="方法的覆盖（重写）"><a href="#方法的覆盖（重写）" class="headerlink" title="方法的覆盖（重写）"></a>方法的覆盖（重写）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">目前的问题：父类的功能无法满足子类的需求。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法重写的前提： 必须要存在继承的关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的重写: 子父类出了同名的函数，这个我们就称作为方法的重写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法重写要注意的事项：</span></span><br><span class="line"><span class="comment">	1.方法重写时， 方法名与形参列表，必须一致。</span></span><br><span class="line"><span class="comment">	2.方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。</span></span><br><span class="line"><span class="comment">	3.方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。</span></span><br><span class="line"><span class="comment">	4.方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。</span></span><br><span class="line"><span class="comment">			Exception(最坏)</span></span><br><span class="line"><span class="comment">			RuntimeException(小坏)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的重载：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法重载的要求</span></span><br><span class="line"><span class="comment">	1. 函数名要一致。</span></span><br><span class="line"><span class="comment">	2. 形参列表不一致（形参的个数或形参 的类型不一致）</span></span><br><span class="line"><span class="comment">	3. 与返回值类型无关。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;  <span class="comment">//大的数据 类型 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;  <span class="comment">//Fish小 的数据类型。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line"></span><br><span class="line">	String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo10</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>(<span class="string">&quot;大头儿子&quot;</span>);</span><br><span class="line">		z.eat();</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。"><a href="#方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。" class="headerlink" title="方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。"></a>方法重写时，子类的方法的权限修饰符必须要大于或者等于父类的权限修饰符。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">protected</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;<span class="comment">//error</span></span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011172047637.png" class="" title="image-20221011172047637">

<p><strong>子类重写的方法，不能够降低访问权限修饰。</strong></p>
<h3 id="方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。"><a href="#方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。" class="headerlink" title="方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。"></a>方法重写时，子类的方法的返回值类型必须要小于或者等于父类的返回值类型。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Fish <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;<span class="comment">//error</span></span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011173611466.png" class="" title="image-20221011173611466">

<p>父类方法的返回值类型为Fish，子类覆盖方法的返回值类型是Animal，比父类的大了，不满足。</p>
<h3 id="方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。"><a href="#方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。" class="headerlink" title="方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。"></a>方法重写时，子类的方法抛出的异常类型要小于或者等于父类抛出的异常类型。</h3><p><strong>子类方法不能抛出比父类方法更多的异常。子类方法抛出的异常必须和父类方法抛出的异常相同，或者子类方法抛出的异常类是父类方法抛出的异常类的子类。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">public</span> Fish <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;<span class="comment">//error</span></span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011173926194.png" class="" title="image-20221011173926194">

<p>子类覆盖的方法比父类方法抛出更大的异常了，错误。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011174154348.png" class="" title="image-20221011174154348">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011174207646.png" class="" title="image-20221011174207646">

<p>这样是没问题的，只要抛出的不是更大的异常就没问题，可以抛出多个异常的。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011180022491.png" class="" title="image-20221011180022491">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011180049218.png" class="" title="image-20221011180049218">

<p>子类抛出了和父类没有任何关系的一个异常，错误。</p>
<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求：使用java描述一下普通的学生、 java基础班的学生、 就业班的学生。</span></span><br><span class="line"><span class="comment">所有的学生都会学习。但是学习的内容不一样。</span></span><br><span class="line"><span class="comment">普通 的学生： 马克思列宁主义。</span></span><br><span class="line"><span class="comment">基础班的学生：学习的是 javase。</span></span><br><span class="line"><span class="comment">就业班学生： javaee+android.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;学习马克思列宁主义&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础班的学生是属于学生中一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">BaseStudent</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用父类构造函数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;学习javase..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//就业班学生 也是属于普通学生中一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WorkStudent</span> <span class="keyword">extends</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造 函数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">WorkStudent</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//重写</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;学习javaee+android..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo11</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//System.out.println(&quot;Hello World!&quot;);</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">BaseStudent</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaseStudent</span>(<span class="string">&quot;居东东&quot;</span>);</span><br><span class="line">		s.study();</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建一个就业班的学生</span></span><br><span class="line">		<span class="type">WorkStudent</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkStudent</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">		w.study();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">instanceof 关键字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">instanceof关键字的作用：判断一个对象是否属于指定的类别。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">instanceof关键字的使用前提：判断的对象与指定的类别必须要存在继承或者实现的关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">instanceof关键字的使用格式：</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		对象  instanceof 类别</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">instanceof关键字的作用： 目前没用。但是后天我们学习 到了多态之后就非常有用。</span></span><br><span class="line"><span class="comment">一般我们做强制类型转换之前都会使用该关键字先判断一把，然后在进行转换的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	String color;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, String color)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//狗是属于动物中一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name,String color)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name,color); <span class="comment">//指定调用父类两个 参数的构造函数。</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bite</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;咬人!!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//老鼠 也是属于动物中一种</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mouse</span> <span class="keyword">extends</span>  <span class="title class_">Animal</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Mouse</span><span class="params">(String name,String color)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name,color);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dig</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;打洞..&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo12</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;哈士奇&quot;</span>,<span class="string">&quot;白色&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;狗是狗类吗？&quot;</span>+ (d <span class="keyword">instanceof</span> Dog));</span><br><span class="line">		System.out.println(<span class="string">&quot;狗是动物类吗？&quot;</span>+ (d <span class="keyword">instanceof</span> Animal));	</span><br><span class="line">		<span class="comment">//System.out.println(&quot;狗是老鼠类吗？&quot;+ (d instanceof Mouse));		// error编译报错 Incompatible conditional operand types Dog and Mouse</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;狗娃&quot;</span>,<span class="string">&quot;黄色&quot;</span>); <span class="comment">//狗娃是人</span></span><br><span class="line">		System.out.println(<span class="string">&quot;动物都是狗吗？&quot;</span>+ (a <span class="keyword">instanceof</span> Dog));<span class="comment">//编译正确，执行结果为false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011194704449.png" class="" title="image-20221011194704449">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011194736189.png" class="" title="image-20221011194736189">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011194813333.png" class="" title="image-20221011194813333">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011194851032.png" class="" title="image-20221011194851032">

<p><strong>注意，分为编译和运行时两个阶段。</strong></p>
<p><strong>编译时，只看左右两边操作数的类型是否是同一个继承树上，如果是，有继承关系，那么就没问题，如图蓝线部分。编译可以通过。</strong></p>
<p><strong>运行时，就看实际左边操作数引用变量实际指向的对象是谁，然后看它是否是右边操作数的实例了。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011195055084.png" class="" title="image-20221011195055084">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011195108736.png" class="" title="image-20221011195108736">

<p><strong>注意，new int[4]，它的类型是int[]，因为正常定义时int[] a &#x3D; new int[4];这样的，a的类型就是int[]。</strong></p>
<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承描述的是事物之间的所属关系，这种关系是： is-a 的关系。例如，图中兔子属于食草动物，食草动物属于动<br>物。可见，父类更通用，子类更具体。</p>
<p><strong>继承：</strong>就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接<br>访问父类中的<strong>非私有的属性和行为</strong>。</p>
<p>将相同类型的对象，进行抽象，得到类。相同对象中相同的内容，抽象为了类变量。</p>
<p>将各个类共有的内容进行抽象，得到父类。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011195755278.png" class="" title="image-20221011195755278">

<p>继承的好处：</p>
<ol>
<li>提高代码的复用性。</li>
<li>类与类之间产生了关系，是多态的前提。</li>
</ol>
<p>语法格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类：员工</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个员工的子类：讲师</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了员工的另一个子类：助教</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Assistant</span> <span class="keyword">extends</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在继承的关系中，“子类就是一个父类”。也就是说，子类可以被当做父类看待。</span></span><br><span class="line"><span class="comment">例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义父类的格式：（一个普通的类定义）</span></span><br><span class="line"><span class="comment">public class 父类名称 &#123;</span></span><br><span class="line"><span class="comment">    // ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定义子类的格式：</span></span><br><span class="line"><span class="comment">public class 子类名称 extends 父类名称 &#123;</span></span><br><span class="line"><span class="comment">    // ...</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Extends</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建了一个子类对象</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        <span class="comment">// Teacher类当中虽然什么都没写，但是会继承来自父类的method方法。</span></span><br><span class="line">        teacher.method();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建另一个子类助教的对象</span></span><br><span class="line">        <span class="type">Assistant</span> <span class="variable">assistant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Assistant</span>();</span><br><span class="line">        assistant.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="继承后成员变量问题"><a href="#继承后成员变量问题" class="headerlink" title="继承后成员变量问题"></a>继承后成员变量问题</h3><p>当类之间产生了关系后，其中各类中的成员变量，又产生了哪些影响呢？</p>
<p><strong>成员变量不重名</strong><br>如果子类父类中出现不重名的成员变量，这时的访问是没有影响的。</p>
<p><strong>成员变量重名</strong><br>如果子类父类中出现重名的成员变量，这时的访问是有影响的。</p>
<p>子父类中出现了同名的成员变量时，在子类中需要访问父类中<strong>非私有成员变量</strong>时，需要使用 super 关键字，修饰<br>父类成员变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.父类成员变量名</span><br></pre></td></tr></table></figure>

<p><strong>Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的（private成员和构造方法不会被继承）。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</strong></p>
<p><strong>私有的成员变量和私有成员方法，是不能够被继承的。</strong></p>
<p><strong>构造方法也不能够被继承。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numFu</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodFu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用的是本类当中的，不会向下找子类的</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numZi</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodZi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 因为本类当中有num，所以这里用的是本类的num，等价于this.num方式。</span></span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">直接通过子类对象访问成员变量：</span></span><br><span class="line"><span class="comment">    等号左边是谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment">间接通过成员方法访问成员变量：</span></span><br><span class="line"><span class="comment">    该方法属于谁，就优先用谁，没有则向上找。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ExtendsField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fu</span> <span class="variable">fu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fu</span>(); <span class="comment">// 创建父类对象</span></span><br><span class="line">        System.out.println(fu.numFu); <span class="comment">// 只能使用父类的东西，没有任何子类内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(zi.numFu); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(zi.numZi); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等号左边是谁，就优先用谁</span></span><br><span class="line">        System.out.println(zi.num); <span class="comment">// 优先子类，200</span></span><br><span class="line"><span class="comment">//        System.out.println(zi.abc); // 到处都没有，编译报错！</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个方法是子类的，优先用子类的，没有再向上找</span></span><br><span class="line">        zi.methodZi(); <span class="comment">// 200等价于methodZi(zi)</span></span><br><span class="line">        <span class="comment">// 这个方法是在父类当中定义的，</span></span><br><span class="line">        zi.methodFu(); <span class="comment">// 100等价于methodFu(zi)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011204327527.png" class="" title="image-20221011204327527">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011210826337.png" class="" title="image-20221011210826337">



<p>&#x2F;&#x2F; 这个方法是子类的，优先用子类的，没有再向上找</p>
<p>zi.methodZi(); &#x2F;&#x2F; 200等价于methodZi(zi)</p>
<p>&#x2F;&#x2F; 这个方法是在父类当中定义的</p>
<p>zi.methodFu(); &#x2F;&#x2F; 100等价于methodFu(zi)</p>
<p>说明：</p>
<p>zi.methodZi()等价于methodZi(zi)，因为看到zi是Zi类型的，因此，编译转换成对Zi类中的methodZi(zi)这种调用方式，因此，zi传递给methodZi中的this，methodZi的原型为public void methodZi(Zi this){}这样的，因此，this的类型为Zi，因此，zi对象传递给了this，因此，就是this.num这样，<strong>编译的时候</strong>，根据等号左边类型编译，因此，this的类型为Zi，里面有num，因此，编译通过，如果没有子类中没有num，那么就会去看继承的父类中是否有num，有，那么编译通过。<strong>然后运行的时候</strong>，this指向的是zi对象，因此，首先会在zi对象中找子类中的num，如果有就打印的就是zi对象中的子类中的num，如果没有就去找zi对象中从父类继承而来的那个num了。</p>
<p>zi.methodFu()等价于methodFu(zi)，因为看到zi是Zi类型，<strong>编译时候，</strong>因此，编译转换为了对Zi类型中的methodFu调用，但是Zi类型中没有methodFu方法的，但是它继承子Fu类，而父类中有methodFu方法的，因此，编译通过，去调用父类Fu中methodFu方法。因此，就是methodFu(zi)，将zi传递给了methodFu中的this，类型为Fu this，因为，父类型的引用指向子类型的对象，多态了。然后methodFu中打印num，即为this.num，编译阶段，this是Fu类型，里面有num，因此，编译通过。<strong>运行的时候，</strong>由于this指向的是子类的对象，但是this的类型是Fu，并且调用的是在Fu类中的methodFu方法中的，因此，其中的this表示指向调用者对象，那么这个调用者实际上就是子类对象中从父类继承过来的那个部分，也就是所谓的super了。因此，打印的时候，只能访问到Fu类中的num。</p>
<p><strong>因此，父类中的方法只能访问打印父类中的属性。子类中的方法可以打印访问子类中的属性，也可以打印访问从父类中继承而来的属性。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">	num=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    num=<span class="number">200</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fu fu&#x3D;new Zi();</p>
<p>fu.method()等给予method(fu)</p>
<p>编译的时候，看到fu是Fu类型，然后看到Fu中有method，因此，编译通过。</p>
<p>运行的时候，fu.method()会转换为method(fu)这种方式调用，因为多态，fu指向的是子类对象，因此，调用子类中的method方法，因此，fu传给子类method中的Zi this变量，这就是向下类型转换了，Zi this&#x3D;(Zi)fu;因此，this指向了子类对象，此时打印num，就是this.num，因此，打印子类对象中的num。如果子类中没有num，那么此时就会拿到子类对象中从父类继承而来的num了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">200</span>;</span><br><span class="line"><span class="comment">//    void method()&#123;</span></span><br><span class="line"><span class="comment">//       System.out.println(num);//等价于this.num</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo13</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">		zi.method();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	<span class="comment">//int num=200;</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(num);<span class="comment">//等价于this.num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo13</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">		zi.method();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>



<h3 id="继承后成员方法问题"><a href="#继承后成员方法问题" class="headerlink" title="继承后成员方法问题"></a>继承后成员方法问题</h3><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p>
<p><strong>成员方法不重名</strong> </p>
<p>如果子类父类中出现不重名的成员方法，这时的调用是没有影响的。</p>
<p>对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu类中的show方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zi类中的show2方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">ExtendsDemo04</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        <span class="comment">//子类中没有show方法，但是可以找到父类方法去执行</span></span><br><span class="line">        z.show(); </span><br><span class="line">        z.show2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 30，局部变量</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num); <span class="comment">// 20，本类的成员变量，如果没有局部变量，那么这里的this可以省略，因为先找局部变量，没有，就找到成员变量，如果成员变量也没有，那么就找父类中的成员变量了。</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num); <span class="comment">// 10，父类的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">局部变量：         直接写成员变量名</span></span><br><span class="line"><span class="comment">本类的成员变量：    this.成员变量名</span></span><br><span class="line"><span class="comment">父类的成员变量：    super.成员变量名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ExtendsField</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"></span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="成员方法重名—重写-Override"><a href="#成员方法重名—重写-Override" class="headerlink" title="成员方法重名—重写(Override)"></a>成员方法重名—重写(Override)</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011214258838.png" class="" title="image-20221011214258838">

<p>如果子类中出现与父类的成员方法重名的，这时的访问是一种特殊情况，叫做<strong>方法重写 (Override)。</strong></p>
<p><strong>方法重写 ：</strong>子类中出现与父类一模一样的方法时（<strong>返回值类型，方法名和参数列表都相同</strong>），会出现覆盖效果，也称为重写或者复写。声明不变，重新实现。<strong>注意，重写不要求返回值类型一致的。只需要方法名和参数列表一致即可。</strong></p>
<p><strong>重写时，用到super.父类成员方法，表示调用父类的成员方法。</strong></p>
<p><strong>注意事项</strong> </p>
<p>1、子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</p>
<p>2、子类方法覆盖父类方法，函数名和参数列表都要一模一样。</p>
<p><strong>方法覆盖重写的注意事项：</strong></p>
<ol>
<li>必须保证父子类之间方法的名称相同，参数列表也相同。<br>@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。<br>这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</li>
<li>子类方法的返回值类型范围必须【小于等于】父类方法的返回值类型范围。<br>小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</li>
<li>子类方法的权限必须【大于等于】父类方法的权限修饰符。<br>小扩展提示：public &gt; protected &gt; (default) &gt; private<br>备注：(default)不是关键字default，而是什么都不写，留空。</li>
<li>子类方法不能抛出比父类方法更多的异常。即子类方法抛出的异常必须和父类方法抛出的异常相同，或者子类方法抛出的异常类是父类方法抛出的异常类的子类。</li>
</ol>
<p>针对第4条：</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011223050869.png" class="" title="image-20221011223050869">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011223203851.png" class="" title="image-20221011223203851">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011223249643.png" class="" title="image-20221011223249643">





<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodFu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类重名方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodZi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类重名方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在父子类的继承关系当中，创建子类对象，访问成员方法的规则：</span></span><br><span class="line"><span class="comment">    创建的对象是谁，就优先用谁，如果没有则向上找。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意事项：</span></span><br><span class="line"><span class="comment">无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">重写（Override）</span></span><br><span class="line"><span class="comment">概念：在继承关系当中，方法的名称一样，参数列表也一样，返回值类型一样。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">重写（Override）：方法的名称一样，参数列表【也一样】，返回值类型一样。覆盖、覆写。</span></span><br><span class="line"><span class="comment">重载（Overload）：方法的名称一样，参数列表【不一样】。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01ExtendsMethod</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"></span><br><span class="line">        zi.methodFu();</span><br><span class="line">        zi.methodZi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建的是new了子类对象，所以优先用子类方法</span></span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fu show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">    <span class="comment">//子类重写了父类的show方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Zi show&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo05</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        <span class="comment">// 子类中有show方法，只执行重写后的show方法</span></span><br><span class="line">        z.show();  <span class="comment">// Zi show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>重写应用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;来电显示号码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NewPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重写父类的来电显示号码功能，并增加自己的显示姓名和图片功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用父类已经存在的功能使用super</span></span><br><span class="line">        <span class="built_in">super</span>.showNum();</span><br><span class="line">        <span class="comment">//增加自己特有显示姓名和图片功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;显示来电姓名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;显示头像&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">NewPhone</span> <span class="variable">np</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewPhone</span>()；</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用父类继承而来的方法</span></span><br><span class="line">        np.call();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 调用子类重写的方法</span></span><br><span class="line">        np.showNum();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重写时，用到<strong>super.父类成员方法，表示调用父类的成员方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法覆盖重写的注意事项：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 必须保证父子类之间方法的名称相同，参数列表也相同。</span></span><br><span class="line"><span class="comment">@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。</span></span><br><span class="line"><span class="comment">这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 子类方法的返回值类型范围必须【小于等于】父类方法的返回值类型范围。</span></span><br><span class="line"><span class="comment">小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 子类方法的权限必须【大于等于】父类方法的权限修饰符。</span></span><br><span class="line"><span class="comment">小扩展提示：public &gt; protected &gt; (default) &gt; private</span></span><br><span class="line"><span class="comment">备注：(default)不是关键字default，而是什么都不写，留空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Override</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	2. 子类方法的返回值必须【小于等于】父类方法的返回值范围。</span></span><br><span class="line"><span class="comment">	public class Fu &#123;</span></span><br><span class="line"><span class="comment">		public Object method() &#123;</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	public class Zi extends Fu &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		@Override</span></span><br><span class="line"><span class="comment">		public String method() &#123;//子类重写的方法的返回值类型小于等于父类的方法返回值类型正确。</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	public class Fu &#123;</span></span><br><span class="line"><span class="comment">		public String method() &#123;</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	public class Zi extends Fu &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		@Override</span></span><br><span class="line"><span class="comment">		public String method() &#123;//子类重写的方法的返回值类型小于等于父类的方法返回值类型正确。</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	public class Fu &#123;</span></span><br><span class="line"><span class="comment">		public String method() &#123;</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	public class Zi extends Fu &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		@Override</span></span><br><span class="line"><span class="comment">		public Object method() &#123;//子类重写的方法的返回值类型大于父类的方法返回值类型，错误。</span></span><br><span class="line"><span class="comment">			return null;</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="继承后的构造方法"><a href="#继承后的构造方法" class="headerlink" title="继承后的构造方法"></a>继承后的构造方法</h3><p>首先我们要回忆两个事情，构造方法的定义格式和作用。</p>
<p>1、构造方法的名字是与类名一致的。<strong>所以子类是无法继承父类构造方法的</strong>。构造方法不能继承。</p>
<p>2、构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构<br>造方法中默认有一个 super() ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">  Fu()&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Fu()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">  Zi()&#123;</span><br><span class="line">    <span class="comment">// super（），调用父类构造方法</span></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;Zi（）&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo07</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span>&#123;</span><br><span class="line">    <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Fu（）</span><br><span class="line">Zi（）</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类无参构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类有参构造！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(); <span class="comment">// 在调用父类无参构造方法</span></span><br><span class="line"><span class="comment">//        super(20); // 在调用父类重载的构造方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        super(); // 错误写法！只有子类构造方法，才能调用父类构造方法。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">继承关系中，父子类构造方法的访问特点：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。</span></span><br><span class="line"><span class="comment">2. 子类构造可以通过super关键字来指定调用父类中重载的不同的构造方法。</span></span><br><span class="line"><span class="comment">3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">子类必须调用父类构造方法，不写则赠送super()，即默认提供一个无参的super()调用；写了则用写的指定的super调用，super只能有一个，还必须是子类构造方法的第一条语句。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Constructor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字的用法有三种：</span></span><br><span class="line"><span class="comment">1. 在子类的成员方法中，访问父类的成员变量。</span></span><br><span class="line"><span class="comment">2. 在子类的成员方法中，访问父类的成员方法。</span></span><br><span class="line"><span class="comment">3. 在子类的构造方法中，访问父类的构造方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodZi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num); <span class="comment">// 父类中的num</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.method(); <span class="comment">// 访问父类中的method</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：</span></span><br><span class="line"><span class="comment">this用法也有三种：</span></span><br><span class="line"><span class="comment">1. 在本类的成员方法中，访问本类的成员变量。</span></span><br><span class="line"><span class="comment">2. 在本类的成员方法中，访问本类的另一个成员方法。</span></span><br><span class="line"><span class="comment">3. 在本类的构造方法中，访问本类的另一个构造方法。</span></span><br><span class="line"><span class="comment">在第三种用法当中要注意：</span></span><br><span class="line"><span class="comment">A. this(...)调用也必须是构造方法的第一个语句，唯一一个。</span></span><br><span class="line"><span class="comment">B. super和this两种构造调用，不能同时使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        super(); // 这一行不再赠送</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">123</span>); <span class="comment">// 本类的无参构造，调用本类的有参构造</span></span><br><span class="line"><span class="comment">//        this(1, 2); // 错误写法！当有了上面的this(123)的时候，这行就不能再有了。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 局部变量</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num); <span class="comment">// 本类中的成员变量</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num); <span class="comment">// 父类中的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.methodA();<span class="comment">//此时this可以省略不写。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，同一个类中的成员之间可以随意访问的，可以不使用this的。</strong></p>
<p><strong>图解：</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011230100475.png" class="" title="image-20221011230100475">

<p>[[super_class]]是javac编译之后，字节码中的一个特殊标记。它指向了父类。意思就是知道了它的父类是谁，就类似extends关键字一样，知道父类是谁了。<br>注意，堆中的子类对象中包含了一个完整的从父类继承而来内容。因此，肯定是先构造出父类内容，然后才在父类内容之外构造出子类对象的内容的。可以看到，堆中，只有一个子类对象的，只是这个子类对象中包含了从父类继承而来的内容。<br>父类内容中的0x method，这个是存的一个地址值，指向的是方法区中Fu.class中的method。<br><strong>this代表的就是子类对象。super就是代表的就是堆中子类对象中，父类内容这个部分。</strong><br>因此，现在对象就是一个两层嵌套结构，里面有父类的内容。</p>
<p>注意，子类中的method中调用super.method()，寻找过程也是先从super定位到堆中对象的父类内容这里，然后定位到0x method这个地址，然后通过它定位到方法区中的父类Fu.class中的method。</p>
<p><strong>注意，堆内存中只有一个子类对象的，只是该对象中包含了父类的内容。</strong></p>
<p>super两个含义，一个就表示了子类对象中从父类继承过来的那部分。另外一个就是字节码中子类部分指向父类的部分。</p>
<p>super.method()等价于method(super)，super传给了父类method方法中的Fu this变量了，因此，父类method中this.num，打印的就是子类对象中从父类继承而来的那部分。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011231250120.png" class="" title="image-20221011231250120">

<p>在每次创建子类对象时，现在堆区开辟空间，先初始化继承的父类成员部分的空间，再创建其子类成员部分空间。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。</p>
<p><strong>注意，父类中的private属性，在子类继承的时候，创建子类对象的时候，这个private属性也是在子类对象的堆空间中的，只是不能够直接访问到它，需要借助父类的方法去访问它而已。</strong></p>
<p><strong>因此，实际上private属性和方法也是可以被继承的。</strong></p>
<p><strong>super和this的含义</strong><br>    <strong>super ：代表父类的存储空间标识(可以理解为父类的引用)。即对子类对象中从父类继承而来的部分的引用，这个继承而来的部分也可以叫做父类对象，因此，也可以理解为super是对父类对象的引用。</strong><br>    <strong>this ：代表当前对象的引用(谁调用就代表谁)。</strong></p>
<p>this.成员变量       ‐‐    本类的</p>
<p>super.成员变量      ‐‐    父类的</p>
<p>this.成员方法名()    ‐‐    本类的    </p>
<p>super.成员方法名()   ‐‐    父类的</p>
<p>this(…)       ‐‐    本类的构造方法</p>
<p>super(…)      ‐‐    父类的构造方法</p>
<p>子类的每个构造方法中均有默认的super()，调用父类的无参构造。手动调用父类构造会覆盖默认的super()。</p>
<p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p>
<p><strong>构造方法和private成员变量成员方法，是不能够被继承的。</strong></p>
<p>这里说的private属性和方法不能继承，是说子类中不能够像继承了之后直接去使用他们，而实际上是继承了，只是需要借助父类去访问到它们的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal : eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat : eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eat();   <span class="comment">// this  调用本类的方法</span></span><br><span class="line">        <span class="built_in">super</span>.eat();  <span class="comment">// super 调用父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        a.eat();</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        c.eatTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">输出结果为：</span><br><span class="line">animal : eat</span><br><span class="line">cat : eat</span><br><span class="line">animal : eat</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.method(); <span class="comment">// 调用了父类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        System.out.println(num); <span class="comment">// 30</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.num); <span class="comment">// 20</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.num); <span class="comment">// 10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"></span><br><span class="line">        zi.show();</span><br><span class="line">        zi.method();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super，在子类重写的方法中又想调用父类中的被重写的方法，可以使用super。</p>
<p>super就代表父类。</p>
<p>特殊变量super，提供了对父类的访问。</p>
<p>可以使用super访问父类被子类隐藏的变量或者覆盖的方法。</p>
<p>每个子类构造方法的第一条语句，都是隐含的调用super()，如果父类没有这种形式的构造方法，那么编译就会报错。</p>
<p>注意，对于构造方法来说，是不能被继承的。不像其它的方法可以继承，构造方法是不能够被继承的。</p>
<p>由于构造方法不能够继承，所以，子类构造方法的第一条语句就是隐含的调用父类的构造方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	<span class="type">int</span> height,weight;</span><br><span class="line">	Animal(<span class="type">int</span> height,<span class="type">int</span> weight)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">	Fish()&#123;</span><br><span class="line">		Animal(<span class="number">30</span>,<span class="number">40</span>);<span class="comment">//由于构造方法不能够继承的，所以这样写错误的。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，super的含义，就是指向父类对象。this，就是指向当前对象。</p>
<h3 id="Java继承的三个特点"><a href="#Java继承的三个特点" class="headerlink" title="Java继承的三个特点"></a>Java继承的三个特点</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012153912672.png" class="" title="image-20221012153912672">

<p>方法的覆盖，发生在子类和父类之间的。</p>
<p>方法的重载，发生在同一个类中。</p>
<p>对于成员变量也是同理，子类定义类与父类同名的成员变量，即覆盖了父类的成员变量。</p>
<p><strong>private方法，出了当前类就无法访问，因此，也就无法覆盖。也就是private方法是不能被继承的。即使我们在子类中对父类的private方法覆盖，编译也没报错，但是，其实是没有覆盖成功的。实际上只是产生了一个新的private方法在子类中。</strong></p>
<p><strong>static方法同理，也是不能覆盖基类的static方法的。对于static成员，子类定义相同的是对父类的隐藏，而不是覆盖。</strong></p>
<p><strong>Private，static方法，不能够被继承，自然不能够被覆盖了。</strong></p>
<p><strong>private私有方法，构造方法，static方法，都不能够被继承。</strong></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012154516057.png" class="" title="image-20221012154516057">

<p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。<strong>我们把没有方法主体的方法称为抽象方法</strong>。Java语法规定，<strong>包含抽象方法的类就是抽象类。</strong></p>
<p><strong>定义</strong> </p>
<p>​	<strong>抽象方法 ： 没有方法体的方法。</strong></p>
<p>​	<strong>抽象类：包含抽象方法的类。</strong></p>
<p><strong>抽象方法</strong> </p>
<p>使用 abstract 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">abstract</span> 返回值类型 方法名 (参数列表);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<p><strong>抽象类</strong> </p>
<p>如果一个类包含抽象方法，那么该类必须是抽象类。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> class 类名字 &#123; </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>抽象的使用</strong> </p>
<p>继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的所有抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小猫在墙头走~~~&quot;</span>)；     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CatTest</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建子类对象</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); </span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 调用run方法</span></span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">小猫在墙头走~~~</span><br></pre></td></tr></table></figure>

<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法。</strong></p>
<p><strong>注意事项</strong></p>
<p><strong>1、抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</strong></p>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
<p><strong>2、抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</strong></p>
<p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p>
<p><strong>3、抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</strong></p>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设<br>计。</p>
<p><strong>4、抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象</strong><br><strong>类。</strong></p>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有<br>意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。</span></span><br><span class="line"><span class="comment">抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如何使用抽象类和抽象方法：</span></span><br><span class="line"><span class="comment">1. 不能直接创建new抽象类对象。</span></span><br><span class="line"><span class="comment">2. 必须用一个子类来继承抽象父类。</span></span><br><span class="line"><span class="comment">3. 子类必须覆盖重写抽象父类当中所有的抽象方法。</span></span><br><span class="line"><span class="comment">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。</span></span><br><span class="line"><span class="comment">4. 创建子类对象进行使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是普通的成员方法</span></span><br><span class="line"><span class="comment">//    public void normalMethod() &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Animal animal = new Animal(); // 错误写法！不能直接创建抽象类对象</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//抽象类中是可以有构造方法的，提供创建子类对象时初始化父类中成员变量的作用。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象父类构造方法执行！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// super();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Zi</span> <span class="variable">zi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        zi.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个抽象类不一定含有抽象方法，</span></span><br><span class="line"><span class="comment">只要保证抽象方法所在的类是抽象类，即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这样没有抽象方法的抽象类，也不能直接创建对象，在一些特殊场景下有用途。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyAbstract</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最高的抽象父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类也是一个抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public abstract void sleep();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog2Ha</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘿嘿嘿……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogGolden</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;呼呼呼……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        Animal animal = new Animal(); // 错误！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Dog dog = new Dog(); // 错误，这也是抽象类</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Dog2Ha</span> <span class="variable">ha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog2Ha</span>(); <span class="comment">// 这是普通类，可以直接new对象。</span></span><br><span class="line">        ha.eat();</span><br><span class="line">        ha.sleep();</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DogGolden</span> <span class="variable">golden</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogGolden</span>();</span><br><span class="line">        golden.eat();</span><br><span class="line">        golden.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="综合案例：群主发红包"><a href="#综合案例：群主发红包" class="headerlink" title="综合案例：群主发红包"></a>综合案例：群主发红包</h3><p>群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则：</p>
<ol>
<li>群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。</li>
<li>成员领取红包后，保存到成员余额中。</li>
</ol>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012161844760.png" class="" title="image-20221012161844760">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> money; <span class="comment">// 余额，也就是当前用户拥有的钱数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 展示一下当前用户有多少钱</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫：&quot;</span> + name + <span class="string">&quot;，我有多少钱：&quot;</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">// 群主的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title function_">send</span><span class="params">(<span class="type">int</span> totalMoney, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先需要一个集合，用来存储若干个红包的金额</span></span><br><span class="line">        ArrayList&lt;Integer&gt; redList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先看一下群主自己有多少钱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMoney</span> <span class="operator">=</span> <span class="built_in">super</span>.getMoney(); <span class="comment">// 群主当前余额</span></span><br><span class="line">        <span class="keyword">if</span> (totalMoney &gt; leftMoney) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> redList; <span class="comment">// 返回空集合</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扣钱，其实就是重新设置余额</span></span><br><span class="line">        <span class="built_in">super</span>.setMoney(leftMoney - totalMoney);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发红包需要平均拆分成为count份</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">avg</span> <span class="operator">=</span> totalMoney / count;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> totalMoney % count; <span class="comment">// 余数，也就是甩下的零头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除不开的零头，包在最后一个红包当中</span></span><br><span class="line">        <span class="comment">// 下面把红包一个一个放到集合当中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            redList.add(avg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后一个红包</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> avg + mod;</span><br><span class="line">        redList.add(last);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">// 普通成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Member</span> <span class="keyword">extends</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Member</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Member</span><span class="params">(String name, <span class="type">int</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receive</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">// 从多个红包当中随便抽取一个，给我自己。</span></span><br><span class="line">        <span class="comment">// 随机获取一个集合当中的索引编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(list.size());</span><br><span class="line">        <span class="comment">// 根据索引，从集合当中删除，并且得到被删除的红包，给我自己</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">delta</span> <span class="operator">=</span> list.remove(index);</span><br><span class="line">        <span class="comment">// 当前成员自己本来有多少钱：</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="built_in">super</span>.getMoney();</span><br><span class="line">        <span class="comment">// 加法，并且重新设置回去</span></span><br><span class="line">        <span class="built_in">super</span>.setMoney(money + delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainRedPacket</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>(<span class="string">&quot;群主&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Member</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;成员A&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Member</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;成员B&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Member</span> <span class="variable">three</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Member</span>(<span class="string">&quot;成员C&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        manager.show(); <span class="comment">// 100</span></span><br><span class="line">        one.show(); <span class="comment">// 0</span></span><br><span class="line">        two.show(); <span class="comment">// 0</span></span><br><span class="line">        three.show(); <span class="comment">// 0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===============&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 群主总共发20块钱，分成3个红包</span></span><br><span class="line">        ArrayList&lt;Integer&gt; redList = manager.send(<span class="number">20</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 三个普通成员收红包</span></span><br><span class="line">        one.receive(redList);</span><br><span class="line">        two.receive(redList);</span><br><span class="line">        three.receive(redList);</span><br><span class="line"></span><br><span class="line">        manager.show(); <span class="comment">// 100-20=80</span></span><br><span class="line">        <span class="comment">// 6、6、8，随机分给三个人</span></span><br><span class="line">        one.show();</span><br><span class="line">        two.show();</span><br><span class="line">        three.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>abstract，抽象类，含有抽象方法的类就是抽象类。如果一个子类没有实现抽象基类中的所有的抽象方法，那么这个子类也是一个抽象类。我们可以将一个没有任何抽象方法的类声明为abstract，从而避免由这个类产生任何的对象。抽象类不能够实例化的。</p>
<p>java中就提供了这样的类，里面的所有方法都是实现了的，但是都是空实现，然后将这个类定义为抽象类，然后我们要去继承这个类，然后至少重写其中的一个方法，然后用这个类去实例化对象，这样实例化出的对象才有意义。适配器模式</p>
<p>抽象类通常是将共性的东西抽象出来，例如，Animal类，其中的sleep方法定义为抽象方法，然后Animal自然就是抽象类，然后子类中去实现这个sleep方法，站着睡觉的就站着，躺着睡觉的就躺着实现的。</p>
<hr>
<h2 id="以下内容来自读书笔记"><a href="#以下内容来自读书笔记" class="headerlink" title="以下内容来自读书笔记"></a>以下内容来自读书笔记</h2><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012170556312.png" class="" title="image-20221012170556312">

<p>注意，这里说的sub继承了父类中的内容，是说sub子类的方法中可以直接访问的意思。</p>
<p>例如，同一个包中，子类可以继承父类中的public，protected，default的成员，意思是说子类的方法中可以直接访问这些成员的。而对于父类中的private成员，实际上在创建子类对象的时候，会调用父类构造方法，也对这些父类中的private成员进行初始化的，这些内容也是放在了堆中子类对象空间中的，只是子类的方法中没有办法直接访问到它而已。</p>
<p>对于不同包中，也是同理。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012171015496.png" class="" title="image-20221012171015496">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012171202196.png" class="" title="image-20221012171202196">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012172327161.png" class="" title="image-20221012172327161">



<h3 id="继承注意事项"><a href="#继承注意事项" class="headerlink" title="继承注意事项"></a>继承注意事项</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012173201014.png" class="" title="image-20221012173201014">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012173221688.png" class="" title="image-20221012173221688">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012173331321.png" class="" title="image-20221012173331321">





<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012173618521.png" class="" title="image-20221012173618521">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174015393.png" class="" title="image-20221012174015393">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174221077.png" class="" title="image-20221012174221077">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174334234.png" class="" title="image-20221012174334234">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174436178.png" class="" title="image-20221012174436178">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174752383.png" class="" title="image-20221012174752383">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174833381.png" class="" title="image-20221012174833381">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012174925165.png" class="" title="image-20221012174925165">

<p>说明：注意，new Sub()的时候，是堆中先开辟对象的空间，然后该对象就有了，然后调用构造方法的时候，将该对象传入，即类似Sub(sub)这样，然后构造方法中Sub this接收这个对象，子类构造方法第一条语句就是隐含调用super()，即调用父类构造方法初始化子类对象中从父类继承而来的部分。调用super()，类似this.super()这样，即子类对象调用super()这样，子类没有就去找父类中的方法，实际上就是调父类中的Base()方法，然后this传入，super(this)，即Base(this)，然后Base this接收传入的这个this（父类引用指向了子类对象），传入的this是子类对象，因此，Base()构造方法中的this也指向了子类这个对象了，然后Base()中调用method，等价于this.method()（编译的时候根据等号左边引用变量类型找方法，this是Base类型，因此，它里面有method方法，编译通过），this现在指向子类对象的，因此，运行的时候，动态绑定，多态，因此，指向谁就调谁的方法，因此，调的就是子类对象中的method方法了，如果子类没有重写，那么就调父类中的method方法了。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200533496.png" class="" title="image-20221012200533496">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200917581.png" class="" title="image-20221012200917581">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200932443.png" class="" title="image-20221012200932443">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200944976.png" class="" title="image-20221012200944976">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012200957897.png" class="" title="image-20221012200957897">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201007680.png" class="" title="image-20221012201007680">



<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201431209.png" class="" title="image-20221012201431209">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201459999.png" class="" title="image-20221012201459999">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201521268.png" class="" title="image-20221012201521268">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201615650.png" class="" title="image-20221012201615650">

<p><strong>参数签名：参数的类型，个数，顺序</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201708712.png" class="" title="image-20221012201708712">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201759241.png" class="" title="image-20221012201759241">



<h3 id="方法覆盖（重写）"><a href="#方法覆盖（重写）" class="headerlink" title="方法覆盖（重写）"></a>方法覆盖（重写）</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012201916678.png" class="" title="image-20221012201916678">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012203241526.png" class="" title="image-20221012203241526">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Fu</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Animal <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">		System.out.println(name+<span class="string">&quot;吃番薯...&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span> &#123;</span><br><span class="line">	String num;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Zi</span><span class="params">(String name)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(name);<span class="comment">//指定调用 父类带参的构造方法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="comment">//重写父类的eat方法</span></span><br><span class="line">	<span class="keyword">public</span> Fish <span class="title function_">eat</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException&#123;<span class="comment">//ok</span></span><br><span class="line">		System.out.println(<span class="string">&quot;吃点开胃菜..&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝点汤....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点龙虾....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃青菜....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;喝两杯....&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;吃点甜品....&quot;</span>);	</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Fish</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明，实际上，子类要覆盖的方法的返回值类型小于等于父类方法的返回值类型即可，不一定非要一致。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204016404.png" class="" title="image-20221012204016404">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204128338.png" class="" title="image-20221012204128338">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204226544.png" class="" title="image-20221012204226544">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204406488.png" class="" title="image-20221012204406488">

<p><strong>父类的静态方法不能被子类覆盖为非静态方法。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204505020.png" class="" title="image-20221012204505020">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012204742596.png" class="" title="image-20221012204742596">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012205312174.png" class="" title="image-20221012205312174">

<p><strong>注意，static方法只能被隐藏，而不能被覆盖的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span>&#123;<span class="comment">//error</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012205211564.png" class="" title="image-20221012205211564">



<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012205440063.png" class="" title="image-20221012205440063">

<p><strong>非静态不能覆盖为静态。</strong></p>
<p><strong>静态也不能覆盖为非静态。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012205549915.png" class="" title="image-20221012205549915">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012210033273.png" class="" title="image-20221012210033273">

<p>如果Base中的showMe改成public，那么运行的时候就是多态动态绑定机制了。</p>
<p>Base中的print中的调用showMe，等价于this.showMe()，sub.print()的时候，等价于print(sub)，因此，Base中的Base this接收sub，父类引用指向子类对象，然后运行的时候，this.showMe()，由于子类的showMe()对父类的showMe()不构成覆盖关系，因此，根据多态，Base this现在指向sub子类对象，根据多态，找子类中的覆盖的showMe()，但是现在没有，因此，就向上找继承的父类中的showMe()，虽然父类的showMe()是private，不能继承的，但是仍然可以这样理解，不冲突。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211511585.png" class="" title="image-20221012211511585">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211659102.png" class="" title="image-20221012211659102">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211745677.png" class="" title="image-20221012211745677">

<p><strong>实例方法可以覆盖为抽象方法。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211921105.png" class="" title="image-20221012211921105">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012211936675.png" class="" title="image-20221012211936675">



<h3 id="super-1"><a href="#super-1" class="headerlink" title="super"></a>super</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012212330410.png" class="" title="image-20221012212330410">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012213113031.png" class="" title="image-20221012213113031">

<p>注意，最后两个等价的。</p>
<p>注意，super的类型就是Base，因此，super.method()，编译的时候根据变量类型，看里面有method方法，编译通过。执行的时候，super指向的就是子类对象中的父类对象部分，因此，调用的就是父类中的method方法。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012214512052.png" class="" title="image-20221012214512052">

<p><strong>静态方法和静态代码块中不能使用this和super。</strong></p>
<p>因为this和super都是指向子类对象和子类对象中继承来的父类部分的，而静态方法和静态代码块，是可以没有对象的。</p>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012215632209.png" class="" title="image-20221012215632209">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012215747775.png" class="" title="image-20221012215747775">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012215807440.png" class="" title="image-20221012215807440">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012215912513.png" class="" title="image-20221012215912513">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220524259.png" class="" title="image-20221012220524259">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220553576.png" class="" title="image-20221012220553576">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220646449.png" class="" title="image-20221012220646449">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220752921.png" class="" title="image-20221012220752921">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220923111.png" class="" title="image-20221012220923111">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012220943663.png" class="" title="image-20221012220943663">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012221439049.png" class="" title="image-20221012221439049">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012221611489.png" class="" title="image-20221012221611489">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012221750898.png" class="" title="image-20221012221750898">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012221820731.png" class="" title="image-20221012221820731">

<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012222213284.png" class="" title="image-20221012222213284">

<p><strong>注意，只有实例方法和引用变量实际指向的对象，才是动态绑定（运行期行为）。其他的都是静态绑定（编译器行为）。</strong></p>
<p><strong>对于实例变量，who.var访问的也是base中的，实际上就是堆中子类对象中的父类部分的内容。这不是多态，因为编译阶段，就可以知道who的类型是Base，然后想要拿到的就是父类中的内容，也就是子类对象中的父类部分的内容。虽然运行的时候who指向的是子类对象，但是这是编译期行为已经确定了，因此，虽然who运行时指向的是子类对象，但是拿到是子类对象中从父类继承而来的那个部分的内容。</strong></p>
<p><strong>对于静态的变量和方法，都是跟类绑定的，属于类，而不属于具体的实例对象的。</strong></p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012223301303.png" class="" title="image-20221012223301303">

<p>说明：这里属于动态绑定了，调用test()，test()中的是this.method()，this是CLASS A类型的，此时this指向子类对象new B()，那么运行的时候，根据动态绑定机制，指向的是子类对象，因此，调用子类中的方法method。可以思考内存图。</p>
<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012224342117.png" class="" title="image-20221012224342117">





<img src="/2022/10/12/Java/JavaSE/13-%E5%86%8D%E8%B0%88%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221012224428395.png" class="" title="image-20221012224428395">



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下mysql手动安装方式</title>
    <url>/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Windows环境下mysql手动方式安装"><a href="#Windows环境下mysql手动方式安装" class="headerlink" title="Windows环境下mysql手动方式安装"></a>Windows环境下mysql手动方式安装</h1><p><a href="https://mirrors.huaweicloud.com/mysql/Downloads/MySQL-6.0/">https://mirrors.huaweicloud.com/mysql/Downloads/MySQL-6.0/</a></p>
<p>下载地址</p>
<img src="/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/Image.png" class="" title="Image">

<p>32位或者64位均可</p>
<img src="/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/Image-1664900250792-2.png" class="" title="Image">

<p>解压放在一个非中文目录下</p>
<img src="/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/Image-1664900274221-4.png" class="" title="Image">

<p>配置环境变量。</p>
<p>将配置文件复制到目录中，并且名称必须是my.ini，否则就需要通过参数指定配置文件了。</p>
<img src="/2022/10/05/MySQL/Install/Windows%E4%B8%8Bmysql%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/Image-1664900317498-6.png" class="" title="Image">

<p>my.ini文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">port=3306</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=gbk</span><br><span class="line">[mysqld]</span><br><span class="line">port=3306</span><br><span class="line">basedir=&quot;C:/App/mysql-6.0.11-alpha-win32&quot;</span><br><span class="line">datadir=&quot;C:/App/mysql-6.0.11-alpha-win32/data&quot;</span><br><span class="line">default-character-set=gbk</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">sql-mode=&quot;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</span><br><span class="line">max_connections=800</span><br><span class="line">query_cache_size=84M</span><br><span class="line">table_cache=1520</span><br><span class="line">tmp_table_size=30M</span><br><span class="line">thread_cache_size=38</span><br><span class="line">myisam_max_sort_file_size=100G</span><br><span class="line">myisam_sort_buffer_size=30M</span><br><span class="line">key_buffer_size=129M</span><br><span class="line">read_buffer_size=64K</span><br><span class="line">read_rnd_buffer_size=256K</span><br><span class="line">sort_buffer_size=256K</span><br><span class="line">innodb_additional_mem_pool_size=6M</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_log_buffer_size=3M</span><br><span class="line">innodb_buffer_pool_size=250M</span><br><span class="line">innodb_log_file_size=50M</span><br><span class="line">innodb_thread_concurrency=10</span><br></pre></td></tr></table></figure>

<p>注意，该配置文件是从图形界面方式安装的mysql之后，从其my.ini配置文件中提取出来的内容。</p>
<p>之后，可以将mysql安装为Windows服务</p>
<p>PS C:\Users\Administrator&gt; mysqld –install MySQL –defaults-file&#x3D;”C:\App\mysql-6.0.11-alpha-win32\my.ini”</p>
<p>Service successfully installed.</p>
<p>PS C:\Users\Administrator&gt;</p>
<p>之后，就可以在services.msc中看到MySQL这个名字的Windows服务了。</p>
<p>这里要注意，上面mysqld命令的参数顺序，不要颠倒了，否则不生效。</p>
<p>PS C:\Users\Administrator&gt; mysqld –defaults-file&#x3D;”C:\App\mysql-6.0.11-alpha-win32\my.ini” –install MySQL</p>
<p>PS C:\Users\Administrator&gt;</p>
<p>这样就不行。</p>
<p>如果想要安装的Windows服务，不是自动启动的，可以–install-manual参数。</p>
<p>如果不想安装为Windows服务，想要直接在命令行下运行，并且看到实时输出，可以如下：</p>
<p>mysqld –defaults-file&#x3D;”C:\App\mysql-6.0.11-alpha-win32\my.ini” –console 即可。</p>
<p>删除MySQL服务</p>
<p>mysqld –remove MySQL即可。</p>
<hr>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>Install</category>
      </categories>
      <tags>
        <tag>MySQL-install</tag>
      </tags>
  </entry>
  <entry>
    <title>12-继承与多态</title>
    <url>/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="12-继承与多态"><a href="#12-继承与多态" class="headerlink" title="12-继承与多态"></a>12-继承与多态</h1><h2 id="方法重载复习"><a href="#方法重载复习" class="headerlink" title="方法重载复习"></a>方法重载复习</h2><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010170742931.png" class="" title="image-20221010170742931">

<p>方法重载（Overload）。表示两个或多个方法名字相同，但方法参数不同。</p>
<p>方法参数不同有两层含义：</p>
<p>1）参数个数不同。</p>
<p>2）参数类型不同。 </p>
<p>【注意】：方法的返回值对重载没有任何影响。</p>
<p><strong>不能根据返回值的类型来重载两个方法。</strong></p>
<p>构造方法也是可以重载的。</p>
<p>如果自己不定义构造方法，那么java会提供一个不带参数的默认构造方法，函数体是空的。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200659438.png" class="" title="image-20221010200659438">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200705686.png" class="" title="image-20221010200705686">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200713902.png" class="" title="image-20221010200713902">

<p>构造方法没有返回值。</p>
<p>构造方法之间也可以互相之间进行调用。但是注意，构造方法不能直接通过方法名来进行调用的，需要通过this来调用。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200821097.png" class="" title="image-20221010200821097">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200831348.png" class="" title="image-20221010200831348">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200840333.png" class="" title="image-20221010200840333">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200859875.png" class="" title="image-20221010200859875">

<p>这样写this报错。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200913085.png" class="" title="image-20221010200913085">

<p>编译错误。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010200923724.png" class="" title="image-20221010200923724">

<p><strong>构造方法重载：</strong>只需看参数即可。如果想在一个构造方法中调用另外一个构造方法，那么可以使用this()的方式调用，this()括号中的参数表示目标构造方法的参数。this()必须要作为构造方法的第一条语句，换句话说，this()之前不能有任何可执行的代码。</p>
<p>为什么说方法的返回值对重载没有任何影响？对比如下两个程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b + c;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">OverloadTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OverloadTest</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> test.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">		System.out.println(result);</span><br><span class="line">		System.out.println(result2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src\Lesson <span class="number">1</span>&gt;java OverloadTest</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">OverloadTest2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OverloadTest2</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test.method(<span class="number">1</span>);</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> test.method(<span class="number">2</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010201054480.png" class="" title="image-20221010201054480">

<p>原因如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test.method(<span class="number">1</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> test.method(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>也可以写成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">test.method(<span class="number">1</span>);</span><br><span class="line">   test.method(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>当写成这种形式时，程序无法判断是否要调用哪个method方法，尽管他们返回值也不一样，所以返回值不能做重载的依据，重载的依据是根据它的参数来定的。</p>
<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010201720019.png" class="" title="image-20221010201720019">

<p><strong>继承（Inheritence）：Java是单继承的</strong>，意味着一个类只能从另一个类继承（被继承的类叫做父类【基类，base class】,继承的类叫做子类），<strong>Java中的继承使用extends关键字</strong>。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010201835653.png" class="" title="image-20221010201835653">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010201842422.png" class="" title="image-20221010201842422">

<p>首先new Child()的时候，会调用子类的不带参数的构造方法，找到，然后子类构造方法又会去调用父类的不带参数的构造方法。因此，是先调用父类构造方法，然后再执行子类构造方法。</p>
<p><strong>没有父亲，就没有孩子。注意，内存模型想象成就只有一个子类对象，然后这个子类对象中有需要父类对象的东西而已，就像孩子继承了父亲的一些特点一样，例如，眼睛，鼻子的特点，但是孩子仍然是单独的自己一个对象。不要认为在内存中是两个对象，一个父类对象，一个子类对象，这样不正确。</strong></p>
<p><strong>当执行子类的构造方法的时候，首先在执行第一行语句之前，首先是去寻找父类的不带参数的构造方法。</strong>即子类构造方法的第一句都是隐含的调用super()。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204500101.png" class="" title="image-20221010204500101">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204506951.png" class="" title="image-20221010204506951">

<p><strong>根据提示，是找父类的不带参数的那个构造方法，也就是默认的构造方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204652409.png" class="" title="image-20221010204652409">

<p><strong>注意，这里说法有问题，堆内存中就一个子类对象，只是子类对象中包含了从父类继承而来的属性，也可以简单的理解为这是父类对象。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204822093.png" class="" title="image-20221010204822093">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010204838623.png" class="" title="image-20221010204838623">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;no args parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="super第一种用法（调用父类指定构造方法）"><a href="#super第一种用法（调用父类指定构造方法）" class="headerlink" title="super第一种用法（调用父类指定构造方法）"></a>super第一种用法（调用父类指定构造方法）</h3><p><strong>super</strong>，表示对父类对象的引用。即对堆内存中唯一的子类对象中父类属性部分的引用，也可以简单理解为对父类对象的引用。指向父类对象</p>
<p><strong>this，表示对当前自己的这个对象的引用。</strong>指向当前对象</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010205230808.png" class="" title="image-20221010205230808">

<p><strong>显示指定，调用父类的哪个构造方法</strong>。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010205255628.png" class="" title="image-20221010205255628">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">super</span>(<span class="number">7</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;child&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	public Parent()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;no args parent&quot;);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>super关键字：super表示对父类对象的引用。注意与this的关键字的区别</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010205535976.png" class="" title="image-20221010205535976">

<p><strong>如果子类使用super()显式调用父类的某个构造方法，那么在执行的时候就会寻找与super()所对应的构造方法而不会再去寻找父类的不带参数的构造方法。与this一样，super也必须要作为构造方法的第一条执行语句，前面不能有其他可执行语句。</strong></p>
<p>因此，可以知道，super()和this()不能在构造方法中同时出现的。</p>
<p>Super的目的，就是严格保证必须要先生成父类对象，然后再生成子类对象。否则父类对象没生成，那么子类就什么都干不了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> demo01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">this</span>(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//error Constructor call must be the first statement in a constructor</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(a,b);</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010205844149.png" class="" title="image-20221010205844149">

<p>父类对象和子类对象的内存地址排列是这样的，也就是内存地址中有两个对象了，一个是child一个是parent，它们在内存中是挨着放置的，连着放置的，然后child指向的是孩子这个对象，又，子类对象可以使用父类对象的某些东西，原因就是地址是连着存放的，因此，子类能够拿到父类对象的东西，知道父类对象在什么地方。</p>
<p>因此，一定要记住，继承的时候，一定是生成多个对象，每个层次都会生成对应的对象的。</p>
<p><strong>这里的说法是错误的。</strong></p>
<p><strong>注意，上面说法是错误的，堆中只有一个new的子类的那个对象，只是该对象中属性分为两部分，分别是来自继承父类的属性和子类自己的属性。注意，如果有多个层次继承关系，那么每个层次的属性，最终都会在new的最终这个子类对象当中的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210643613.png" class="" title="image-20221010210643613">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210650805.png" class="" title="image-20221010210650805">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210803343.png" class="" title="image-20221010210803343">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210818793.png" class="" title="image-20221010210818793">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">		System.out.println(apple.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;fruit&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>





<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210908959.png" class="" title="image-20221010210908959">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210917981.png" class="" title="image-20221010210917981">

<p>子类继承了，但是可以覆盖成自己的特点。</p>
<p><strong>可以对父类的属性name进行修改</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">		System.out.println(apple.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;fruit&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210944059.png" class="" title="image-20221010210944059">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010210951972.png" class="" title="image-20221010210951972">

<p>这个表示的就是父类没有的属性，子类可以有。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Apple</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">		System.out.println(apple.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	String name = &quot;fruit&quot;;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010211155026.png" class="" title="image-20221010211155026">

<p><strong>关于继承的3点：</strong></p>
<p>a) 父类有的，子类也有</p>
<p>b) 父类没有的，子类可以增加</p>
<p>c) 父类有的，子类可以改变</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010211224785.png" class="" title="image-20221010211224785">

<p><strong>关于继承的注意事项</strong></p>
<p>a) <strong>构造方法不能被继承</strong></p>
<p>b) 方法和属性可以被继承</p>
<p>c) <strong>子类的构造方法隐式地调用父类的不带参数的构造方法</strong></p>
<p>d) 当父类没有不带参数的构造方法时，子类需要使用super来显式地调用父类的构造方法，super指的是对父类的引用</p>
<p>e) super关键字必须是构造方法中的第一行语句。</p>
<p><strong>如果不显示调用super方法，那么每个子类构造方法的第一条语句都是隐含调用super()的。</strong></p>
<hr>
<h2 id="多态剖析"><a href="#多态剖析" class="headerlink" title="多态剖析"></a>多态剖析</h2><p>继承过程中，方法和属性类似，但是方法多点内容。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010211919029.png" class="" title="image-20221010211919029">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010211947387.png" class="" title="image-20221010211947387">

<p>说明，成员方法都是在代码区中被当前这个类的所有对象共享的，只有一份。可以理解为C++编译之后，将类中方法都解析为了代码区中的全局唯一的方法了。</p>
<p>当调用方法的时候，编译器转换为run(dog,xx,yy,zz)这样，即将当前对象作为第一个隐含参数传入给成员方法内部的this，而每个类的成员方法中的this的类型，就是当前这个类，例如，Animal中的run中的this，类型就是Animal，Dog中的成员方法中的this的类型就是Dog。</p>
<p>上例中，dog.run()调用run方法，首先根据dog的类型是Dog，因此，在代码区中Dog字节码区域中找run方法（注意，编译的时候，根据等号左边变量类型进行编译查看是调用哪个类中的成员方法的），发现没有，然后就会它的父类Animal中找这个继承的run方法，找到了，可以调用，然后将dog传入给Animal中run中的this，this的类型是Animal，可以接收子类对象，父类引用指向子类对象。但是此时在Animal中的run方法就只能访问到父类中的属性，而没有办法拿到子类中的特有的自己的属性了，原因是父类中方法run中的this是Animal类型的，它指向子类对象，但是类型是父类型，编译的时候是看等号左边根据类型进行编译，因此，this是Animal类型，那么run中就只能访问Animal中的属性。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010213205024.png" class="" title="image-20221010213205024">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010213444368.png" class="" title="image-20221010213444368">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010213528369.png" class="" title="image-20221010213528369">

<p><strong>方法的，名字一样，返回类型，参数也一样，这就是子类将父类的方法覆盖掉了。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010214158847.png" class="" title="image-20221010214158847">

<p><strong>方法重写（Override）：又叫做覆盖</strong>，子类与父类的方法<strong>返回类型一样、方法名称一样，参数一样</strong>，这样我们说子类与父类的方法构成了重写关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		dog.run();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;	</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010214406265.png" class="" title="image-20221010214406265">

<p><strong>此时两个run就不构成重写的关系了。</strong></p>
<p>所谓重写，就是子类将从父类继承过来的覆盖掉了，看不到了，用的就是子类中的了。</p>
<p><strong>上图中，就是从父类继承过来了一个run()方法，同时子类中自己又增加了一个run(int i)，这两个run之间构成了重载关系（应该不是重载，重载只是发生在同一个类中）。不构成覆盖关系。</strong></p>
<p>此时上面的dog.run调用的时候，如果dog.run()，调用的就是从父类继承而来的run了。</p>
<p><strong>注意，重载只是发生的同一个类中的。覆盖是发生在父类子类之间的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		dog.run(<span class="number">1</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">	&#123;	</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java InheritenceTest2</span><br><span class="line">dog is running</span><br></pre></td></tr></table></figure>

<p>【说明】次处就不应该是重写，子类从父类当中继承了run()方法，而本身一个带参数的run(int i)的方法，所以只能说子类对父类的run()方法进行了重载，此时子类当中应该有两个run方法，一个是带参数的，一个是不带参数的，所以如果main方法中传递不带参数的run方法，则程序执行结果不同，参考以下程序。<br><strong>注意，两个run方法仍然是分别在代码区中两个类Animal和Dog自己的字节码当中的。只是从逻辑上讲子类继承了父类，父类的方法也在子类中了而已。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		dog.run();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">	&#123;	</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java InheritenceTest2</span><br><span class="line">animal is running</span><br></pre></td></tr></table></figure>

<p>注意，编译的时候，是根据赋值号&#x3D;左边的变量类型来看对应类中是否有要调用的成员方法或者要访问的成员变量，如果有，那么编译通过的，如果没有，编译失败。而运行的时候，是看具体引用变量指向的是哪个对象，从而调用对应那个对象所属类型的方法的（这是多态内容）。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220242889.png" class="" title="image-20221010220242889">

<p><strong>方法重写与方法重载之间的关系：重载发生在同一个类内部的两个或多个方法。重写发生在父类与子类之间。重载是一种平行的关系，重写是一种层次关系，伴随着继承而发生的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220403437.png" class="" title="image-20221010220403437">

<p>在子类中不仅想执行自己的方法，还想调用父类被覆盖的方法。这个时候，可以使用super，表示对父类的引用。</p>
<h3 id="super第二种用法（子类覆盖父类成员方法之后，仍然想调用被覆盖的父类方法）"><a href="#super第二种用法（子类覆盖父类成员方法之后，仍然想调用被覆盖的父类方法）" class="headerlink" title="super第二种用法（子类覆盖父类成员方法之后，仍然想调用被覆盖的父类方法）"></a>super第二种用法（子类覆盖父类成员方法之后，仍然想调用被覆盖的父类方法）</h3><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220514961.png" class="" title="image-20221010220514961">

<p><strong>通过super调用父类中被覆盖了的方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220707682.png" class="" title="image-20221010220707682">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010220718947.png" class="" title="image-20221010220718947">

<p><strong>Super是对父类对象的引用。因此super.run()，就是对父类对象的方法的调用。</strong></p>
<p>这里的super可以理解为堆区中new的子类对象中的从父类继承来的父类的属性那些部分所组成的部分，认为是父类对象。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221132394.png" class="" title="image-20221010221132394">

<p>super.run()，可以理解为run(super)，由于super是Animal类型，因此，调用的run自然是父类型中的run。因此，super传给父类型run方法中的this。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221308790.png" class="" title="image-20221010221308790">

<p><strong>这样是可以的，因为这里的super不是调用的父类的构造方法，是调用的父类的普通的方法，那么既然能够调用父类的普通方法，说明父类对象已经生成出来了。</strong></p>
<p><strong>而如果是构造方法中，那么就必须先去构造父类对象，然后才能构造子类对象。因此，对于构造方法来说，必须super()是第一条语句。而对于普通方法来说，就无所谓了。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221357409.png" class="" title="image-20221010221357409">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221421889.png" class="" title="image-20221010221421889">

<p>当两个方法形成重写关系时，可以在子类方法中通过super.run()形式调用父类的run()方法，其中super.run()不必放在第一行语句【此处super.run()与super();是不同的】，因为此时父类对象已经构造完毕，先调用父类的run()方法还是先调用子类的run()方法是根据程序的逻辑决定的。</p>
<p><strong>Java中类没有显示的继承，那么就是继承Object类的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010221617310.png" class="" title="image-20221010221617310">

<p>在定义一个类的时候，如果没有显式指定该类的父类，那么该类就会继承于java.lang.Object类（JDK提供的一个类，Object类是Java中所有类的直接或间接父类）。Object类是Java中所有类的直接或间接父类。Object中的定义的十个方法每个都很重要，后续说明。</p>
<p><strong>当继承层次很多的时候，那么生成最底层子类对象的时候，上面每一层的构造方法都会自动被调用，创建对应的层次类的对象。</strong></p>
<p>继承中构造方法调用顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritenceTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Son</span> <span class="variable">son</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandpa</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Grandpa</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;grandpa&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> <span class="keyword">extends</span> <span class="title class_">Grandpa</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;father&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;son&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java InheritenceTest3</span><br><span class="line">grandpa</span><br><span class="line">father</span><br><span class="line">son</span><br></pre></td></tr></table></figure>



<h3 id="多态基础"><a href="#多态基础" class="headerlink" title="多态基础"></a>多态基础</h3><p><strong>多态：多种形态。构建在封装以及继承基础之上的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222027981.png" class="" title="image-20221010222027981">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222035061.png" class="" title="image-20221010222035061">

<p>现在是Flower类型的引用变量，指向了Rose类型的对象。奔驰叫车是汽车。</p>
<p><strong>子类就是父类，这就是多态。男人是人。但是反之是不对的。</strong></p>
<p>Flower rose &#x3D; new Rose()，这里Rose()本身也是花，虽然本身玫瑰，但是子类就是父类，因此，可以认为就是花。因此，Flower类型的引用可以指向Rose类型的对象。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222132752.png" class="" title="image-20221010222132752">

<p>多态（Polymorphism）：我们说子类就是父类（玫瑰是花，男人是人），因此<strong>多态的意思就是：父类型的引用可以指向子类的对象</strong>。多态是构建在封装和继承之上的。</p>
<p>反之不行，不能用子类型的引用指向父类型的对象。</p>
<p><strong>查看java编程思想3版中的第七章，多态。看summary。总结。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222306412.png" class="" title="image-20221010222306412">

<p>多态就是不同形式。面向对象中，你有相同的脸（基类中通用的接口）和使用那个脸的不同的形式：动态绑定方法的不同的版本。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222340053.png" class="" title="image-20221010222340053">

<p>如果没有数据抽象（封装）和继承，那么我们不可能创建理解，创建一个多态的例子。多态是一个不能被孤立看待的一个特征，相反，应该在一个大的类关系的场景中，多态存在的，<strong>人们经常被其它的java中的非面向对象的特征所困扰，例如，方法重载，有时候被当作面向对象的特征，不要被愚弄，如果不是晚绑定，那么它就不是多态。对于方法的重载，它不是晚绑定，它是早绑定。</strong></p>
<p><strong>早绑定，编译期间的，也就是编译的时候，java编译器就知道参数是什么样的，如何进行调用的。</strong></p>
<p><strong>晚绑定，就是运行的时候，java才知道如何执行，编译的时候，java是不知道的。也就是只有运行的时候，才知道父类型的引用变量到底指向的是哪个子类的对象。这个在编译的时候，编译器只是看等号两边的类型是否是同一颗继承树上的，来判断语法是否正确，但是不知道这个引用变量到底指向哪个对象，因为对象还没创建呢。</strong></p>
<p><strong>方法重载，不是晚绑定，不是面向对象的特征，多态不是由它来决定的。多态是晚绑定的。如果不是晚绑定，就一定不是多态。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010222955977.png" class="" title="image-20221010222955977">

<p>要使用多态，你必须扩展视角包括不仅仅是单独的类成员和方法，而且应该考虑不同类之间的关系。</p>
<p>因为多态能够实现更快的开发，代码的更好的组织，以及维护性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Flower</span> <span class="variable">rose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rose</span>(); <span class="comment">//多态</span></span><br><span class="line">		rose.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flower</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;flower is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rose</span> <span class="keyword">extends</span> <span class="title class_">Flower</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">flower is singing</span><br></pre></td></tr></table></figure>

<p>【说明】：Flower rose &#x3D; new Rose(); &#x2F;&#x2F;多态    Flower类型的引用指向Rose的对象。</p>
<hr>
<h3 id="多态详解1"><a href="#多态详解1" class="headerlink" title="多态详解1"></a>多态详解1</h3><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010223545556.png" class="" title="image-20221010223545556">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010223551498.png" class="" title="image-20221010223551498">

<p>Java源文件中可以定义多个类，这些类可以都不是public的，如果有public，那么最多只能有一个，并且文件的名字必须要public的类的名字相同。并且main方法必须在public类里面来进行定义（这个不是强制的，main方法也可以在非public的类当中，因为编译之后，每个类会产生一个class文件的，可以java去运行含有main方法的类的。而没有main方法的类，即使是public的，也没法运行的。另外，如果使用myeclipse的话，那么在一个文件中定义多个类，只能有一个类是public的，并且文件名就是这个类名，如果main方法定义在了其它的非public类中的话，那么在这个源文件中就不能右键-运行，因为在当前这个文件上点右键-运行，必须得是在这个public类中写main方法了。）。如果源文件中定义的多个类都不是public，那么源文件的名字可以随意。</p>
<p>方法的返回值类型，不能作为重载的条件。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224520330.png" class="" title="image-20221010224520330">

<p><strong>构造方法重载只看参数就行，因为，多个构造方法的名字肯定都是一样的，都是类名。</strong></p>
<p><strong>构造方法没有返回值类型的。也就是没有返回值。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224548054.png" class="" title="image-20221010224548054">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224554837.png" class="" title="image-20221010224554837">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224611299.png" class="" title="image-20221010224611299">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224634118.png" class="" title="image-20221010224634118">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010224641469.png" class="" title="image-20221010224641469">

<p><strong>注意，super()和this()在构造函数中，不能同时出现，否则是矛盾的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225223376.png" class="" title="image-20221010225223376">

<p>13，覆盖说法不是很严格，后续学完其它内容会严格说明。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225251756.png" class="" title="image-20221010225251756">









<p><strong>多态：父类型的引用指向子类型的对象</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225430173.png" class="" title="image-20221010225430173">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225438880.png" class="" title="image-20221010225438880">

<p><strong>注意，引用变量指向谁，就会调用谁的方法。P虽然声明的是父类型的引用，但是程序运行起来之后，指向的是子类型的对象，因此，就会调用子类型对象的方法。只是在编译的时候，是根据赋值&#x3D;等号左边的类型去编译，看对应类型中是否有要调用的方法的，有，则编译通过，否则编译失败。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225627564.png" class="" title="image-20221010225627564">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225639907.png" class="" title="image-20221010225639907">

<p>现在将子类的方法注释掉。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225703268.png" class="" title="image-20221010225703268">

<p><strong>现在子类中没有显示定义这个方法了，那么由于从父类继承过来了sing这个方法了，因此，就会调用继承过来的方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225732085.png" class="" title="image-20221010225732085">

<p><strong>注意，编译的时候同理，仍然是看等号左边的类型来进行编译的。由于p的类型是Parent，而Parent中有sing方法，因此，能够编译通过。而如果父类中没有sing方法，而只是子类中新定义了一个sing方法，那么上面编译就会失败，因此，编译时候看等号左边，发现Parent中没有sing方法，那么就编译失败。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225907900.png" class="" title="image-20221010225907900">

<p>现在将父类的注释。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225925621.png" class="" title="image-20221010225925621">

<p><strong>现在父类没有sing方法，子类有sing方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010225957428.png" class="" title="image-20221010225957428">

<p>可以看到，在Parent中找sing方法。找不到，报错。</p>
<p><strong>因为，编译的时候，jvm是看引用变量的类型当中是否有对应的方法来进行编译的，也就是静态的，因为还没运行，没有对象呢，自然不知道引用变量到底指向哪个对象的。</strong></p>
<p><strong>也就是说p虽然是指向子类对象的引用，但是p这个变量的类型是Parent，而Parent中现在没有sing方法，也就是说，对于多态，父类型的引用变量，指向子类型的对象，然后调用了子类对象的某个方法，那么就要求，这个方法必须在父类中也要存在，因为这个p本身是父类型的。那么什么类型的才能使用什么类型的方法，虽然实际指向的是子类的对象。不能说父类中没有这个方法，子类中有，然后进行调用，这样调用不了的，编译的时候，看到的p的类型就是Parent类型的，因此首先就是检查父类中是否有这个方法的。如果有这个方法，然后在执行的时候，创建了对象了，父类型引用指向了子类型对象了（动态绑定），再去子类对象中调用不管是继承过来的还是重写的那个sing方法。</strong></p>
<p>因此，要分清两个时机：编译时（类型中是否有成员方法或者成员变量检查）和运行时（动态绑定）</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010232134731.png" class="" title="image-20221010232134731">

<p><strong>编译的时候，肯定是看什么类型的引用变量，那么就调用什么类型里面的方法，是这种规则去编译检查的。因为编译的时候，还不能确定p到底指向的是什么对象，也就是说，编译的时候，都是字面上看到的，都是静态的，而new的对象是在运行的时候才会创建的。只有运行的时候，才知道p指向的具体的对象是谁，动态绑定。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Parent</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line">		parent.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;parent is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;child is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">parent is singing</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	Parent parent = new Parent();</span></span><br><span class="line"><span class="comment">//	parent.sing();</span></span><br><span class="line">	<span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">	child.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">child is singing</span><br></pre></td></tr></table></figure>

<p>上面这两种情况都不是多态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//	Parent parent = new Parent();</span></span><br><span class="line"><span class="comment">//	parent.sing();</span></span><br><span class="line"><span class="comment">//	Child child = new Child();</span></span><br><span class="line"><span class="comment">//	child.sing();</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">Parent</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">	p.sing();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">child is singing</span><br></pre></td></tr></table></figure>

<p>多态。</p>
<p>【说明】：Parent p &#x3D; new Child(); p类型是父类型，<strong>看类型是要左边的那个Parent</strong>。指向了子类生成的属性，接下来调用sing();方法，指向child(),就调用子类的方法，所以输出子类的方法，指向谁就调用谁的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	Parent parent = new Parent();</span></span><br><span class="line">	<span class="comment">//	parent.sing();</span></span><br><span class="line">	<span class="comment">//	Child child = new Child();</span></span><br><span class="line">	<span class="comment">//	child.sing();</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Parent</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">		p.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;parent is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	public void sing()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;child is singing&quot;);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">parent is singing</span><br></pre></td></tr></table></figure>

<p>【说明】：此时子类继承了父类的sing()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	Parent parent = new Parent();</span></span><br><span class="line">	<span class="comment">//	parent.sing();</span></span><br><span class="line">	<span class="comment">//	Child child = new Child();</span></span><br><span class="line">	<span class="comment">//	child.sing();</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">Parent</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">		p.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*	</span></span><br><span class="line"><span class="comment">	public void sing()</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		System.out.println(&quot;parent is singing&quot;);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;child is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest.java</span><br><span class="line">PolyTest.java:<span class="number">11</span>: 错误: 找不到符号</span><br><span class="line">                p.sing();</span><br><span class="line">                 ^</span><br><span class="line">  符号:   方法 sing()</span><br><span class="line">  位置: 类型为Parent的变量 p</span><br><span class="line"><span class="number">1</span> 个错误</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【说明】：p是指向子类对象的引用，但是p还是Parent类型的，而Parent中没有这个方法,对于多态可以这样理解，即便p是指向子类，但是必须在p所在类型Parent中必须存在这个方法，才可以调用。p在调用子类的方法的时候，会去检查p所在类型是否有这个方法，如果有的话，就调用子类的方法，否则报错。</p>
<p><strong>Parent p &#x3D; new Child();当使用多态方式调法时，首先检查父类中是否有sing()方法,如果没有则编译出错；如果有再去调用子类的sing()方法。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010232355466.png" class="" title="image-20221010232355466">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010232407838.png" class="" title="image-20221010232407838">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233148296.png" class="" title="image-20221010233148296">

<p><strong>父类型的引用转换为子类型的引用，向下类型转换。转换的原则是，这个引用变量实际指向的是什么类型的，那么就向下转换为什么类型的。</strong><br><strong>转换之后，那么就能调用子类型中的特有的方法了（子类中新增的，不是从父类继承而来的），父类型中方法仍然能够调用（因为子类中如果没有覆盖的，那么就会去父类中找）。因为，在编译阶段，引用变量到底能够调用什么方法，主要是看它的类型的，看它类型中有什么方法的。是在编译阶段的。</strong><br><strong>向下类型转换的另外一个目的，就是可以调用子类中特有的方法，在父类中没有的方法了。否则不转换的话，直接调用子类中特有的方法，编译会报错，因为编译的时候是看等号左边引用变量的类型的，而此时a的类型是Animal，它里面肯定没有子类中新增的特有的方法的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233717761.png" class="" title="image-20221010233717761">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233748051.png" class="" title="image-20221010233748051">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233807474.png" class="" title="image-20221010233807474">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233814291.png" class="" title="image-20221010233814291">

<p>这样是错误的。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233833440.png" class="" title="image-20221010233833440">

<p><strong>编译是能够通过的，因为，编译的时候，不知道b到底是指向谁呢，只有运行的时候，才会知道。编译的时候只是知道b的类型是Animal类型。</strong></p>
<p><strong>也就是编译的时候，只要看类型转换的时候，等号两边变量的类型是否在同一颗继承树上，是同一颗继承树，就允许你转换。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221010233935947.png" class="" title="image-20221010233935947">

<p>运行时错误。</p>
<p><strong>因此，向下类型转换，就是这个引用变量指向哪个子类对象，那么就能够转换为那个子类的引用。指向谁，就转成谁。</strong></p>
<p><strong>通过上面可以看到，编译时候没错，运行时报错，因此，多态是一个运行期的行为，而不是编译期的行为。也就是java程序，只有到真正运行的时候，才知道这个b到底是指向的什么对象。编译的时候，只是知道b是Animal类型的，但是具体指向谁是不知道的，因为右边的new对象，还没有开辟内存创建对象呢。</strong></p>
<p><strong>编译的时候，只是知道b是Animal类型的，而d是Dog类型的，在同一个继承树上的上下继承关系，因此，能够向下类型转换。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">		<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">		dog.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;cat is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest</span><br><span class="line">dog is singing</span><br></pre></td></tr></table></figure>

<p>【说明】：Animal a &#x3D; new Dog(); Dog dog &#x3D; (Dog)a;这两条语句是一个强制类型转换，将一个父类型的引用强制转为子类型的引用,这在多态中叫做向下类型转换，注意的是它实际指向的是谁，才能转换成谁。比如a实际指向的是Dog对象，所以才能强制类型转换为Dog类型的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">dog.sing();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)b;</span><br><span class="line">cat.sing();</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest2</span><br><span class="line">dog is singing</span><br><span class="line">cat is singing</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog)a;</span><br><span class="line">dog.sing();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> (Dog)b;</span><br><span class="line">d.sing();</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest2.java</span><br><span class="line">D:\src&gt;java PolyTest2</span><br><span class="line">dog is singing</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: Cat cannot be cast to Dog</span><br><span class="line">        at PolyTest2.main(PolyTest2.java:<span class="number">9</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【说明】:这个程序在编译的时候没有提示错误，在执行字节码文件时候出现错误，提示类转换异常：猫不能转换成狗。因为b指向的是Cat类型的对象，而在转换后变成b指向了Dog类型的引用，所以出错。向下类型转换的引用指向那个对象，才能强制类型转换为这个类型的引用。</p>
<hr>
<h3 id="多态详解2"><a href="#多态详解2" class="headerlink" title="多态详解2"></a>多态详解2</h3><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011000538482.png" class="" title="image-20221011000538482">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011000543778.png" class="" title="image-20221011000543778">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">		<span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"> </span><br><span class="line">		animal2 = animal;</span><br><span class="line">		animal2.sing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;animal is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;dog is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;cat is singing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093251866.png" class="" title="image-20221011093251866">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093258188.png" class="" title="image-20221011093258188">

<p><strong>指向谁，就调用谁的方法。类型转换的时候，就转换成谁。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Animal animal = new Cat();</span></span><br><span class="line"><span class="comment">Animal animal2 = new Animal();</span></span><br><span class="line"><span class="comment">animal2 = animal;</span></span><br><span class="line"><span class="comment">animal2.sing();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"> </span><br><span class="line">animal = animal2;</span><br><span class="line">animal.sing();</span><br></pre></td></tr></table></figure>



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093320821.png" class="" title="image-20221011093320821">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093340701.png" class="" title="image-20221011093340701">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093349478.png" class="" title="image-20221011093349478">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093355815.png" class="" title="image-20221011093355815">

<p><strong>可以看到，编译通过（向下类型转换），运行时错误。因为编译的时候，只要看左右两边变量类型是在同一颗继承树上，那么就没问题。</strong></p>
<p><strong>因为Cat是Animal的一个子类，因此，在编译的时候，编译器只是知道这些信息，但是animal这个变量到底指向的是谁，只有在执行的时候才能够确定下来，而在执行的时候，jvm发现，animal指向的是一个Animal类型的对象而不是指向的Cat类型的对象，那么强制转为Cat类型，就肯定错误的了，就例如，将动物强制转换为猫，就肯定不对了。指向谁才能转换成谁，例如，指向Cat才能转换为Cat。现在指向的是Animal，就不能转为Cat。</strong></p>
<p><strong>注意，所谓的奔驰轿车是汽车，这种说法，是从继承多态的角度来说的，也就是说的都是等号左边的类型，而不是具体的实例对象，也就是说的奔驰轿车是指子类型，汽车是父类型。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Animal animal = new Cat();</span></span><br><span class="line"><span class="comment">Animal animal2 = new Animal();</span></span><br><span class="line"><span class="comment">animal2 = animal;</span></span><br><span class="line"><span class="comment">animal2.sing();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Animal animal = new Cat();</span></span><br><span class="line"><span class="comment">Animal animal2 = new Animal();</span></span><br><span class="line"><span class="comment">animal = animal2;</span></span><br><span class="line"><span class="comment">animal.sing();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Cat cat = new Cat();</span></span><br><span class="line"><span class="comment">Animal animal = cat;</span></span><br><span class="line"><span class="comment">animal.sing();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat)animal;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest2.java</span><br><span class="line">D:\src&gt;java PolyTest2</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.ClassCastException: Animal cannot be cast to Cat</span><br><span class="line">        at PolyTest2.main(PolyTest2.java:<span class="number">25</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【说明】：在编译的时候系统只知道Cat是Animal的子类，具体Animal指向谁只有在执行的时候才能够发现，当执行的时候发现animal的引用指向的是animal类型的对象，此时把它强制转换为cat，系统就会提示错误，就好比如将一个人强制的转换成一个男人，这样是不对的。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011093916309.png" class="" title="image-20221011093916309">

<p>一共有两种类型的强制转换：</p>
<p>a) 向上类型转换(upcast):比如说将Cat类型转换为Animal类型,即将子转换为父类型。</p>
<p>b) 向下类型转换(downcast):比如将Animal类型转换为Cat类型。即将父转换为子类型。对于向下，必须要显式指定(必须要使用强制类型转换)。</p>
<p><strong>注意，向下类型转换的时候，转换的都是等号左边的引用变量的类型，而不是堆中的对象，堆中的对象就是对应的实际的类型的对象，不能进行类型转换的。</strong></p>
<p>Animal animal &#x3D; new Cat()，这就是向上类型转换。</p>
<p>Cat cat &#x3D; new Cat()</p>
<p>Animal animal &#x3D; cat</p>
<p>animal.sing()</p>
<p>这种也是向上类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向上类型转换</span></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"><span class="comment">//Animal animal = (Animal)cat;这种写法也可以，但是通常不需要显示的制定，因为向上类型转换通常认为子类就是父类了，不需要强制类型转换。</span></span><br><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> cat;</span><br><span class="line">animal.sing();</span><br></pre></td></tr></table></figure>



<p><strong>多态中，子类就是父类，这种说法是对的。但是父类就是子类，这种说法就不对，因为父类引用必须是指向子类对象，才能说父类就是子类。</strong></p>
<p><strong>向下类型转换的时候，要看父类型的引用到底指向的是谁，如果父类型的引用就是指向的父类型的对象，那么就不能向下类型转换了。编译通过，运行的时候就错误。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011094946893.png" class="" title="image-20221011094946893">

<p><strong>这里调用a.sing()和调用cat.sing()效果一样的，因为都指向的Cat类型的对象。但是为何还要使用向下类型转换呢？原因是，父类没有的，子类可以添加，也就是子类中可能具有父类没有的方法，因此，这个时候，就只能向下转换为子类引用，然后才能调用子类特有的方法。如果不向下类型转换的话，那么这个引用变量的类型就是父类型的，而调用方法的时候，编译器是看等号左边变量类型确定调用哪个类方法的，是根据变量的类型中有什么方法来进行调用的，这样就只能调用父类型中有的方法了。因此，就需要进行向下类型转换才行。</strong></p>
<p>【说明】:在向下类型转换中，比如这个程序调用c.sing();方法和调用a.sing();方法执行效果是一样的，为什么还要做这种先下类型转换呢?比如说父类中3个方法，子类继承了或者重写了父类的三个方法，此时使用向下类型转换意义不大，因为调用使用与不使用都是调用子类这三个方法一个。但是有一种情况是，假如这个子类自己添加了5个方法，此时父类有3个方法，子类有8个方法，此时如果调用a.sing();这种方法时只能调用在子类当中存在于父类当中的那三个方法，其他五个方法是没法调用到的，因为a是父类型，所以只能调用父类型中有的方法，此时如果使用向下转型之后,调用c.sing();此时c是属于子类型的所以可以调用子类当中的所有方法，这就是使用向下类型转换的原因。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011095445186.png" class="" title="image-20221011095445186">

<p><strong>因为编译的时候是看等号左侧的引用变量的类型，来确定调用的成员方法是否合法，如果不向下类型转换，那么引用变量的类型是父类型，那么就只能看到父类型中的那些成员方法的。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100454704.png" class="" title="image-20221011100454704">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100505293.png" class="" title="image-20221011100505293">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100518872.png" class="" title="image-20221011100518872">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100527742.png" class="" title="image-20221011100527742">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100542693.png" class="" title="image-20221011100542693">

<p>上面这个程序，是否使用强制类型转换，其实无所谓。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100602190.png" class="" title="image-20221011100602190">

<p>grow方法是子类中新增的成员方法。</p>
<p>子类添加特有的方法。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100629886.png" class="" title="image-20221011100629886">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011100640042.png" class="" title="image-20221011100640042">

<p><strong>编译的时候，只能看到f是Fruit类型的，因此，去到这个类型中看是否有这个grow方法，有才能编译通过。而父类中是没有这个方法的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="comment">//不使用强制类型转换</span></span><br><span class="line">		<span class="type">Fruit</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">		f.grow();</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//使用强制类型转换</span></span><br><span class="line">	<span class="comment">//	Fruit f = new Pear();</span></span><br><span class="line">	<span class="comment">//	Pear p = (Pear)f;</span></span><br><span class="line">	<span class="comment">//	p.grow();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;fruit is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pear</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;pear is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;pear is growing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest3.java</span><br><span class="line">PolyTest3.java:<span class="number">7</span>: 错误: 找不到符号</span><br><span class="line">                f.grow();</span><br><span class="line">                 ^</span><br><span class="line">  符号:   方法 grow()</span><br><span class="line">  位置: 类型为Fruit的变量 f</span><br><span class="line"><span class="number">1</span> 个错误</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101327594.png" class="" title="image-20221011101327594">

<p><strong>现在强制类型转换，然后p的类型就是Pear，那么编译的时候，看到的Pear里面有grow方法，所以，编译通过。</strong></p>
<p>向下类型转换。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101411833.png" class="" title="image-20221011101411833">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;		</span><br><span class="line">		<span class="comment">//不使用强制类型转换</span></span><br><span class="line">	<span class="comment">//	Fruit f = new Pear();</span></span><br><span class="line">	<span class="comment">//	f.grow();</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">//使用强制类型转换</span></span><br><span class="line">		<span class="type">Fruit</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">		<span class="type">Pear</span> <span class="variable">p</span> <span class="operator">=</span> (Pear)f;</span><br><span class="line">		p.grow();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;fruit is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pear</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;pear is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;pear is growing&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest3</span><br><span class="line">pear is growing</span><br></pre></td></tr></table></figure>



<p><strong>因此，强制类型转换，是在子类中具有子类特有的方法，父类中没有这个方法的时候，才有使用的必要。</strong></p>
<p><strong>多态是运行期的行为，不是编译期的行为，此前的例子，都是在编译的时候，眼睛直接能够看到引用变量指向的是谁，下面的例子是在编译的时候，我们眼睛看不出指向的是谁，只有运行的时候才知道。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101546262.png" class="" title="image-20221011101546262">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101552998.png" class="" title="image-20221011101552998">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101603512.png" class="" title="image-20221011101603512">

<p>这就说明了多态是运行期的行为，只有运行的时候，才知道调用哪个类的method方法。</p>
<p>编译之后，java执行环境不知道，a到底现在是指向的哪个对象，只有运行的时候才会知道。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011101642242.png" class="" title="image-20221011101642242">

<p>【说明】：编译的时候不知道a指向的是哪个方法，只有在执行的时候输入一个参数来确定具体执行哪个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">&quot;1&quot;</span>)) <span class="comment">//命令行输入1时执行if里面的语句。</span></span><br><span class="line">		&#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="title class_">B</span>();	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">&quot;2&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">&quot;3&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			a = <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		a.method();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac PolyTest4.java</span><br><span class="line">D:\src&gt;java PolyTest4 <span class="number">1</span></span><br><span class="line">B</span><br><span class="line">D:\src&gt;java PolyTest4 <span class="number">2</span></span><br><span class="line">C</span><br><span class="line">D:\src&gt;java PolyTest4 <span class="number">3</span></span><br><span class="line">D</span><br></pre></td></tr></table></figure>



<p><strong>这就是晚绑定，也就是编译的时候，不知道，只有执行的时候，才能确定跟哪个对象绑定。编译的时候，不知道a到底指向哪个对象。</strong></p>
<p><strong>上面的程序，目前来说，无法实现向下类型转换，因为要向下类型转换，必须明确知道a指向的是谁，但是现在a到底指向谁只有运行的时候才知道。这个需要反射学完才能解决。这个向下类型转换只有运行期的时候才能知道，而反射正好是一个运行期的东西。</strong></p>
<p><strong>所谓晚绑定，就是只有在运行的时候，才能够确定等号左边的引用变量，具体是和哪个对象（父类对象还是子类对象）绑定的，也就是具体是指向哪个对象的。</strong></p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest5</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(BMW bmw)</span></span><br><span class="line">	&#123;</span><br><span class="line">		bmw.run();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(QQ qq)</span></span><br><span class="line">	&#123;</span><br><span class="line">		qq.run();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">PolyTest5</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PolyTest5</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="type">BMW</span> <span class="variable">bmw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BMW</span>();</span><br><span class="line">		test.run(bmw);</span><br><span class="line"> </span><br><span class="line">		<span class="type">QQ</span> <span class="variable">qq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QQ</span>();</span><br><span class="line">		test.run(qq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;car is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;bmw is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QQ</span> <span class="keyword">extends</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;qq is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest5</span><br><span class="line">bmw is running</span><br><span class="line">qq is running</span><br></pre></td></tr></table></figure>

<p>那么现在又增加了很多车型，都继承了Car这个类，然后在PloyTest5中相应的就要增加对应处理这个车的run方法。这样，显然麻烦，那么为何不使用一个方法，然后能够处理所有的车型。这样比较好。</p>
<p>【说明】：这个程序的缺点是如果再添加子类，在子类中又添加方法，此时相应的也需要在PolyTest5类中继续定义run()方法，此种效果比较差，如果用只用一个方法来实现这种机制是最好，所以引申出下面这个程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolyTest5</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Car car)</span></span><br><span class="line">	&#123;</span><br><span class="line">		car.run();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">PolyTest5</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PolyTest5</span>();</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//有以下两种方式。</span></span><br><span class="line">		<span class="comment">//用父类型的引用生成子类型的对象</span></span><br><span class="line">		<span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BMW</span>();</span><br><span class="line">		test.run(car);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">//向上类型转换</span></span><br><span class="line">		<span class="type">QQ</span> <span class="variable">qq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QQ</span>();</span><br><span class="line">		test.run(qq);</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;car is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BMW</span> <span class="keyword">extends</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;bmw is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QQ</span> <span class="keyword">extends</span> <span class="title class_">Car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;qq is running&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java PolyTest5</span><br><span class="line">bmw is running</span><br><span class="line">qq is running</span><br></pre></td></tr></table></figure>

<p>【说明】：这种程序比较容易维护，如果子类继续添加，只要知道父类，子类就都可以作为参数传上去，因为Car是父类型，子类型的引用都可以传上去，实现先上转型，一个方法就可以应付所有的此类需求，这就是多态度给我们带来的好处，它屏蔽掉了子类的差异性，用一个公共的父类去标示着接口，不管增加了多少子类，都可以通过将父类型的引用作为一个参数，具体的子类引用传过去就可以了。</p>
<p><strong>这就是多态的作用，使用一个公共的方法，屏蔽了，各个子类之间的不同，只需要一个run方法即可了。</strong></p>
<hr>
<h3 id="多态详解3"><a href="#多态详解3" class="headerlink" title="多态详解3"></a>多态详解3</h3><img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011103811265.png" class="" title="image-20221011103811265">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011114258348.png" class="" title="image-20221011114258348">



<p>抽象类(abstract class)：使用了abstract关键字所修饰的类叫做抽象类。抽象类无法实例化，也就是说，不能new出来一个抽象类的对象(实例)。</p>
<p><strong>含有抽象方法的类，必须定义为抽象类。但是抽象类中不一定就必须有抽象方法。抽象类中可以什么都没有。也可以全都是具体方法</strong></p>
<p><strong>抽象方法是有声明，无实现。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011114404739.png" class="" title="image-20221011114404739">



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac Test.java</span><br><span class="line">Test.java:<span class="number">5</span>: 错误: T是抽象的; 无法实例化</span><br><span class="line">                <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">                      ^</span><br><span class="line"><span class="number">1</span> 个错误</span><br></pre></td></tr></table></figure>

<p><strong>【说明】：以上程序错误的原因是抽象类不能被实例化</strong></p>
<p><strong>抽象方法(abstract method)：使用abstract关键字所修饰的方法叫做抽象方法(有声明，无实现)。抽象方法需要定义在抽象类中。相对于抽象方法，之前所定义的方法叫做具体方法(有声明，有实现)。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例程序中定义一个抽象方法：public abstract void method();注意直接用分号结束，没有花括号，没有花括号表示没有实现这个方法，注意的是如果有花括号即便是花括号里面没有内容，这也算是有实现的，只不过这个方法体为空，空实现。</p>
<p>如果一个类包含了抽象方法，那么这个类一定是抽象类。</p>
<p>如果某个类是抽象类，那么该类可以包含具体方法(有声明，有实现)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成功。</p>
<p>如果一个类中包含了抽象方法，那么这个类一定要声明成abstract class，也就是说，该类一定是抽象类；反之，如果某个类是抽象类，那么该类既可以包含抽象方法，也可以包含具体方法，甚至什么都不包含也是可以的。</p>
<p>无论何种情况，只要一个类是抽象类，那么这个类就无法实例化。</p>
<p>在子类继承父类（父类是个抽象类）的情况下，那么该子类必须要实现父类中所定义的所有抽象方法；如果子类不实现父类的所有方法，否则，该子类需要声明成一个abstract class。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;javac Test.java</span><br><span class="line">Test.java:<span class="number">18</span>: 错误: R不是抽象的, 并且未覆盖T中的抽象方法method()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">^</span><br><span class="line"><span class="number">1</span> 个错误</span><br></pre></td></tr></table></figure>



<p><strong>两种解决办法：</strong></p>
<p><strong>第一种实现父类的抽象方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>第二种，将子类转为抽象类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	R r = new R();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【说明】：此时子类还是不能被实例化，如果想使用这个子类，还必须定义一个R的一个子类，把method的方法实现出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	R r = new R();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">R</span> <span class="keyword">extends</span> <span class="title class_">T</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【说明】：R继承了T，则R类里面有两个方法，一个方法是实现T的抽象方法，另外一个是从T当中继承下来的具体方法test()；此时把R声明为抽象类正常，应该抽象类本身可以包含具体方法，也可以包含抽象方法。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011114418322.png" class="" title="image-20221011114418322">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011114423408.png" class="" title="image-20221011114423408">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115547897.png" class="" title="image-20221011115547897">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115554010.png" class="" title="image-20221011115554010">



<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115608256.png" class="" title="image-20221011115608256">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115620734.png" class="" title="image-20221011115620734">

<p><strong>这里就是R这个类没有实现父类的method抽象方法，那么这个R就要定义为抽象类。否则就应该实现method方法才行。</strong></p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115710007.png" class="" title="image-20221011115710007">

<p>此时编译就能够通过了。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115750204.png" class="" title="image-20221011115750204">

<p>或者这样，但是此时就不能实例化R这个类了。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011115821775.png" class="" title="image-20221011115821775">

<p>也可以这样。但是R不能实例化。现在的情况就是R实现了T的method方法，然后R又定义为抽象类。</p>
<p><strong>抽象类和抽象方法的作用，就是在抽象类中定义抽象方法，然后作为一种声明，告诉这个方法是干什么用的，但是具体的实现是由子类的实现者来去完成的。不同的子类，可能有自己不同的实现方式，但是最终的目的都是这个方法声明要实现的目的，只是实现的方式不同。</strong></p>
<p>例如，定义一个排序方法，父类中定义一个抽象方法排序，但是具体的如何排的，那么我不管，不同子类自己去实现这个功能即可。</p>
<p>构造方法的作用是完成初始化的作用，就是对成员变量进行一些赋初值的操作。</p>
<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011140913527.png" class="" title="image-20221011140913527">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011140941008.png" class="" title="image-20221011140941008">

<img src="/2022/10/11/Java/JavaSE/12-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/image-20221011140956204.png" class="" title="image-20221011140956204">

<p><strong>因此，抽象类目的就是定义规则，而具体的规则如何实现是子类来进行的。</strong></p>
<p>抽象方法，抽象类有什么作用，有声明没实现？<br>这个实现是推迟到子类当中去实现的，父类实现不了，父类可以声明一个抽象方法，写一个注释，告诉这个类的实现者，告诉它我这个方法有什么用，可以让子类去实现，对于一个父类来说，可以有多个子类，而不同的子类可以实现不同的方法。比如说在父类中定义一个排序的抽象方法，而在这个父类的各个子类当中可以分别实现这个抽象方法，具体子类实现方法有可能是用冒泡排序，有可能是用哈希排序，每种实现规则的不一样，从这一点可以看出，抽象类和抽象方法主要起到一个规范，约束的作用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Triangle</span>(<span class="number">10</span>,<span class="number">6</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> shape.computerArea();</span><br><span class="line">		System.out.println(<span class="string">&quot;triangle:&quot;</span> + area);</span><br><span class="line">		</span><br><span class="line">		shape = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//前面area用完，shape指向完已经关闭，下面可以不用定义直接使用。     </span></span><br><span class="line">		area = shape.computerArea();</span><br><span class="line">	        System.out.println(<span class="string">&quot;rectangle&quot;</span> + area);	</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">computerArea</span><span class="params">()</span>; <span class="comment">//计算形状面积</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> width;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Triangle</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span>  <span class="comment">//用构造方法来完成一些初始化工作</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//注意此处用this是因为声明完构造方法之后，把方法外面的int width;和int height;给屏蔽掉了，所以这个地方要访问到外面的width和height成员变量就用this，this表示对自己的引用。这样就把方法参数传给成员变量。</span></span><br><span class="line">		<span class="built_in">this</span>.width = width;     </span><br><span class="line">		<span class="built_in">this</span>.height = height;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computerArea</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> width * height / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> width;</span><br><span class="line">	<span class="type">int</span> height;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Rectangle</span><span class="params">(<span class="type">int</span> width,<span class="type">int</span> height)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.width = width;</span><br><span class="line">		<span class="built_in">this</span>.height = height;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computerArea</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> width * height;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">D:\src&gt;java Test2</span><br><span class="line">triangle:<span class="number">30</span></span><br><span class="line">rectangle100</span><br></pre></td></tr></table></figure>

<p>【说明】：从这个例子说可以看到抽象方法起到规范，规则子类行为的作用，具体怎么实现满足这个规则由子类去实现。约束规则，比如说定义什么类型，传递什么参数等。</p>
<p><strong>抽象类不能实例化，但是可以有构造方法。</strong></p>
<p><strong>因为对于继承的子类而言，子类将抽象基类中的抽象方法都实现了，那么子类就可以实例化了，那么实例化的子类对象中的对象属性部分，就有来自抽象父类的成员变量部分，那么这个部分就需要子类构造方法中去super来调用抽象父类中的构造方法来对来自父类中的属性进行初始化。因为在子类中是没有办法直接对继承来的父类中的属性进行初始化的，因为这些属性是在父类中的，因此，需要使用父类的构造方法去初始化这些父类中的属性。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo15</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		System.out.println(b);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo15</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;demo15&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16</span> <span class="keyword">extends</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo16</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;demo16&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Demo16</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo16</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo15</span><br><span class="line">Demo16</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo16</span> <span class="keyword">extends</span> <span class="title class_">Demo15</span> &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Demo16</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;demo16&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Demo16</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo16</span>();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">Demo16</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>windows配置为openssh服务端可远程登录</title>
    <url>/2022/10/04/Windows/Service/windows%E9%85%8D%E7%BD%AE%E4%B8%BAopenssh%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>windows的openssh服务端</p>
<p><a href="https://github.com/PowerShell/Win32-OpenSSH/releases">https://github.com/PowerShell/Win32-OpenSSH/releases</a></p>
<p>配置方式如下：</p>
<p>下载安装包，32位或64位，解压，放置在任意目录。</p>
<img src="/2022/10/04/Windows/Service/windows%E9%85%8D%E7%BD%AE%E4%B8%BAopenssh%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/970770-20200922123950524-1846829508.png" class="" title="img">

<p>右键-使用powershell运行</p>
<img src="/2022/10/04/Windows/Service/windows%E9%85%8D%E7%BD%AE%E4%B8%BAopenssh%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/970770-20200922124036665-1851354777.png" class="" title="img">

<p>将openssh ssh server设置为自动启动即可。</p>
<img src="/2022/10/04/Windows/Service/windows%E9%85%8D%E7%BD%AE%E4%B8%BAopenssh%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/970770-20200922124117194-664861249.png" class="" title="img">

<p>如想卸载，右键-powershell运行uninstall-sshd.ps1即可。</p>
<p>ps：如右键-powershell运行报错，“无法加载文件….，因为在系统中进制执行脚本”。则执行如下操作即可。</p>
<p>使用管理员身份打开powershell</p>
<p>执行set-ExecutionPolicy RemoteSigned</p>
<p>之后，脚本即可正常运行。</p>
]]></content>
      <categories>
        <category>Windows</category>
        <category>Service</category>
      </categories>
      <tags>
        <tag>openssh</tag>
      </tags>
  </entry>
</search>
